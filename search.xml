<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[发布订阅与观察者]]></title>
    <url>%2F2020%2F10%2F18%2F%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%B8%8E%E8%A7%82%E5%AF%9F%E8%80%85%2F</url>
    <content type="text"><![CDATA[发布订阅与观察者模式总是被混淆，不容易分辨，其实这两种模式最初都是同一种，之后进行了一些发展与演变，才有了发布订阅这种解耦的方式，就自己的理解谈一谈这两种方式的具体区别。 两者的区别 发布订阅可以说是观察者模式的一种升级 观察者模式核心是我知道你的存在，当发生了变化时我直接通知大家发生的变化。 发布订阅模式核心是我不知道其他人是否存在，我需要告诉第三方有事件了，第三方负责去通知各个订阅人，同理各个订阅人也只是订阅了，具体会不会发生这个事件订阅人也不知道。 观察者模式是松耦合的，发布订阅是解耦合的。 解耦合当然是好事情了，但是还是需要去看具体的场景了，如果彻底解耦就需要第三方来帮助我们对接，那么无疑会增加我们的代码 如果是大型系统的对接，我们就需要使用解耦合的场景，未来我们也不知道会有那些人来使用，会有谁接入进来，所以需要一个第三方平台来管控，是比较便于后续系统的继续拓展的。 如果是我们自己内部代码，那么松耦合也是可以接受的，我们在编写代码就能掌控到全局，为了代码模块今后的拓展性，采用松耦合的方式也完全是ok的。 当发生取消操作时（不订阅），观察者模式主体是需要亲自操作的，而发布订阅模式发布者是不需要感知的。 JS简单实现两种方式 熟悉ts，推荐使用ts去实现，对于理解原理会更好一点。 观察者模式核心代码1234567891011121314151617181920212223242526// 观察者class Observer &#123; update(payload) &#123; &#125;&#125;// 事件主体class Subject &#123; constructor() &#123; this._observers = [] &#125; add(observer) &#123; this._observers.push(observer) &#125; remove(observer) &#123; const removeIndex = this._observers.indexOf(observer); if (removeIndex !== -1) &#123; this._observers.splice(removeIndex, 1); &#125; &#125; notify(payload) &#123; this._observers.forEach(observer =&gt; observer.update(payload)); &#125;&#125; 使用示例创建一个前端主题，并创建出多个开发者，最终前端更新主题，直接通知到开发者 1234567891011121314151617181920212223242526class FEObserver extends Observer &#123; constructor(name) &#123; super(); this.name = name; &#125; update(payload) &#123; console.log(`$&#123;this.name&#125;学习了-$&#123;payload.type&#125;`); &#125;&#125;const feSubject = new Subject&lt;FEPayloadType&gt;();const fe1 = new FEObserver('fe1');const fe2 = new FEObserver('fe2');feSubject.add(fe1);feSubject.add(fe2);feSubject.notify(&#123; type: 'CSS' &#125;);// fe1学习了-CSS// fe2学习了-CSSfeSubject.remove(fe2);feSubject.notify(&#123; type: 'JS' &#125;);// fe1学习了-JS 发布订阅模式核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class EventEmitter &#123; constructor() &#123; this.c = new Map(); &#125; // 订阅指定的主题 subscribe(topic, ...handlers) &#123; let topics = this.c.get(topic); if (!topics) &#123; this.c.set(topic, topics = []); &#125; topics.push(...handlers); &#125; // 取消订阅主题 unsubscribe(topic, handler) &#123; if (!handler) &#123; return this.c.delete(topic); &#125; const topics = this.c.get(topic); if (!topics) &#123; return false; &#125; const removeIndex = topics.indexOf(handler); if (removeIndex &lt; 0) &#123; return false; &#125; topics.splice(removeIndex, 1); if (topics.length === 0) &#123; this.c.delete(topic); &#125; return true; &#125; // 发布主题 publish(topic, ...args) &#123; const topics = this.c.get(topic); if (!topics) &#123; return null; &#125; return topics.map(handler =&gt; &#123; try &#123; return handler(...args); &#125; catch (e) &#123; console.error(e); return null; &#125; &#125;); &#125;&#125; 使用示例创建一个ts学习主题，进行一下订阅，之后统一发布到EventCenter 123456789101112131415161718192021222324252627282930const eventCenter = new EventEmitter();const subscriberTs1 = (content) =&gt; &#123; console.log(`subscriberTs1 receive: $&#123;content&#125;`);&#125;;const subscriberTs2 = (content) =&gt; &#123; console.log(`subscriberTs2 receive: $&#123;content&#125;`);&#125;;// 订阅事件eventCenter.subscribe('ts', subscriberTs1);eventCenter.subscribe('ts', subscriberTs2);// 发布事件eventCenter.publish('ts', '发布了一篇ts文章');// subscriberTs1 receive: 发布了一篇ts文章// subscriberTs2 receive: 发布了一篇ts文章// 取消订阅eventCenter.unsubscribe('ts', subscriberTs1);// 发布事件eventCenter.publish('ts', '发布了二篇ts文章');// subscriberTs2 receive: 发布了二篇ts文章// 取消订阅eventCenter.unsubscribe('ts');// 发布事件eventCenter.publish('ts', '发布了三篇ts文章');]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Context处理React全局共享数据]]></title>
    <url>%2F2020%2F10%2F15%2F%E4%BD%BF%E7%94%A8Context%E5%A4%84%E7%90%86React%E5%85%A8%E5%B1%80%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[推荐在FC(function component)中使用，文中基本为FC组件 之前看到过使用Context去优雅的管理全局数据，这里做一些分享与代码组织方式 用Context管理数据，更贴切React原生语法，并且新版ContextAPI性能也得以提升，之前旧版的Context发生改变时，并不能准确的知道具体有哪些子组件需要更新，需要所有组件更新（内部会有小优化去bailout跳过）,新版ContextAPI更多像是一种依赖收集，将Context改变挂载在该组件中，就可以明确知道这个组件的依赖改变了，去更新他。 (上图为ReactFiber内Context依赖) Context使用回顾使用Context实现全局主题 12345678910111213// index.jsxconst ThemeContext = React.createContext('light');const Index = () =&gt; &#123; const [theme, setTheme] = React.useState('light'); return ( &lt;ThemeContext.Provider value=&#123;theme&#125;&gt; &lt;App /&gt; &lt;/ThemeContext.Provider&gt; )&#125; 在某一个具体对的button中使用 12345678910// Button.jsxconst Button = props =&gt; &#123; // 可直接在该Button中应用主题 const theme = React.useContext(ThemeContext) return ( &lt;button &#123;...props&#125; /&gt; )&#125; 这样就避免了组件中充满了无用的透传，使代码变得较为简洁。 通过Context修改全局数据我们将状态缓存在最顶部，将state，与setState都传递下去即可，就达到了缓存在自组件内修改全局状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// CountStateContext.jsconst CountStateContext = React.createContext();// index.jsxconst Index = () =&gt; &#123; const [countState, setCountState] = React.useState(0) return ( &lt;CountStateContext.Provider value=&#123;[countState, setCountState]&#125;&gt; &lt;App /&gt; &lt;/CountStateContext.Provider&gt; )&#125;// Sub1.jsxconst Sub1 = () =&gt; &#123; const [countState, setCountState] = React.useContext(CountStateContext) return ( &lt;&gt; &lt;h1&gt;Count: &#123;countState&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; &#123;setCountState(c =&gt; c + 1)&#125;&#125;&gt;Increment CountState&lt;/button&gt; &lt;/&gt; )&#125;// Sub2.jsxconst Sub2 = () =&gt; &#123; const [countState] = React.useContext(CountStateContext) return ( &lt;&gt; &lt;h1&gt;Count: &#123;countState&#125;&lt;/h1&gt; &lt;/&gt; )&#125;// Sub3.jsxconst Sub3 = () =&gt; &#123; const [, setCountState] = React.useContext(CountStateContext) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; &#123;setCountState(c =&gt; c + 1)&#125;&#125;&gt;Increment CountState&lt;/button&gt; &lt;/&gt; )&#125; Context都传递下去的问题将一个顶层状态的state与setState都传递下去，但是不一定在所有的自组件中都会用到这两个数据 比如某个自组件中可能只是单纯想进行一个数据的修改，但是由于context中同时也依赖了state,所以当顶层组件的state发生改变时，该组件也会进行一次重新的渲染，那这样其实不符合我们的预期的，所以就将Context存储的数据拆分，那我们的核心就是读写分离！ 可能会发生Context套娃，没关系先把主要问题解决了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// CountContext.jsconst CountContext = React.createContext();const SetCountContext = React.createContext();// index.jsxconst Index = () =&gt; &#123; const [count, setCount] = React.useState(0) return ( &lt;CountContext.Provider value=&#123;count&#125;&gt; &lt;SetCountContext.Provider value=&#123;setCount&#125;&gt; &lt;App /&gt; &lt;/SetCountContext.Provider&gt; &lt;/CountContext.Provider&gt; )&#125;// Sub1.jsxconst Sub1 = () =&gt; &#123; const count = React.useContext(CountContext) const setCount = React.useContext(SetCountContext) return ( &lt;&gt; &lt;h1&gt;Count: &#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(c =&gt; c + 1)&#125;&#125;&gt;Increment CountState&lt;/button&gt; &lt;/&gt; )&#125;// Sub2.jsxconst Sub2 = () =&gt; &#123; const count = React.useContext(CountContext) return ( &lt;&gt; &lt;h1&gt;Count: &#123;count&#125;&lt;/h1&gt; &lt;/&gt; )&#125;// Sub3.jsxconst Sub3 = () =&gt; &#123; const setCount = React.useContext(SetCountContext) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(c =&gt; c + 1)&#125;&#125;&gt;Increment CountState&lt;/button&gt; &lt;/&gt; )&#125; 将Context存储的数据抽离出来目前是将所有的数据都存储在顶层组件中的，我们也可以使用一个自定义Hooks去存储我们的数据，最终附带吐出一个带有Context的组件即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// CountContext.jsxconst CountContext = React.createContext();const SetCountContext = React.createContext();function useCount() &#123; return React.useContext(CountContext)&#125;function useSetCount() &#123; return React.useContext(SetCountContext)&#125;function CountStoreProvider(&#123; children &#125;) &#123; const [count, setCount] = React.useState() return ( &lt;CountContext.Provider value=&#123;count&#125;&gt; &lt;SetCountContext.Provider value=&#123;setCount&#125;&gt; &#123;children&#125; &lt;/SetCountContext.Provider&gt; &lt;/CountContext.Provider&gt; )&#125;export &#123; useCount, useSetCount, CountStoreProvider &#125;// index.jsximport &#123; CountStoreProvider &#125; from './CountContext'const Index = () =&gt; &#123; return ( &lt;CountStoreProvider&gt; &lt;App /&gt; &lt;/CountStoreProvider&gt; )&#125;// Sub1.jsximport &#123; useCount, useSetCount &#125; from './CountContext'const Sub1 = () =&gt; &#123; const count = useCount() const setCount = useSetCount() return ( &lt;&gt; &lt;h1&gt;Count: &#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(c =&gt; c + 1)&#125;&#125;&gt;Increment CountState&lt;/button&gt; &lt;/&gt; )&#125; 最终我们创建了一个类似store的组件，即CountContext,之后便可以方便的修改我们的数据，将此Context内部的数据都封装在自定义Hooks内部，也减少了对外部代码的侵入，使用起来比较简洁。 配合Reducer使用前面一直使用useState,那么将其存储为useReducer使用范围会更广，那么将Context中存储的数据修改为reducer会更加优雅一点，这一部分就留给大家去改造了。 在线实例 另外文中一直尝试的修改数据为同步的，如果有异步的数据修改，是将其在React组件内部处理好，再同步的dispatch出去，还是可以在context组件内部去做更多异步的处理，需要大家自己去实践了。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[link-npm包]]></title>
    <url>%2F2020%2F10%2F12%2Flink-npm%E5%8C%85%2F</url>
    <content type="text"><![CDATA[可使用 yarn link 或者 npm link 一般用于本地开发，将npm包引入到项目中，而不用发布到npm仓库中，直接进行本地的一个link(实际为一个软连接)，进行引用即可。 引包原理npm引入包的时候，只要存在于node_modules目录中，（还需要在创建包的目录中添加package.json）就可以在项目中引入到。也就是说只要node_modules中存在符合规则的目录，不需要npm install也可以使用。 可以在一个项目的node_modules中引入一个软连接，这样，应用到的包即为最新的npm包。 在本地创建一个link包12345├── ./lib│ └── ./lib/math.js├── ./src│ └── ./src/index.js└── ./package.json 在项目根目录下（与package.json同级的目录）npm link或者yarn link，将该包link到全局包 在本地取消link包在项目根目录下（与package.json同级的目录）npm unlink或者yarn unlink，将该包取消软连接 引入该link包在要需要使用项目内进行关联npm link &lt;module-link-name&gt;，之后在该项目中的node_nodules中有了一个软连接，直接指向目标包 之后使用的方式和正常使用方式一样，import &lt;module-link-name&gt; 取消关联在需要取消的目录中,执行npm unlink &lt;module-link-name&gt;,即可取消该软连接]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加油,China]]></title>
    <url>%2F2020%2F09%2F03%2F%E5%8A%A0%E6%B2%B9-China%2F</url>
    <content type="text"><![CDATA[加油，中国，一起共度难关！🇨🇳🇨🇳🇨🇳]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转换hooks的开发建议]]></title>
    <url>%2F2020%2F08%2F28%2F%E8%BD%AC%E6%8D%A2hooks%E7%9A%84%E5%BC%80%E5%8F%91%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[同学，还不试一把React-hooks吗？ 使用hooks开发有一阵时间了，几乎是从推出后就尝试使用，一路走来，一顿毒打，踩了不少坑，也逐渐体会到了hooks模式下，开发方式的变化，不得不说还是要吹一波的。 接触到的最开始就是MaterialUI了，当时hooks模式正式发布后，MaterialUI也推了一版，并且官方文档就已经使用到了hooks，当时以为hooks就是存个state，后来发现完全是另一种开发组件的思想。 本篇只是希望给同学们提供一些不一样的开发思路，更多是和大家讨论一下hooks模式，涉及到具体的api使用，及更深入可去React-Hooks学习。 Hooks模式介绍2019年第一季度,React16.7正式发布，Hooks模式也可以用于生产环境中， 首先必须要明确的一点，hooks是在function组件中使用的，所以函数式组件的使用是直接调用的，比如 1234// React 16.13.0 ReactFiberHooks.new.js// Component即jsx转换后传递的 Function组件的引用let children = Component(props, secondArg); 但是基于ReactFiber架构，即有了为Function组件拓展的可能，在fiber上挂载一个hooks的链 个人认为，发布的hooks主要分为三大块方向 存储数据型 （useState, useReducer …） 主要负责将数据和’生命周期’连接起来，有了同class组件类似的this.state功能，能够满足函数式组件自己定义状态的能力。 辅助记忆型 （useMemo, useCallback …） 由于函数式组件每次都是重新执行一遍,所以自己存储的一些数据会丢失，需要重新来一次，比如使用到了一个计算较为昂贵的值，就可以使用该函数缓存起来。 工具型 （useEffect, useRef, useContext …） 使得函数式组件有了能够和React内部有了关联，比如能够对数据生命周期控制，或者能够获取到上下文Context,或是存储ref对象 Hooks解决了什么hooks开发时有两点感觉还是很不错的，能和之前class组件有不同的开发方式 以数据为生命周期之前使用class组件时，我们都是以整个组件的周期去统揽我们的各个数据，应该在这个组件什么生命周期去操作他，使用它，同样的,我们的核心是组件的生命周期，所有数据要应用到组件的生命周期，这就有一个问题，我们其实更加关心的是这个数据的生命周期。 比如我们展示一个好友列表，如果当前没数据，我们去从服务端拉起数据，同样的，如果这个数据发生了改变，需要更新好友列表时，我们需要从服务端拉取数据。那么实际上，我们就是在看这个好友列表，而且最终反应到界面，更不知道组件的生命周期状态发生了改变。 hooks模式下，则完全变成了我们对一个数据的生命周期的操作，不管当前这个组件是什么状态，只关心最终呈现到页面上，这也更符合我们的思考逻辑，同时也对开发者更加友好，减少bug的最好方式就是少写代码。 以搜索框举例我们需要通过一个搜索框中内容的改变做一些校验 Class组件中 123456789101112131415161718192021this.state = &#123; search: 'defaultValue', resultList: [],&#125;// 为了放大问题，使用间接的方式修改resultlistcomponentDidUpdate(prevState) &#123; if (prevState.search !== this.state.search) &#123; this.setState(&#123; resultList: fetchData(this.search) &#125;) &#125;&#125;// 组件挂载好，去修改默认搜索内容componentDidMount()&#123; this.setState(&#123; resultList: fetchData(this.search) &#125;)&#125; Function组件中 1234567// 设定search搜索框中的内容状态const [search, setSearch] = React.useState('defaultValue')// 当search内容发生改变时，更新结果列表const [resultList, setResultList] = React.useState([])React.useEffect(() =&gt; &#123; setResultList(fetchResult(search))&#125;, [search]) 逻辑更为集中当时用了class组件时，大部分逻辑是处于分散在各个生命周期内的，因为我们使用的类，所以必须是一个个方法，如果又要配合生命周期使用，那么state+logic+lifecycle会分散出来，然而大部分组件内状态的管理都会使用到这三个方式，能将某一部分集中起来，代码量再多的情况下，也会更好的拆分出来。 hooks开发相关建议 hooks不止是存储了this.state/this.setState 无需刻意在function组件中模拟class的周期如果真的需要class组件周期使用的，那么使用class组件是更好的方式。 大部分人会模拟生命周期，比较明显的就是didMount 123React.useEffect(() =&gt; &#123; // 模拟componentDidMount&#125;, []) 其实可以写很多个，内部使用依赖进行比较，一个空的依赖始终都是一样的，所以只会执行一次。 123456789101112// name相关操作const [name, setName] = React.useState('')React.useEffect(() =&gt; &#123; // 初始化name操作...&#125;, [])// age相关操作const [age, setAge] = React.useState(0)React.useEffect(() =&gt; &#123; // 初始化age操作...&#125;, []) 使用callback时的闭包当使用callback，他会缓存当前的执行栈相关的信息，这里的缓存如果控制不好依赖，就容易造成很大的问题，同样的window自带的setTimeout,setInterval也会有相关的问题。 比如我们需要在组件挂载3s后打印当前的state状态 12345678910111213const [count, setCount] = React.useState(0)React.useEffect(() =&gt; &#123; const timer = setTimeout(() =&gt; &#123; console.log(count) &#125;, 3000) // 根据需要进行卸载 return () =&gt; &#123; clearTimeout(timer) &#125;&#125;, [])return ( &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;increment&lt;/button&gt;) 即使同样都是用到了count,多次点击按钮，发现3s钟后打印出的count还是0,因为创建时已经绑定了环境，及count已经为0了，（使用class组件并没体现出来，this.state.count，一串引用） 使用引用去解决引用,ref 1234567891011121314const [count, setCount] = React.useState(0)const callbackRef = React.useRef()React.useEffect(() =&gt; &#123; callbackRef.current = () =&gt; &#123; console.log(count) &#125;&#125;, [count])React.useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; callbackRef.current() &#125;, 3000)&#125;, []) 最终由于count的改变，修改了callbackRef的current，并且timeout绑定的是执行栈的callbackRef,然而他的ref已经被跟新了 不要欺骗你的hookshooks的依赖项决定了当前这个hooks是否在组件渲染时重新更新，即绑定了上下文环境中的变量，所以当他缓存起来时，就已经决定了内部的各种state值，可以说已经被替换为相应的数值，不再是一个变量了。 12345678910// 组件申明时const [count, setCount] = React.useState(0)React.useEffect(() =&gt; &#123; // count ...&#125;, [])// 后续组件被缓存，可以理解为React.useEffect(() =&gt; &#123; // 0 ...&#125;, []) 当使用各种callback去优化时，一定要注意使用的依赖是否正确 hooks放置在函数组件顶部 官方说明 hooks内部的实现是挂载于fiber内的一个链表，无论是useState,还是useEffect等，React无法用一个明显的key值去区分挂载于fiber上的具体哪一个节点对应哪一个hooks，使用他们的顺序index也就成了目前最好的选择 123456789const [count, setCount] = React.useState()React.useEffect(() =&gt; &#123; // ....&#125;, [])const price = React.useMemo(() =&gt; &#123; // ....价格由一堆复杂折扣计算而来， f(discount)&#125;, [ discount ]) 之后挂载与该Fiber上的hooks链表大致为 12345&#123; (count代表的useState) , next-&gt;(useEffect)&#125;&#123; (useEffect) , next-&gt;(useEffect)&#125;&#123; (count代表的useState) , next-&gt;(price代表的useMemo)&#125;&#123; (price代表的useMemo) , next-&gt;(null)&#125; 正常情况React再次渲染时，根据出现的顺序，将Fiber上记忆的每一个hooks，依据顺序去赋值操作，正好也是对上的 如果有hooks前后出现顺序不一致，则会出现再次渲染时对不上，导致hooks调用错误 123456// 错误写法if (!isLogin) &#123; React.useEffect(() =&gt; &#123; // ..... &#125;, [])&#125; 这里想表示，某一个effect逻辑只在登陆时做检查，但是由于当前这个hooks（useEffect）是被嵌套的，很可能出现该hooks在函数内的执行顺序不一致 isLogin == true hooks对应情况 123const [count, setCount] ----&gt; React.useState 执行相关effect内部方法 ----&gt; React.useEffectconst price ----&gt; React.useMemo isLogin == false hooks对应情况 12const [count, setCount] ----&gt; React.useStateconst price ----&gt; React.useEffect 这时出现了，对不上hooks存储的相关数据与其对应的使用发生了错误，即出现了问题 正确的使用方式 将判断逻辑，嵌套内置与hooks内部 123456React.useEffect(() =&gt; &#123; if (!isLogin) &#123; // ..... &#125;&#125;, []) 无论程序执行状况是怎样的，最终都是稳定，正确的hooks调用关系 123const [count, setCount] ----&gt; React.useState 执行相关effect内部方法 ----&gt; React.useEffectconst price ----&gt; React.useMemo 需要立刻替换hooks吗可以着手于新的组件使用hooks模式（如果喜欢这种开发方式），hooks模式与class模式是可以共存的，所以并不用着力去修改。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object与Map的选用]]></title>
    <url>%2F2020%2F08%2F28%2FObject%E4%B8%8EMap%E7%9A%84%E9%80%89%E7%94%A8%2F</url>
    <content type="text"><![CDATA[12const obj = &#123;&#125;const map = new Map(); 各自的特点 Map Object 默认值 不包含任何的值，只有显式插入的键 Object上有原型，原型上的键可能会与自定义键名冲突 key类型 任意的类型 String 或者Symbol 长度 通过属性size获取 键值个数只能手动计算 性能 频繁增删键值对有一定的性能优化 对频繁增添场景未进行优化 Object 有原生的JSON相关转换方法，可以更方面的转换为json串 其key需为string,symbol相对来说有一些限制 不可直接迭代 原型上有相关方法，注意不要与key重复1234567let o = &#123;&#125;console.log(o.constructor) // Object() &#123; [native code] &#125;o.constructor = 1 // `.`操作的用法console.log(o.constructorr) // 1// 可能出问题的部分let count = o[key] || 0 // 如果key为constructor则第一次初始化不到0 Map 其key可以为任何类型。 key为正则，可以为一类数据匹配结果 key也可为对象，直接key.status = xxx &amp;&amp; key.code === xxx Map对象插入是有顺序的，可以直接迭代拿出顺序 其key不会有任何冲突，因为他是使用方法操作的数据，并不是通过.来操作数据 操作方法创建1234567let obj1 = &#123;&#125;let obj2 = &#123; name: 'zhn' &#125;let map1 = new Map()let map2 = new Map([ ['name', 'zhn']]) 增删12345678let key = 'age'let value = 18obj[key] = valuemap.set(key, value)delete obj[key]map.delete(key) 获取元素1234let key = 'name'obj[key] // zhnmap.get(key) // zhn 遍历元素Objectobject可搭配Object.keys(obj)进行遍历 object本身就不能保证顺序，但是其Object.keys可以返回一定的顺序（ES6+） 123456const object = &#123; &#125;;object['key1'] = 'value1';object['key0'] = 'value0';object; // &#123; key1: "value1", key0: "value0" &#125;object[20] = 'value20'; // 经历了隐式类型转换object; // &#123; 20: "value20", key1: "value1", key0: "value0" &#125; 借助Object遍历的方式， 123456789101112131415161718192021222324252627for(const key of Object.keys(object)) &#123; console.log(key);&#125;// key1// key2// key3for(const value of Object.values(object)) &#123; console.log(value);&#125;// value1// value2// value3for(const entry of Object.entries(object)) &#123; console.log(entry);&#125;// ["key1", "value1"]// ["key2", "value2"]// ["key3", "value3"]for(const [key,value] of Object.entries(object)) &#123; console.log(key,value);&#125;//"key1", "value1"//"key2", "value2"//"key3", "value3" object不是可迭代对象，所以不能使用for-of直接获取其值，可以使用for-in方法去获取keys Mapmap是一个可迭代的对象，并且保证了其在迭代的顺序是可以保证的 12345678910111213141516171819// forEachconst map = new Map();map.set('key1', 'value1');map.set('key2', 'value2');map.set('key3', 'value3');map.forEach((value, key) =&gt; &#123; console.log(key, value);&#125;);// key1 value1// key2 value2// key3 value3//for...of...for(const entry of map) &#123; console.log(entry);&#125;// ["key1", "value1"]// ["key2", "value2"]// ["key3", "value3"] 如何更好的选用 不能用map去代替object，只是一种补充方案 考虑键值类型，是string, symbol,如果较为简单，则使用object即可，如果有更为复杂的key类型，使用map也可以。 考虑之后遍历是否需要保证其中的顺序，map是可以保证顺序的，object的本意就是没有顺序的，而且隐式类型转换也有问题。 频繁操作性能考虑，map的结构是一个哈希结构，频繁增上有较好的性能优化效果 考虑其key的可能性，如果key是用户可自定的话，要考虑是否会覆盖，比如用户自定了toString这个键，那么使用map较好 考虑是否需要使用JSON，object原生对json串支持较好，map需要自己去做实现 考虑是否要在key上做文章，map的key为任意类型，其中改写为正则类型，会有更好的拓展延伸效果]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化多个判断分支]]></title>
    <url>%2F2020%2F08%2F28%2F%E4%BC%98%E5%8C%96%E5%A4%9A%E4%B8%AA%E5%88%A4%E6%96%AD%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[在充斥了大量的if-else的场景中，如果分支切换过多，会导致以后看起来不是很直观，需要进行策略模式的设计 使用switch适用于操作不多的情况，直接做一些转换，比如redux中就使用了这种方式，其优点是可以做一些透穿，一定要注意break，或者直接return了 12345678910function reducer(state, action) &#123; switch(action.type) &#123; case 'ADD': return &#123; ... &#125; case 'UPDATE': return &#123; ... &#125; default: return &#123; ... &#125; &#125;&#125; 抽出成key-value的形式将switch中的判断case做成key即可 1234567891011121314151617181920// object类型const actions = &#123; 'ADD', function1, 'UPDATE', function2, 'default', function2,&#125;let command = 'ADD'const res = actions[command] || actions['default']// map类型const actions = new Map([ ['ADD', function1], ['UPDATE', function2], ['default', function3],])let command = 'ADD'const res = actions.get(command) || actions.get('default') 多层嵌套判断12345678910111213141516171819202122232425262728if (guest) &#123; if (command === 'ADD') &#123; &#125; else if (command === 'UPDATE') &#123; &#125; else if (....)&#125; else if (master) &#123; if (command === 'ADD') &#123; &#125; else if (command === 'UPDATE') &#123; &#125; else if (....)&#125;// object，map都可以叠加作为keyconst actions = &#123; 'guest_ADD', function1, 'guest_UPDATE', function2, 'master_ADD', function3, 'master_UPDATE', function2, 'default', function2,&#125;let identity = 'guest'let action = 'ADD'let command = `$&#123;identity&#125;_$&#123;action&#125;`const res = actions[command] || actions['default'] 利用map的key多类型，做高级key使用正则表达式去匹配 12345678910const actions = new Map([ [/^guest_(ADD|UPDATE)$/, function1], // 匹配 guest_ADD, guest_UPDATE [/^master_[1-4]$/, function2] // 匹配 master_1, master_2, ..., master_3 [/default/, function3]])let identity = 'guest'let action = 'ADD'let command = `$&#123;identity&#125;_$&#123;action&#125;`const res = [...actions].find(([key, value]) =&gt; key.test(command)) 将key直接做成一个对象 1234567891011const actions = new Map([ [&#123; identity: 'guest', action: 'ADD'&#125;, fucntion1], [&#123; identity: 'guest', action: 'UPDATE'&#125;, fucntion2], [&#123; identity: 'master', action: 'ADD'&#125;, fucntion3], [&#123; identity: 'master', action: 'UPDATE'&#125;, fucntion4], // ...])let identity = 'guest'let action = 'ADD'let command = `$&#123;identity&#125;_$&#123;action&#125;`const res = [...actions].find(([key, value]) =&gt; key.identity === identitu &amp;&amp; key.action === action)]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-0814]]></title>
    <url>%2F2020%2F08%2F14%2F2020-0814%2F</url>
    <content type="text"><![CDATA[2020-08-14 北京-海淀-中关村紫金大厦（字节出差于海淀大厦） 有幸于22岁的最后一天赶上末班车，回头一看，已经23岁了，时间挺快的，一切都来不及思考，接下来加油咯 实习-8k Bytedance next-age =&gt; 16k 送自己一句话，折中的选择，会吸收两者共同的缺点，虽然都是歪理，但还是挺喜欢的，接下来好好努力，顺着一个方向深挖，加油。]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TT]]></title>
    <url>%2F2020%2F08%2F03%2FTT%2F</url>
    <content type="text"><![CDATA[现在已经是20200803了，最近国际形势也是飞速变换，Tiktok同样收到了重创，ByteDance风评被害,一鸣也风评被害，目前不清楚所有的形式，也不能妄自予以判断，还记得上一篇种好每一颗土豆，华为算是挺过来，但是也被各种DISS爱国营销，作为一个局外人，我还在这吃瓜，但是这次自己也算是一个developer，对于TT大家还都是引以为傲的，网络上吃瓜群众也很多，也不知道那些吃瓜群众都是什么心态，其他就交给大佬们了，自己先把手头工作做好，加油，Always Day 1! 杭州·西湖白堤]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON.stringify转换字符串]]></title>
    <url>%2F2020%2F06%2F18%2FJSON-stringify%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[字符串转换时，会使用到JSON.stringify他会将一个对象转换为json串格式 12345let obj = &#123; name: 'zhn', age: 18&#125;JSON.stringify(obj) // "&#123;"name":"zhn","age":18&#125;" 代表一个字符串,其中内容为&#123;"name":"zhn","age":18&#125; 转换纯字符串同时也可以转换普通的字符串 1JSON.stringify('str') // ""str"" 代表一个字符串，其中的内容为"str" 转换纯字符串中引号默认会转换为双引号 123JSON.stringify('str') // ""str""JSON.stringify("str") // ""str"" 单引号会依旧存在 1JSON.stringify("st'666'r") // ""st'666'r"" 双引号会被转义（默认转换为双引号） 1JSON.stringify('st"666"r') // ""st\"666\"r"" 如果有引号叠加的状态，则会保留，因为字符串如果输入正确就已经被转移过了。 1JSON.stringify("st\"666\"r") // ""st\"666\"r"" 应用于webpack打包 具体要看插件是如何定义的，如webpack.DefinePlugin在其文档写清楚了 12345678910111213141516// 比如我们最终打包后的代码为const code = 'console.log(1)'// 执行代码时，只需要eval(code)// 如果我们最终是一个字符串const str = 'hello word'// 最终暴露const code = 'module.exports = ' + str // 最终code = 'module.exports = hello word'eval(code) // 报错 hello 找不到应用// 最终暴露const code = 'module.exports = ' + JSON.stringify(str) // 最终code = 'module.exports = "hello word"'eval(code) // 可正常执行]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐藏元素3种方式区别]]></title>
    <url>%2F2020%2F06%2F15%2F%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A03%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[display:none; display: none/block; 该元素会彻底从页面上消息，DOM结构会消失，所以会直接触发页面重排重绘，所以不适合频繁地显示隐藏元素。并且由于其消失后，自身绑定的事件更不会触发，也不能有过渡效果。其等于从页面上消失，所以被遮挡的元素不受到影响，依然可以正常的操作。 用作nav时，下拉的提示效果。 visibility:hidden; visibility: hidden/visible; 从页面上仅仅是隐藏该元素，DOM结果均会存在，只是当时在一个不可见的状态，不会触发重排，但是会触发重绘，并且他给人的效果是隐藏了，所以他自身的事件不支持，他隐藏后，被遮挡住的元素依然可以正常的触发其自身事件。 其子元素仍然可以设置visible来显示出来 一般用作较为频繁的显示和隐藏时，可以用到。 opacity:0; opacity: 0/1; 这是使用浏览器降低alpha数值来达到隐藏的效果，可以说是元素此时还正常，只是正好透明了，我们看不到而已，所以不会引发重排，一般情况下也不会引发重绘，由于其仍然是存在于页面上的，所以他自身的的事件仍然是可以出发的，但被他遮挡的元素是不能触发其事件的。 其子元素不能设置opacity来达到显示的效果 三种方式的对比 display: none visibility: hidden opacity: 0 页面中 不存在 存在 存在 重排（reflow） 会 不会 不会 重绘（paint） 会 会 不一定 自身绑定事件 不触发 不触发 可触发 transition 不支持 支持 支持 子元素可复原 不能 能 不能 被遮挡的元素可触发事件 能 能 不能]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每个人都可以发光]]></title>
    <url>%2F2020%2F06%2F11%2F%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%8F%91%E5%85%89%2F</url>
    <content type="text"><![CDATA[今天结束了字节的3面+HR面,总的来说体验还是很不错的，首先要怒夸一波bytedance,办公效率真的是很高，一共用了4天。 day1:我去官网投了面试，很快收到了字节的邮件回复，看样子像是自动回复（尚未考证过）不过署名是来自字节的人力资源。 day2:人事联系了我，（没想到那么快，那早还在床上，突然收到电话，差点以为是骚扰电话挂了010开头）和我约了时间，她看了下当天下午，应该是排满了，于是就安排了我于第二天下午14:00,就是前一秒的你还在床上看bilibili的沙雕视频，下一秒你就得知明天面试了。 day3:下午13:50多，面试官也基本提前来了,当天气氛还算可以，1面+2面（二面代码，思考偏多，结束后连面试官都不太记得长什么样了），当天做到16点，结束后，也算是休息一波，hr通知我，今天时间可能来不及了，于是约到了第二天下午16点。 day4:13:59面试官还没到，感到有点不对劲，于是看了下手机，发现hr之前发了短信，还打了电话给我，（电话被我静音了，呜呜呜！）后面hr在电话里很是抱歉，表示有一个紧急会议，而且声音很委婉。（应该用这个形容词吧）不禁让我一惊Σ(っ °Д °;)っ，对面只是一个还不知道状况的实习生，也能如此尊敬，后来我以为要改时间了，但是他说推迟到1个小时即可，那么今天还是可以正常进行的，还是很好的。最后3面+HR面，结束也都18点40多了。总的来说，字节还是很认真的，而且面试官也是很不错的，挺像同学的，和他聊天。 最终结果要等到下周一，整个过程还是挺愉快的，挺不错的一次体验，不得不说，bytedance效率真高，隔壁面Tencent的同学两轮面试之间差了2周多。 以下和自己面试没关系，单纯是了解抖音时的一些感想。 还有就是自己对抖音的理解吧，之前一直认为抖音在消耗人的时间，众多短视频平台里的佼佼者，也几乎没有怎么细细去看过，但是前两天，当我打开抖音官网时，被他震住了，突然感觉抖音不是我想象的软件，记录美好生活突然间有了更深的意义，或许我们每个人并没有那样华丽的光环，大多数都是在自己的生活中默默无闻的奉献，那么每个人将自己平凡的生活做一个记录，留下些许记忆的片刻，何尝不是好事情呢，或许世界这么大，每个人都有每个人的生活，自己才是人生的主角，努力去记忆，等到以后回忆时，也会有某种独特的思绪吧，或许这才是科技应该给人带来的，记录每个人平凡的生活，用数字的方式记录下来，曾几何时，再让我们回忆起，那么也会有着某种思绪万千的回忆吧。 很喜欢官网的这个宣传片，借此机会保存下来。 如有幸入职实习，那么还是加油了！搞出点东西来！]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端跨域]]></title>
    <url>%2F2020%2F06%2F10%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[为什么会有跨域只要协议、域名、端口有任何一个不同，都被当作是不同的域。 浏览器为了安全考虑，随便使用他人的资源可能会发生安全问题，所以会有跨域问题。 123456789101112131415161718192021222324URL 说明 是否允许通信http://www.a.com/a.jshttp://www.a.com/b.js 同一域名下 允许http://www.a.com/lab/a.jshttp://www.a.com/script/b.js 同一域名下不同文件夹 允许http://www.a.com:8000/a.jshttp://www.a.com/b.js 同一域名，不同端口 不允许http://www.a.com/a.jshttps://www.a.com/b.js 同一域名，不同协议 不允许http://www.a.com/a.jshttp://70.32.92.74/b.js 域名和域名对应ip 不允许http://www.a.com/a.jshttp://script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）http://www.a.com/a.jshttp://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）http://www.cnblogs.com/a.jshttp://www.a.com/b.js 不同域名 不允许 遇到跨域问题的情况操作不同域的DOM使用iframe的时候，外部iframe如果和里面源src不一样，操作起来可能会有问题 获取网页的存储信息，cookie, localStorage在www.baidu.com做了登录，信息是在www.baidu.com但是在yun.baidu.com也可以获取到相应的登录信息。 获取数据操作数据地址与前端页面不在一个域下，可以发送数据，单出于同源考虑，浏览器不会使用数据 解决方案操作不同域的DOM只需要能保证能够通过父子页面中，直接操作到其html的内容即可 父获取子，可以获取到iframe后iframe.contentWindow 子获取父，可以直接访问parentparent即为父的window。（子的window.parent是父元素window） 使用document.domain修改document.domain的方法只适用于不同子域的框架间的交互。 浏览器中不同域的框架之间是不能进行js的交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是http://www.damonare.cn/a.html ， 在这个页面里面有一个iframe，它的src是http://damonare.cn/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的： 123456789&lt;script type="text/javascript"&gt; function test()&#123; var iframe = document.getElementById('ifame'); var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的 var doc = win.document;//这里获取不到iframe里的document对象 var name = win.name;//这里同样获取不到window对象的name属性 &#125;&lt;/script&gt;&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt; 只要把http://www.damonare.cn/a.html 和 damonare.cn/b.html 这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。 在页面http://www.damonare.cn/a.html 中设置document.domain: 1234567&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt; document.domain = 'damonare.cn';//设置成主域 function test()&#123; alert(document.getElementById('iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象 &#125;&lt;/script&gt; 在页面http://damonare.cn/b.html 中也设置document.domain: 123&lt;script type="text/javascript"&gt; document.domain = 'damonare.cn';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同&lt;/script&gt; 获取网页的存储信息，cookie, localStorage www.baidu域名下面登录了，发现yun.baidu域名下面也自然而然登录了；淘宝登录了，发现天猫也登录了，淘宝和天猫是完全不一样的2个域名。 用来传递信息的，因为有跨域不能去拿其他页面存储的内容，所以可以在目标页面生成一个iframe，匹配存储内容的src，之后拿到数据发回主页面即可。 使用location.hash来跨域hash是明文存储的，存在直接暴露在url中，数据容量和类型都有限等的问题。 URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。 假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。 a.html传送数据到b.html a.html下修改iframe的src为google.com/b.html#paco b.html监听到url发生变化，触发相应操作 b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”www.baidu.com/proxy.html#…&quot; proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash） a.html监听到url发生变化，触发相应操作 子页面b.html关键如下 123456789try &#123; parent.location.hash = 'data'; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = "http://www.baidu.com/proxy.html#data"; document.body.appendChild(ifrproxy); &#125; proxy.html关键如下 12//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值 parent.parent.location.hash = self.location.hash.substring(1); 使用document.domain如果两个面主域名完全相同，则使用该方法就可以，和上面介绍的方法一样 12345// www.a.comdocument.domain = 'a.com'// yun.a.comdocument.domain = 'a.com' 使用postMessage如果两个域名完全不相同，可以用postMessage和iframe相结合的方法。postMessage(data,origin)方法允许来自不同源的脚本采用异步方式进行通信。 postMessage的使用方法： 12345otherWindow.postMessage(message, targetOrigin);otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口message: 是要发送的消息，类型为 String、Object (IE8、9 不支持)targetOrigin: 是限定消息接收范围，不限制请使用 '*' 比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信。 A-&gt;B发送数据使用A页面通过postMessage发送数据 12345window.onload = function() &#123; var ifr = document.getElementById('ifr'); var targetOrigin = "http://www.google.com"; ifr.contentWindow.postMessage('hello world!', targetOrigin); &#125;; B页面通过message事件监听并接受消息: 12345678910111213141516var onmessage = function (event) &#123; var data = event.data;//消息 var origin = event.origin;//消息来源地址 var source = event.source;//源Window对象 if(origin=="http://www.baidu.com")&#123; console.log(data);//hello world! &#125; &#125;;// 处理兼容，绑定事件if (typeof window.addEventListener != 'undefined') &#123; window.addEventListener('message', onmessage, false); &#125; else if (typeof window.attachEvent != 'undefined') &#123; //for ie window.attachEvent('onmessage', onmessage); &#125; B-&gt;A发送数据与A-&gt;B发送数据是相同的 在子页面B中，要在B内操作逻辑，parent即为父元素A的window B元素发送时parent.postMessage(data, target) A元素接收时window.addEventListener(&#39;message&#39;, handle)即可。 与服务端拉取数据的前端环境部署的服务器地址，与后端环境的数据地址并不在同一个地方，所以浏览器在访问时就会遇到跨域的问题。 使用反向代理 前端开发时，可以配置webpack的代理。多用于开发环境 跨域是浏览器端的，服务端并无此问题，我们可以使用开发时的node中转一下。 12345678mmodule.exports = &#123; //... devServer: &#123; proxy: &#123; '/api': 'http://localhost:3000' &#125; &#125;&#125;; fetch(&#39;/api/xxx&#39;)也就是对自己发出访问，通过代理走一层。 请求到 /api/xxx 现在会被代理到请求 http://localhost:3000/api/xxx, 例如 /api/user 现在会被代理到请求 http://localhost:3000/api/user 使用jsonp jsonp和ajax并无关系，是两种不一样的东西，只是jQuery做了封装，使得$.ajax可以做jsonp jsonp需要后端来配合,只能使用一些简单的请求。依赖后端配合 我们定义了使用这个数据的方法，等到这个数据请求成功后，返回结果就是调用方法，并且参数已经是我们想要的结果了。 1234567&lt;script type="text/javascript"&gt; function dosomething(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt; &lt;!-- 返回结果，dosomething(['a','b','c']);上述函数会被直接触发 --&gt; jQuery中的处理方法，其实他在内部也是一样的，他创建了个临时方法，并且在使用完毕之后立即销毁了 12345&lt;script type="text/javascript"&gt; $.getJSON('http://example.com/data.php?callback=?,function(jsondata)')&#123; //处理获得的json数据 &#125;);&lt;/script&gt; 使用CORS这也是目前使用最主流的方式,依赖后端配合。 CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。跨域资源共享 CORS 详解 也就是说浏览器用了各种原因限制了我们，我们用各种方法绕过跨域检查，也可以从正面走，就是让浏览器知道这个源，我跨域了，但是他就是我想要的，他是安全的，而且服务端返回的地址里，也有客户端的地址，是开发人员指定的，我们发送请求和之前并无异样。 123var xhr = new XMLHttpRequest();xhr.open("GET", "http://segmentfault.com/u/trigkit4/",true);xhr.send(); 如果前端要发送凭证(携带cookie)时，设置withCredentials: true 如果要使用withCredentials，服务端请求头Access-Control-Allow-Origin: 不能为* xhr：xhr.withCredentials = true fetch: fetch(url, {credentials: &#39;include&#39;}); 服务端要配置CORS相关头 参考https://juejin.im/post/5815f4abbf22ec006893b431 https://www.cnblogs.com/xjy20170907/p/11772416.html]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC块状格式化区域]]></title>
    <url>%2F2020%2F06%2F09%2FBFC%E5%9D%97%E7%8A%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[什么是BFCBFC（block-fomatting-context）是一种css渲染规则，规定了其内部元素的渲染规律，css2.1规定了BFC,IFC,css3又规定了BFC,IFC,GFC,FFC。 BFC就是块级的作用域。GFC就是grid作用域。IFC就是内联作用域。FFC就是flex作用域。 BFC可以理解为一种渲染的独立区域，规定了内部如何渲染，并且与外部也毫不关联。常用在独立的定位区域，并多余float关联（float也是营造出BFC的一种方式） BFC内部特性如下 内部的Box会在垂直方向上一个接着一个放置。 Box垂直方向的距离由 margin 决定。属于同一个BFC中的两个相邻的Box上下margin会发生叠加。 每个元素的margin box 的左边，与包含块border box 的左边相接触。即使浮动也是如此。 BFC 的区域不会与float box 重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响外面的元素，反之也如此。 计算BFC的高度时，浮动元素也参与计算。 也就是说我们的BFC环境中，他的计算都是独立出来的，与外部的BFC区域边界接触。并且内部与外部不相互影响。 营造出BFC环境的几种方式 position:absolute或者fixed。 float:不是none。 overflow: 不是visible。 display: inline-box或者flex 根元素&lt;html&gt; 使用场景右下角广告跟随屏幕移动，设置其position: fixed形成了一个BFC，可对内布局。 浮动区域left与right两个元素，通常情况下，将left设置为BFC(float)那么如果right的高度特别大，right元素会环绕在left的四周，这也是float最初的设计，文字排版中做图片环绕的功能。如果将right也设置为BFC(float)那么两个元素的边界才会挨在一起。 123456789101112131415161718192021&lt;style&gt; .float-wrapper &#123; border: 2px solid red; overflow: auto; &#125; .left &#123; float: left; background: yellowgreen; width: 50px; height: 50px; &#125; .right &#123; float: left; background: hotpink; height: 100px; &#125;&lt;/style&gt;&lt;div class="float-wrapper"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 清除浮动当其内部元素都为float时，会造成高度塌陷，因为我们的BFC是独立的，所以我们可以为父元素设置为BFC，解决清除浮动。 123456789&lt;style&gt;.wrapper &#123; overflow: auto; &#125;.box &#123; float: left; width: 50px; height: 50px; &#125;&lt;/style&gt;&lt;div class="wrapper"&gt; &lt;div class="box"&gt; &lt;div class="box"&gt;&lt;/div&gt; 解决margin无效的问题同一个BFC内，会出现margin合并的问题，我们可以在区域内营造出他自己的BFC环境，与外界隔离即可。 1234567891011121314151617181920212223242526272829&lt;style&gt; .box &#123; width: 50px; height: 50px; margin: 50px 0; &#125; .wrapper &#123; overflow: auto; &#125;&lt;/style&gt;&lt;!-- margin出现重合 --&gt;&lt;div&gt; &lt;div class="box"&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;!-- margin恢复 --&gt;&lt;div&gt; &lt;div class="wrapper"&gt; &lt;div class="box"&gt; &lt;/div&gt; &lt;div class="wrapper"&gt; &lt;div class="box"&gt; &lt;/div&gt;&lt;/div&gt; 其他-圣杯布局按照解析顺序，center在前。 123&lt;div class="center"&gt;&lt;/div&gt;&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt; 会使用到margin-left: -100px;他会向左去走，如果这个元素之前被挤下来了，那么他会又上去。 使用padding: 0 100px然后在将元素浮动到位置，使用position之后，定位到空缺里，实现左右两侧固定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; header, footer &#123; background: hotpink; &#125; .wrapper &#123; padding: 0 50px; overflow: auto; &#125; .center &#123; float: left; width: 100%; background: yellowgreen; &#125; .left &#123; position: relative; float: left; left: -50px; width: 50px; margin-left: -100%; background: deeppink; &#125; .right &#123; position: relative; right: -50px; float: left; width: 50px; margin-left: -50px; background: deeppink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;header&lt;/header&gt; &lt;div class="wrapper"&gt; &lt;div class="center"&gt;center&lt;/div&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;footer&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 本身使用float+margin-left: -50px就可以实现，但是会覆盖住center所以，设置了wrapper的两侧的padding,并且将其向两侧定位即可。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟async自执行函数]]></title>
    <url>%2F2020%2F06%2F07%2F%E6%A8%A1%E6%8B%9Fasync%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[回顾generator函数generator函数是用来处理异步编程的解决方案，它使得一个函数可以暂时离开当前的执行栈，并将函数的执行权交由外部去处理。 next方法，手动获取当前的执行情况，next()方法的返回值，是yield的右侧内容，而next(param)参数param则是传递给generator函数中被yield挂起的左侧返回值。 1234567891011121314151617function* generator() &#123; const data1 = yield 2 const data2 = yield data1 + 1 return data2&#125;/* 执行情况1 */const gen = generator()gen.next() // &#123; value: 2, done: false &#125; 函数从头开始，停在在yield 2右处gen.next() // &#123; value: NaN, done: false &#125; 函数从yield 2 左侧开始，并返回undefined, 停在yield data1 + 1 gen.next() // &#123; value: NaN, done: true &#125; 函数从yield data1 + 1 左侧开始 并返回undefined 停在执行完函数return/* 执行情况2 */const gen = generator()gen.next() // &#123; value: 2, done: false &#125; 函数从头开始，停在在yield 2右处gen.next(8) // &#123; value: 9, done: false &#125; 函数从yield 2 左侧开始，并返回8, 停在yield data1 + 1 gen.next(2) // &#123; value: 2, done: true &#125; 函数从yield data1 + 1 左侧开始, 并返回2, 停在执行完函数return 可以看出generator设计并不是将yield右侧内容，异步处理完毕后解析给左侧，他是让你来处理，只不过大多数情况我们都将处理的结果返回yield,造成了一种假象，并且其实直接返回内容给yield正是我们的本意 for-of循环可以在done为false的情况下，不断执行，使用generator执行fibonacci 1234567891011121314function* fibonacci() &#123; let [pre, cur] = [0, 1]; while(true) &#123; [pre, cur] = [cur, pre + cur]; yield cur &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 100) &#123; break; &#125; console.log(n) // 1 ... 89&#125; 实现一个async/await的实现 async/await是generator函数的一个语法糖 目的使用async/await重写例子 1234567async function asyncFunc() &#123; const data1 = await 2 const data2 = await data1 + 1 return data2&#125;asyncFunc().then(val =&gt; console.log(val)) // 3 我们期望通过封装之后能够实现async/await类似的效果 1234567const asyncFunc = asyncToGenerator(function* generator() &#123; const data1 = yield 2 const data2 = yield data1 + 1 return data2&#125;)asyncFunc().then(val =&gt; console.log(val)) // 3 实现如果实现串式，需要使用到Promise,核心内容为，如果当前next未执行完毕，则在下一个promise.then中继续调用next(),也即我们构建了一个Promise，省略了generator中若干可控制的yield,只将他的返回值取出来了。 1234567891011121314151617181920212223function asyncToGenerator(generatorFunc) &#123; return function (...args) &#123; const gen = generatorFunc.apply(this, args) return new Promise((resolve, reject) =&gt; &#123; function step(key, arg) &#123; let generatorResult try &#123; generatorResult = gen[key](arg) &#125; catch(error) &#123; return reject(error) &#125; const &#123; value, done &#125; = generatorResult if (done) &#123; return resolve(value) &#125; else &#123; return Promise.resolve(value).then(val =&gt; step('next',val), err =&gt; step('throw',err)) &#125; &#125; // 开启任务 step('next') &#125;) &#125;&#125; 测试 123456789function* calcFunc(num) &#123; const x = yield num * 2; console.log(x); const y = 3 * (yield x + 1); console.log(y); return x + y;&#125;const gen = asyncToGenerator(calcFunc)gen(2).then(val =&gt; console.log(val)); // 16]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中常用继承方式]]></title>
    <url>%2F2020%2F06%2F06%2Fjs%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[继承能够实现，是因为对象找属性，如果找不到会一直顺着原型链走下去，直到找到null为之。 原型链继承将原型指向一个创建的新的父对象 优点：可以访问父对象的所有方法缺点：1.父对象的数据会被所以子类共享，2.无法向构造函数内传参 如果为子类改原型之后，要修改好之后再去添加原型上的方法。 123456789101112131415161718function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123; &#125; Child.prototype = new Parent(); let child1 = new Child(); child1.names.push('yayu'); console.log(child1.names); // ["kevin", "daisy", "yayu"] let child2 = new Child(); console.log(child2.names); // ["kevin", "daisy", "yayu"] 类式继承，构造器继承，经典继承利用创建对象时，同es6中类的construct中this的特性,也即最终返回的结果会是真正创建出来 他避免了原型继承的大部分缺点，并且等于将父类’构造器‘借用了自己一下。 优点：1.避免子类所有属性共享。2.可以向构造器内传参缺点：1.不能访问父类原型方法。2.只是使用一下父类原型，但是每一次都要重新创建父类 123456789101112131415function Parent (name) &#123; this.name = name;&#125; function Child (name) &#123; Parent.call(this, name);&#125; const child1 = new Child('kevin'); console.log(child1.name); // kevin const child2 = new Child('daisy'); console.log(child2.name); // daisy 组合继承原型链继承 + 类式继承 原型继承重点关注了原型部分，类式继承重点关注了实例部分，将他们进行一次组合 优点：1.不能访问父类原型方法。2.避免子类所有属性共享。3.可以向构造器内传参缺点：1.只是使用一下父类原型，但是每一次都要重新创建父类，调用2次，创建实例一次，绑定原型一次。 123456789101112131415161718192021222324252627282930function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125; Parent.prototype.getName = function () &#123; console.log(this.name)&#125; function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125; Child.prototype = new Parent(); var child1 = new Child('kevin', '18'); child1.colors.push('black'); console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // ["red", "blue", "green", "black"] var child2 = new Child('daisy', '20'); console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // ["red", "blue", "green"] 原型式继承创建对象时，直接以某个对象为原型挂载，和原型链继承相似，只不过我们并没有提供构造函数。 他和原型链继承的区别是： 原型链继承，有构造函数，改变prototype 原型式继承，无构造函数，内部创建一个空构造函数，直接替换prototype,只关心以某个对象为原型的创建。 123456789// es6官方实现Object.create()// 在内部手动创建了构造器function createObj(proto) &#123; function F()&#123;&#125; F.prototype = proto return new F()&#125; 优点：1.可以使用原型链的方法。2.创建起来比较简单。缺点：1.会共享父对象方法，但不一定会改变 12345678910111213let person = &#123; name: 'kevin', friends: ['daisy', 'kelly']&#125; let person1 = createObj(person);let person2 = createObj(person); person1.name = 'person1';console.log(person2.name); // kevin person1.friends.push('taylor');console.log(person2.friends); // ["daisy", "kelly", "taylor"] 这里一定要注意.操作符，如果他没有该属性，会进行添加，然后进行修改的话是不会发生改变的。 所以，修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了name值，并非修改了原型上的name值。 同样，如果是person1.friends = [ xxx ]这样以后再修改，也是不会影响到原型上的方法的。 寄生式继承和原型式继承很像，只是增添了一些方法，类似于包装了一层 12345678function createObj(o) &#123; let clone = Object.create(o) clone.sayName = function () &#123; console.log('hi') &#125; return clone&#125; 寄生组合式继承他是结合了上述的优点，只是我们再使用继承时，一般不会希望子类去共享父类的方法，（有的话，就使用组合继承）所以会创建很多对象，其原型上可能会有一些用不到的对象，那么我们用组合继承就可以避免 优点：1.可以访问父类原型。2.避免共享父类数据。3.可以调用父类构造函数传参。4.免去原型上不必要的属性。 就是在组合继承的基础上，避免直接prototype = new Xxx(),而是采用迂回的方式。 最终Parent上的属性，通过类式继承，借给子类，等于直接变成了子类的属性，而在原型上，由于并没有new操作，所以也并不会将Parent上的部分无用属性挂载到原型上。 123456789101112131415161718192021function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125; Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;function inheritPrototype(subObj, supperObj) &#123; const prototype = Object.create(supperObj.prototype) prototype.constructor = subObj prototype.constructor.prototype = prototype&#125;inheritPrototype(Child, Parent) 参考(https://www.cnblogs.com/lanyueff/p/7792009.html)[https://www.cnblogs.com/lanyueff/p/7792009.html]]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致2年前的自己]]></title>
    <url>%2F2020%2F06%2F04%2F%E8%87%B42%E5%B9%B4%E5%89%8D%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[2年前的自己应该是在准备高考了，今年受到疫情影响有所推迟，应该是到7月份了。今天和同学聊了聊人生，感觉不知不觉大家也都开始考虑人生了，反观自己，这里一路走来还是得以有父母能一直支持与鼓励我。教育真的很重要，一定不能小看了他的作用，不仅是教授一个人知识，更是约束一个人在正确时间干正确的事，希望父母一切安好，也给自己打气，加油！]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准Package打包方式]]></title>
    <url>%2F2020%2F05%2F31%2F%E6%A0%87%E5%87%86Package%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前半部分是father-build，后部分是打包需要注意的部分 使用father-build打包 具体可参考redux的包管理，是一个相对比较规范的包管理仓库(unpkg) 使用方式1234567891011# 安装方式yarn add father-build -D# 使用方式"build": "father-build"# 应该为在当前目录下安装依赖后直接使用father-build# 此处为了节省node_modules，均安装在了上一级目录../node_modules/.bin/father-build 配置文件.fatherrc.js 123456789101112131415161718192021222324252627// rollup（推荐）export default &#123; entry: 'src/index.js', esm: &#123; type: 'rollup', mjs: true, // 开启mjs &#125;, cjs: 'rollup', umd: &#123; name: 'demo', // 暴露全局的名称 minFile: true, // 是否打出umd.min &#125;&#125;// babelexport default &#123; entry: 'src/index.js', esm: &#123; type: 'babel', mjs: true, &#125;, cjs: 'babel', umd: &#123; name: 'demo', minFile: true, &#125;&#125; 注意包名称 目录名称 package.json名称 package.json版本 包指向 main(cjs) module(esm) unpkg(umd) 包含的文件package.json 123456&#123; "files": [ "dist/", "lib/" ]&#125; 发包前检查1npm pack 发布1npm publish]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用requestIdleCallback调度任务]]></title>
    <url>%2F2020%2F05%2F27%2F%E4%BD%BF%E7%94%A8requestIdleCallback%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[任务调度系统操作系统中调度操作系统中，基于时间片调度时，如果到了时间该程序还没有运行完毕，那么此时会有中断，将该程序的相关运行位置，以及上下文环境等存入相关的寄存器中，之后进行恢复 浏览器中调度我们在浏览器中，也可以近似的模拟出调度算法，但是js程序必须自己守时，如果到了时间不自己退出，或者是长时间占用主线程，那么卡顿是必然的，所以在浏览器中必须来手动尽可能的控制程序的运行。 浏览器中目前提供的方式在一个EventLoop，如果当前这个循环需要更新，js代码-requestAnimationFrame-UI渲染(layout, paint)-requestIdleCallback(0个或多个)-macroTask requestIdleCallback当浏览器运行时，主线程有空闲的时间，那么就会去运行代码，但是浏览器空闲下来，谁也不能保证接下来浏览器会发生什么，会不会有优先级更高的任务进来,如用户点击的交互事件，或者是动画事件,相关的研究发现，人在50ms内是不太容易察觉出变化来的，所以如果当前线程空闲（用户不操作，或者当前并没什么操作进行）当前requestIdleCallback会设定&lt;50ms执行时间。 requestIdleCallback(fn, timeout?) fn最终回调执行fn(deadline),deadline.timeout是否超时,deadline.timeRemaining()剩余时间，&gt;=0, 到0表示已经执行超时了。 timeout,表示超时时间，因为rIC并不一定会执行，如果浏览器长时间忙碌，那么他会在timeout超时下强制执行 React的polyfill `React@16.6.x` React团队考虑到浏览器兼容问题，并没有使用rIC,而是使用rAF+setTimeout来进行polyfill rAF,requestAnimationFrame用来在每个渲染时，发出执行的信号 并且其调动callback时，会传入类似当前performace.now，他使用计算屏幕的刷新率（多次rAF间隔）计算出下一次渲染的deadline当然这里包括了UI线程的时间，deadline与当前时间now可近似算出，这一帧还有多少的执行时间。 setTimeout同样是为了防止该任务在浏览器繁忙时，多次得不到执行而设定的一个超时 在rAF中发出postMessage，UI渲染结束后，调用macroTask,监听message回调的事件会执行，并通过上下文计算是否超时 使用rIC(requestIdleCallback)小例子 使用chrome时，可在Performance调低性能，效果较为明显。 执行一定数量的console.log操作，使用同步异步来执行 模拟浏览器忙碌的情况使用一个css动画模拟浏览器的忙碌情况，从而更好的测试性能，我们创建了一个左右移动的box 123456789101112131415161718192021222324252627282930&lt;style&gt;/* 使用margin移动，更好验证效果，如果做动画，transform还是首选 */@keyframes slide &#123; 0% &#123; margin-left: 0; /* transform: translateX(0); */ &#125; 50% &#123; margin-left: 200px; /* transform: translateX(200px); */ &#125; 100% &#123; margin-left: 0; /* transform: translateX(0); */ &#125;&#125;.box &#123; width: 400px; height: 200px; animation-duration: 3s; animation-name: slide; animation-iteration-count: infinite; background: red;&#125;&lt;/style&gt;&lt;div class="box"&gt;&lt;/box&gt; 同步123456789101112131415161718192021222324const TEST_SIZE = 1000function performSync () &#123; const arr = new Array(TEST_SIZE) let i = 0; console.time('push') // 放入数组中 for (; i &lt; TEST_SIZE; i++) &#123; arr[i] = i &#125; i = 0 console.timeEnd('push') // push: 0.41015625ms console.time('sync-log') // 打印 for (; i &lt; TEST_SIZE; i++) &#123; console.log(arr[i]) &#125; i = 0 console.timeEnd('sync-log') // sync-log: 2690.320068359375ms&#125; 可以看到，执行performSync时，浏览器动画发生了明显的卡顿，也即js占用时间过长，导致后面出现掉帧 异步我们这里存取数据时，需要使用链表进行操作了，可能会涉及到频繁的增添元素， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function performAsync () &#123; let deadline = null let firstCallbackNode = null let lastCallbackNode = null const arr = new Array(TEST_SIZE) let i = 0 console.time('push') // 放入链中 let obj = &#123;&#125; for (; i &lt; TEST_SIZE; i++) &#123; obj = &#123; next: null, payload: i &#125; if (firstCallbackNode === null) &#123; lastCallbackNode = firstCallbackNode = obj &#125;else &#123; lastCallbackNode = lastCallbackNode.next = obj &#125; &#125; i = 0 console.timeEnd('push') // push: 1.015869140625ms // 执行链表中的任务 function flushWork(callback) &#123; while (deadline.timeRemaining() &gt; 0) &#123; // 结束任务 if (firstCallbackNode === null) &#123; lastCallbackNode = null return &#125; callback(firstCallbackNode.payload) firstCallbackNode = firstCallbackNode.next &#125; &#125; // 进行调度 function scheduleWork(deadlineObj) &#123; deadline = deadlineObj // 结束 if (firstCallbackNode === null) &#123; deadline = null console.timeEnd('async-log') // async-log: 7676.759033203125ms return &#125; // 下一次继续调度 requestIdleCallback(scheduleWork) // 当前执行刷新任务 flushWork(console.log) &#125; console.time('async-log') // 启动调度 requestIdleCallback(scheduleWork)&#125; 可以看到在执行performAsync时，动画执行依旧比较流畅，当然相应所耗费时间还是增加的。 结论浏览要干的活是一定的，你让他一下干完，时间很少，但是发生了明显的卡顿（他自己的活来不及干了）。让他空闲的时候执行，动画较为流畅，执行任务所需的时间也久了（给你干活的时间少了） React团队同时引进了ConcurrentMode意为给任务增加不同的优先级，这样能够更好的调度，当然他采用“懒”策略，能不执行就不执行，等他要超时了，赶紧执行。保证了有大量间隙时间给用户交互，但是任务越积越多，到最后一大笔帐要算的时候，还是会出现卡顿。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用对象池创建数据]]></title>
    <url>%2F2020%2F05%2F25%2F%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[在React中,使用到pool的地方并不少，比如SyntheticEvent.js中使用事件对象池，来创建销毁事件。ReactChild.js使用child对象池，React.Children.forEach来遍历子节点。 使用对象池来创建数据，可以很好地帮助我们创建那些需要频繁创建销毁的元素,并在性能上做一部分优化。 举例我们使用Marker来标记地图上的点 参考React.16.6.0中SyntheticEvent.js创建事件池的写法 定义Marker对象123456789101112131415function Marker(x, y, containerInfo) &#123; this.x = x this.y = y this.containerInfo = containerInfo&#125;Marker.prototype.destroy = function () &#123; this.x = null this.y = null this.containerInfo = null&#125;Marker.prototype.show = function () &#123; console.log(`x: $&#123;this.x&#125; y:$&#123;this.y&#125; containerInfo:$&#123;this.containerInfo&#125;`)&#125; 定义对象池相关1234567891011121314151617181920212223242526272829303132333435// 对象池大小const MARKER_POOL_SIZE = 10// 从pool中得到一个marker对象function getPooledMarker(x, y, containerInfo) &#123; const MarkerConstructor = this if (MarkerConstructor.markerPool.length) &#123; const instance = MarkerConstructor.markerPool.pop() MarkerConstructor.call(instance, x, y, containerInfo) return instance &#125; return new MarkerConstructor(x, y, containerInfo)&#125;// 归还一个marker对象到pool中function releasePooledMarker(marker) &#123; const MarkerConstructor = this if (marker instanceof MarkerConstructor === false) &#123; throw Error() // 当前marker不是由其创造,错误提示 &#125; marker.destroy() if (MarkerConstructor.markerPool.length &lt; MARKER_POOL_SIZE) &#123; MarkerConstructor.markerPool.push(marker) &#125;&#125;// 向Marker上挂载对象池的方法function addMarkerPoolingTo(MarkerConstructor) &#123; MarkerConstructor.markerPool = [] MarkerConstructor.getPooled = getPooledMarker MarkerConstructor.release = releasePooledMarker&#125;// 将对象池应用到Marker上addMarkerPoolingTo(Marker) 使用方式 这里手动释放marker,即marker = null 12345678910111213141516// 未使用对象池let marker1 = new Marker(1, 1, 'container1')marker1.show()marker1.destroy()marker1 = null// 使用对象池let marker2 = Marker.getPooled(2, 2, 'container2')marker2.show()Marker.release(marker2)marker2 = null]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件回调系统中处理错误]]></title>
    <url>%2F2020%2F05%2F21%2F%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[更优的调试方式如何让我们在调试代码时，既看到具体的报错信息，又能不影响当前的执行环境,使用try-catch的方式会帮我们静默捕获 程序出错是不能走正常的逻辑，所以我们仅是记录错误信息，hasError等并且去走出错的逻辑，React的ErrorBandage渲染错误的备用UI，这里仅是能看到报错的具体信息，但是又不影响出错的逻辑。 1234567891011121314151617// 模拟出效果function toggleError() &#123; throw Error()&#125;console.log('script start')toggleError()console.log('script end')// 实际执行效果script startUncaught Error// 最终期望的执行结果script startUncaught Errorscript end 事件回调系统事件回调系统拥有自己的上下文，即便在自己的事件回调系统中触发了错误也不会影响到整个事件的处理系统 1234567891011121314// 使用事件回调系统document.addEventListener("DOMContentLoaded", function() &#123; console.log("Init: 1"); DOES_NOT_EXIST++; // error&#125;, false);document.addEventListener("DOMContentLoaded", function() &#123; console.log("Init: 2");&#125;, false);// 此时console中会显示如下内容Init: 1Uncaught ReferenceError: DOES_NOT_EXIST is not definedInit: 2 12345678910111213// jQuery中使用回调系统实现$(document).ready(function() &#123; console.log("Init: 1"); DOES_NOT_EXIST++; // error&#125;); $(document).ready(function() &#123; console.log("Init: 2");&#125;)// 此时console中会显示如下内容Init: 1Uncaught ReferenceError: DOES_NOT_EXIST is not defined 可以看到使用了事件处理函数会使得某个回调事件中发生了错误不会破坏到整个系统 不同环境下处理错误的不同生产环境使用的try-catch此时发生的错误会被我们捕获，并且继续进行后续的执行，(比如React中ErrorBandage可渲染备用的错误UI) 123456789function toggleError() &#123; throw Error()&#125;try &#123; toggleError()&#125; catch (e) &#123; // 处理错误信息&#125; 开发环境中当然使用try-catch是没有问题的，但是既然我们正在开发，就应该得知具体的报错情况，并且处理掉，但是我们一旦使用try-catch就会帮我们静默的处理，并不会暴露错误，chrome中有调试工具pause on caught exception只有出错就暂停到此处,所以我们使用一种曲线救国的方式，使用事件回调的方式去运行，报错并不会影响到外部环境。 模拟React中的invokeGuardedCallback，即将回调放到一个自定义事件函数中，立即触发，有错误不会影响外部 123456789101112131415161718192021222324252627let hasError = truelet error = nullfunction invokeGuardedCallback(callback) &#123; // 全局error事件，有错误记录error信息 function handleWindowError(event) &#123; error = event.error &#125; window.addEventListener('error', handleWindowError); // 自定义事件处理回调 const eventType = 'fakeErrEventType' const evt = document.createEvent('Event') evt.initEvent(eventType, false, false) const fakeNode = document.createElement('fake-err') // 处理回调 function callCallback() &#123; fakeNode.removeEventListener(eventType, callCallback, false) callback.call(null) // 默认有错误，如果正常执行callback，则认为没有错误发生 hasError = false &#125; // 绑定自定义事件并触发 fakeNode.addEventListener(eventType, callCallback, false) fakeNode.dispatchEvent(evt)&#125; 不同方法处理实例1234// 目标回调函数toggleErrorfunction toggleError() &#123; throw Error()&#125; 不进行错误处理1234567console.log('script start')toggleError()console.log('script end')// 执行结果script startUncaught Error 使用try-catch处理1234567891011console.log('script start')try &#123; toggleError()&#125; catch (err) &#123; // err 错误相关信息&#125;console.log('script end')// 执行结果， 并不能看出错误详情位置，可能会忽略发生了错误，因为被处理了script startscript end 使用invokeGuardedCallback1234567891011console.log('script start')invokeGuardedCallback(toggleError)if (hasError) &#123; // error 是全局捕获的出错信息&#125;console.log('script end')// 执行结果， 能看出错误详情位置script startUncaught Errorscript end 参考资料 https://www.cnblogs.com/fangzhaolee/p/3719384.html https://github.com/facebook/react/blob/22f7663f14f12ebd6174292931e94d2b352cf666/packages/shared/invokeGuardedCallbackImpl.js#L61]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正负0的问题]]></title>
    <url>%2F2020%2F05%2F16%2F0-0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在其他语言中（Java）如果出现了1/0这种操作，则会直接报出Exception,但是在js中并不会报错，而是给出一个特殊值Infinity 1230/1 = 01/0 = Infinity // 无限大 +0和-0的区别+0和-0是完全相等的，所以要是进行比较还是应该从1/0的特性来说 1234567891011121314151617181920212223242526272829303132+0 === -0 // true+0 === 0 // true-0 === 0 // true1/0 = Infinity1/-0 = -InfinityInfinity === Infinity // trueInfinity === -Infinity // false/** * 以下计算在正常情况，不要故意改变 .e.g * Infinity + (-Infinity) = NaN * Infinity * (1 / Infinity) = NaN * * 这样不改变运算情况是可以的 * Infinity * -Infinity = -Infinity * * `*`，`/`运算要考虑n的符号 */Infinity + n = Infinity // n为所有值Infinity - n = Infinity // n为非InfinityInfinity - Infinity = NaNInfinity * n = Infinity // n为所有值Infinity / n = Infinity // n为非InfinityInfinity / Infinity = NaN NaN和0的关系123456780/0 = NaN // 特殊+n / 0 = Infinity-n / 0 = -Infinity0 / n = NaN // (n !== 0)NaN === NaN // false Object.is的polyfill1234567function is(x, y) &#123; if (x === y) &#123; // 判断正负0 return x !== 0 || y !== 0 || 1/x === 1/y &#125; else &#123; // NaN !== Nan, 这里polyfill认为 两者相等 return x !== x || y !== y &#125;&#125;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js对首屏渲染的问题]]></title>
    <url>%2F2020%2F05%2F12%2Fjs%E5%AF%B9%E9%A6%96%E5%B1%8F%E6%B8%B2%E6%9F%93%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[浏览器发出请求后，接收流程 Bytes, (3C 62 5F 49 ....) Characters, &lt;html&gt;&lt;head&gt;....&lt;/head&gt;.. Tokens, StartTag: html, StartTag: head, ... Hello .... EndTag: html Nodes, html, head, meta, body, p, Hello DOM, 生成最终DOM树， HTML - head, body(树结构) 浏览器渲染流程HTML生成为DOM对象，CSS生成为CSSOM对象，两者进行Attached操作后，即可生成一个render tree，通过layout（reflow）计算其在浏览器上的样式，最终进行paint绘制到浏览器上 在没有JS的情况DOM对象和CSSOM对象同步生成，待CSSOM对象生成完毕后(如果之后的CSS对之前的样式进行修改，浏览器会发生多次重绘和回流，要等CSSOM生成完毕后在进行渲染)，之后从上到下显示页面，直到整个DOM渲染完成。 JS对浏览器渲染引擎的影响因为JS可以操作DOM, CSS所以，js可能会修改之前的内容，使浏览器发生重绘，影响性能，浏览器此时需要阻塞当前线程，转而去运行js内容，运行完后，继续进行之后的渲染逻辑。 注意：如果script标签是异步拉取的，那么拉取之后到本地，当运行JS时，线程依然会阻塞 HTML,CSS,JS存在的渲染情况浏览器接收到内容后，开始解析，先去匹配一下script标签，有的话就会匹配到也给tcp，去进行下载（并非执行到才回去加载，只是提前下载）,浏览器DOM,CSSOM，生成renderTree,之后绘制到浏览器，一旦遇到script标签后，阻塞当前线程，去运行script标签内的东西（也就是script内的操作之前的DOM结构，后面的还没有生成），如果后面还有内容，则不会渲染，严重情况可能会出现页面渲染了一半的情况。 首屏渲染时间，页面加载完成时间FP（First Paint）：首屏渲染，这里是首页需要显示的内容（部分是不需要被首次渲染出来的） DCL(DOM Content Loaded)： 页面加载完成 (所有的js执行完成，触发DOMContentLoaded事件，window.onLoad) 我们关心的是首屏渲染事件，如果首屏渲染到一半，中间插入了js，如果该js占用较长时间，或加载问题，会造成页面被截断，只能显示一部分页面，所以我们关心的是这个部分。 为什么js放到body最后js放到最后也会下载，但是由于他在最后，并不会影响之前首屏内容的渲染，也就是说js文件放到前面还是后面，DOMContentLoad是不会改变的，但是不同的位置会影响FP,这里肯定是先让用户看到页面最好，所以一般js请求会放到最后面 其实浏览器发现有js存在，会去开启下载，那么必然会占用那么一丢丢浏览资源，包括CPU]]></content>
      <tags>
        <tag>恰饭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用二进制码表示状态]]></title>
    <url>%2F2020%2F04%2F20%2F%E5%88%A9%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A0%81%E8%A1%A8%E7%A4%BA%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[在前端中，二进制码似乎在平常的开发中很少会去使用到，但是在一些框架中，也会看到其作为开发的一部分存在，并且结合位运算，有时也能达到较好的使用效果。 123456789101112131415161718// react\packages\shared\ReactSideEffectTags.js 中使用的相关状态码export type SideEffectTag = number;// Don't change these two values. They're used by React Dev Tools.export const NoEffect = /* */ 0b00000000000;export const PerformedWork = /* */ 0b00000000001;// You can change the rest (and add more).export const Placement = /* */ 0b00000000010;export const Update = /* */ 0b00000000100;export const PlacementAndUpdate = /* */ 0b00000000110;export const Deletion = /* */ 0b00000001000;export const ContentReset = /* */ 0b00000010000;export const Callback = /* */ 0b00000100000;export const DidCapture = /* */ 0b00001000000;export const Ref = /* */ 0b00010000000;export const Snapshot = /* */ 0b00100000000; 简单的位运算位运算不会进位，不要与二进制的加减运算混淆 123456 与(AND) 或(OR) 异或(XOR) 非(NOT) 0b001 0b001 0b011 &amp; 0b010 | 0b010 ^ 0b001 ~ 0b011-------- -------- -------- -------- 0b000 0b011 0b010 0b100 在js中的数字类型转换中: 0,NaN对应的boolean值为false 123,-123,Infinity,...对应的boolean值为true。 所以利用这一特性可以将二进制数位运算的值转换为boolean值。 运用位运算实例吃饭，睡觉，打豆豆为例 1234567891011121314151617181920// 存在的各种状态（为了对齐，借鉴React的书写方式）const Eat = /* */ 0b001 // 吃饭const Sleep = /* */ 0b010 // 睡觉const Fight = /* */ 0b100 // 打豆豆const Mode = /* */ 0b000 // 用户的初始状态let eatAndSleep = Mode | Eat | Sleep // 0b011let emptyMode = Mode // 0b000let fightMode = Mode | Fight // 0b100// 检验是否吃饭console.log(eatAndSleep &amp; Eat) // 1 (0b001) -&gt; trueconsole.log(emptyMode &amp; Eat) // 0 (0b000) -&gt; falseconsole.log(fightMode &amp; Eat) // 0 (0b000) -&gt; false// 检验是否打豆豆console.log(eatAndSleep &amp; Fight) // 0 (0b000) -&gt; falseconsole.log(emptyMode &amp; Fight) // 0 (0b000) -&gt; falseconsole.log(fightMode &amp; Fight) // 4 (0b100) -&gt; true 添加类型1let mode = Mode | Eat // 增加吃饭的标记 0b001 是否有类型12let hasEat = Mode &amp; Eat // 结果0或者非0// let hasEat = !!(Mode &amp; Eat) // 结果为true/false 去除类型1234mode = mode ^ Eat // 去除睡觉的标记 0b000mode = mode &amp; ~(Eat) // 去除睡觉的标记mode = mode &amp; ~(Eat | Sleep) // 去除 睡觉，吃饭 的标记 更为通用的方法123456789101112131415161718192021222324252627282930/** * 判断是否存在当前的状态 * @param &#123;Number&#125; currentMode 当前的状态 * @param &#123;Number&#125; targetMode 目标状态 * @return &#123;Boolean&#125; 是否存在 */function hasMode(currentMode, targetMode) &#123; return (currentMode &amp; targetMode) !== 0&#125;/** * 为当前状态码添加状态 * @param &#123;Number&#125; currentMode 当前的状态 * @param &#123;Number&#125; targetMode 目标状态 * @return &#123;Number&#125; 新生成的状态吗 */function addMode(currentMode, targetMode) &#123; return currentMode | targetMode&#125;/** * 为当前状态码去除状态 * @param &#123;Number&#125; currentMode 当前的状态 * @param &#123;Number&#125; targetMode 目标状态 * @return &#123;Number&#125; 新生成的状态吗 */function removeMode(currentMode, targetMode) &#123; // return currentMode &amp; ~targetMode // 也可使用 return currentMode ^ targetMode // 可使用 ^异或去除&#125; 使用方式使用封装的方法123456let eatMode = addMode(Mode, Eat)let eatAndSleepMode = addMode(eatMode, Sleep)console.log(hasMode(eatAndSleepMode, Eat)) // truelet sleepMode = removeMode(eatAndSleepMode, Eat)console.log(hasMode(sleepMode, Eat)) // false 直接使用二进制操作 React源码中大量使用到了位操作 !!操作可以直接转换为boolean值 12345let eatAndSleepMode = Mode | Eat | Sleepconsole.log(!!(eatAndSleepMode &amp; Eat)) // truelet sleepMode = eatAndSleepMode &amp; ~Eatconsole.log(!!(sleepMode &amp; Eat)) // false 有时React会直接操作当前mode 123effectTag |= Ref // 将Ref标识添加到effectTag中effectTag &amp;= ~Placement // 将Placement状态从effectTag中去除]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝]]></title>
    <url>%2F2020%2F04%2F14%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[JS中的深拷贝最为简单的方式1JSON.parse(JSON.stringify(obj)) 使用递归，手写深拷贝1234567891011function clone (target) &#123; if (typeof target === 'object') &#123; const cloneTarget = Array.isArray(target) ? [] : &#123;&#125; for (const key in target) &#123; cloneTarget[key] = clone(target[key]) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 使用map,防止循环引用自身的情况(重复引用情况) WeakMap,如果放入的对象其引用已经为null,则其中的元素会自动销毁，被垃圾回收器处理 这里仅仅考虑最为普通的形式，即深层次递归的是一个数组或者是对象，如果是函数function，则直接返回其引用即可，并没有什么深层次拷贝的意义 123456789101112131415function clone (target, map = new WeakMap()) &#123; if (typeof target === 'object') &#123; const cloneTarget = Array.isArray(target) ? [] : &#123;&#125; if (map.get(target)) &#123; return map.get(target) &#125; map.set(target, cloneTarget) for (const key in target) &#123; cloneTarget[key] = clone(target[key], map) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 由于while循环速度较快，可以将for in 循环改进成while循环 while循环效率 &gt; 普通for循环的效率 &gt; for in的效率 1234567function forEach(array, callback) &#123; let index = -1 const length = array.length while (++index &lt; length) &#123; callback.call(array[index], array[index], index) &#125;&#125; 考虑多种数据类型重构判断基本类型 function直接当做基本类型，复制过去 12345678function isObject (obj) &#123; const type = typeof obj return type !== null &amp;&amp; (type === 'object' || type === 'function' )&#125;function getType (obj) &#123; return Object.prototype.toString.call(obj)&#125; 克隆时，保证其原型对象挂载正常1234function getInit (obj) &#123; const Ctor = obj.constructor return new Ctor()&#125; 构建多种类型，包括适合深拷贝1234567891011121314151617// 适合递归深拷贝的类型const mapTag = '[object Map]'const setTag = '[object Set]'const arrayTag = '[object Array]'const objectTag = '[object Object]'const deepTag = [mapTag, setTag, arrayTag, objectTag]// 其余重新拷贝的类型const booleanTag = '[object Boolean]'const dateTag = '[object Date]'const errorTag = '[object Error]'const numberTag = '[object Number]'const regexpTag = '[object RegExp]'const stringTag = '[object String]'const symbolTag = '[object Symbol]'const functionTag = '[object Function]' 深度clone 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function clone (target, map = new WeakMap()) &#123; // 克隆原始类型 if (!isObject(target)) &#123; return target &#125; // 初始化 const type = getType(target) let cloneTarget if (deepTag.includes(type)) &#123; cloneTarget = getInit(target) &#125; // 防止循环引用 if (map.get(target)) &#123; return map.get(target) &#125; map.set(target, cloneTarget) // 克隆set if (type === setTag) &#123; target.foreach(value =&gt; &#123; cloneTarget.add(clone(value, map)) &#125;) &#125; // 克隆map if (type === mapTag) &#123; target.foreach((value, key) =&gt; &#123; cloneTarget.set(key, clone(value, map)) &#125;) &#125; // 克隆数组 if (type === arrayTag) &#123; foreach(target, (value, index) =&gt; &#123; // [a, b, c] =&gt; 0:a 1:b 2:c 使用的是0,1,2 cloneTarget[index] = clone(target[index], map) &#125;) &#125; // 克隆对象 if (type === objectTag) &#123; const keys = Object.keys(target) foreach(keys, (key, index) =&gt; &#123; // ['name', 'age'] =&gt; 0: 'name', 1: 'age' 我们使用到的是name, age cloneTarget[key] = clone(target[key], map) &#125;) &#125;&#125; 克隆函数的方式 函数可以直接引用地址，这里也可以使用正则匹配 箭头函数没有原型，可以直接使用eval()生成 普通函数有原型，需要使用new Function(...params, functionBody) 123456789101112131415161718192021222324252627function cloneFunction (fn) &#123; const bodyReg = /(?&lt;=\&#123;)(.|\n)+(?=\&#125;)/m const paramsReg = /(?&lt;=\().+(?=\)\s+\&#123;)/ const fnStr = fn.toString() if (fn.prototype) &#123; // 普通函数 const body = bodyReg.exec(fnStr) const params = paramsReg.exec(fnStr) // 无函数体 if (!body) &#123; return null &#125; // 无参数 if (!params) &#123; return new Function(body[0]) &#125; // 有参数 const paramsArr = params[0].split(',') return new Function(...paramsArr, body[0]) &#125; else &#123; // 箭头函数 return eval(fnStr) &#125;&#125; 克隆其他类型的方式除了map, set, object, array其余可以使用构造器，或者再生成 123456789101112131415161718192021222324252627282930313233343536373839404142const type = getType(target)let cloneTargetif (deepTag.includes(type)) &#123; cloneTarget = getInit(target)&#125; else &#123; return cloneOtherType(target, type)&#125;// 克隆其他类型function cloneOtherType (target, type) &#123; const Ctor = target.constructor switch (type) &#123; case booleanTag: case numberTag: case stringTag: case dateTag: case errorTag: return new Ctor(target) case functionTag: return cloneFunction(target) case symbolTag: return cloneSymbol(target) case regexpTag: return cloneRegExp(target) default: return null &#125;&#125;// 克隆Symbolfunction cloneSymbol (symbol) &#123; return Object(Symbol.prototype.valueOf.call(symbol))&#125;// 克隆正则function cloneRegExp (regExp) &#123; // const flagReg = /[i|m|g]*$/g const flagReg = /\w*$/g const result = new RegExp(regExp.source, flagReg.exec(regExp)) result.lastIndex = regExp.lastIndex return result&#125; 总结 基本数据类型在栈中存储，一旦创建则不可改变；存储在堆中的引用类型则需要深拷贝。 深拷贝时，要考虑三种类型的拷贝，基本数据类型，通过递归操作的引用类型，通过创建实例的其他引用类型 基本数据类型首先JS中的基本数据类型有,null undefined boolean number string symbol object 要判断是基本数据类型还是引用类型，需要使用typeof 可区分 typeof会将function类型单独区分出来，其实是属于object类型中的 typeof null === &#39;object&#39;这是早期js设计的bug,后来考虑到兼容性的问题，就没有在进行修复 因为function类型并没有实际拷贝的需要，lodash中也是直接返回的 所以创建出一个判断是否是Object类型的方法，核心使用typeof进行判断，如果不是object类型(function类型也直接被返回了)，直接返回该值 通过递归操作的引用类型其次判断类型应该使用Object.prototype.toString.call(target)来判断，分为两类 需要进行递归操作拷贝的类型map, set, object, array暂不考虑WeakMap, WeakSet 另一类包括基本类型的一些包装类型Number, Boolean, String, 还有其他类型Date, Symbol, RegExp 需要深拷贝的类型 12345678910111213141516171819202122232425262728293031323334const Ctor = target.constructorlet cloneTarget = new Ctor()// 克隆set if (type === setTag) &#123; target.foreach(value =&gt; &#123; cloneTarget.add(clone(value, map)) &#125;) &#125; // 克隆map if (type === mapTag) &#123; target.foreach((value, key) =&gt; &#123; cloneTarget.set(key, clone(value, map)) &#125;) &#125; // 克隆数组 if (type === arrayTag) &#123; foreach(target, (value, index) =&gt; &#123; // [a, b, c] =&gt; 0:a 1:b 2:c 使用的是0,1,2 cloneTarget[index] = clone(target[index], map) &#125;) &#125; // 克隆对象 if (type === objectTag) &#123; const keys = Object.keys(target) foreach(keys, (key, index) =&gt; &#123; // ['name', 'age'] =&gt; 0: 'name', 1: 'age' 我们使用到的是name, age cloneTarget[key] = clone(target[key], map) &#125;) &#125; 其他类型 通过创建实例的其他引用类型其他类型，包装类型，以及一些简单的类型 123456789const Ctor = target.constructorswitch (type) &#123; case booleanTag: case numberTag: case stringTag: case dateTag: case errorTag: return new Ctor(target)&#125; 其他类型 Symbol 1234567const s1 = Symbol('foo')// const s2 = Symbol.prototype.valueOf.call(s1) // s1 === s2const s2 = Object(Symbol.prototype.valueOf.call(s1)) // s1 !== s2function cloneSymbol(symbol) &#123; return Object(Symbol.prototype.valueOf.call(symbol))&#125; 其他类型 RegExp 12345function cloneRegExp(regExp) &#123; const flagReg = /\w*$/ // 匹配结尾的模式修饰符img const result = new RegExp(regExp.source, flagReg.exec(regExp)) // 重新创建示例 result.lastIndex = regExp.lastIndex // 修正lastIndex&#125; 其他类型 function function类型可以直接返回，但是这里也做出实现 箭头函数没有原型，可以用eval直接返回 普通函数有原型，可以使用new Function(...params, functionBody) 12345678910111213141516171819202122232425262728function cloneFunction (fn) &#123; const bodyReg = /(?&gt;=\&#123;)(.|\n)+(?=\&#125;)/m const paramsReg = /(?&gt;=\().+(?=\)\s+\&#123;)/ const fnStr = fn.toString() if (fn.prototype) &#123; // 普通函数 const body = bodyReg.exec(fnStr) const params = paramsReg.exec(fnStr) // 无函数体 if (!body) &#123; return null &#125; // 无参数 if (!params) &#123; return new Function(body[0]) &#125; // 有参数 const paramsArr = params[0].split(',') return new Function(...paramsArr, body[0]) &#125; else &#123; // 箭头函数 return eval(fnStr) &#125;&#125; 处理循环引用WeakMap,若key对应不在有引用，则下一次GC会对其引用回收，避免内存泄漏 1function clone]]></content>
      <tags>
        <tag>恰饭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10优化]]></title>
    <url>%2F2020%2F04%2F10%2Fwin10%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[关闭应用商店中的后台应用设置中搜索-后台应用，或者再隐私中找到后台关闭不需要的应用 关闭不需要的通知设置中搜索-通知，关闭不需要的通知提醒 关闭动画设置中搜索-轻松使用，关闭不需要的动画和过渡效果 关闭平板模式设置中搜索-平板模式，始终使用桌面模式，不询问我，不切换 关闭不需要启动项任务管理器中，选择启动之后关闭不需要的启动项 开启卓越性能模式（噪声大，可选）设置中，搜索电池，选择电源计划，选择卓越性能 12# powershell中，输入此代码，获取卓越性能模式powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61 禁用服务（视情况）12# 使用win+Rservices.msc Connected User Experiences and Telemetry 上传可关闭 Windows Search 可关闭 分析电脑安装的驱动使用driverstore进行分析电脑驱动，删除同命名的驱动，将旧的删除即可 如果你选择了错误的驱动，如果不勾选强制删除，是没有问题的,不会删除掉正在使用的驱动 分析电脑磁盘中安装的大小使用sspacesniffer分析电脑中各盘所占的大小，自己去寻找占用较大的文件进行处理]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git回顾]]></title>
    <url>%2F2020%2F04%2F05%2Fgit%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[Git是一种分布式代码管理的方式，相比传统的SVN相比，其速度更快（每个提交都是存储的完整快照，而不是项目补丁），性能更好（使用极致的压缩算法，使得存储占用很少） 分布式VS集中式在早前，都是用集中式（SVN）代码管理的方式，即使用一台中心服务器作为代码管理，大家都从上面拉代码，然后提交代码，但是一旦此中心服务器发生问题，则可能会丢失代码（如果要恢复，至少有一个人保存过项目的所有完整快照）并且此服务器如果发生问题后，写的代码都是不保险的，因为没有本地的代码永远是那一份，不存在版本，如果错了，只能回退到服务器发生故障之前的代码。 分布式（Git）代码管理的方式，很好的解决了上面的问题，每个人的客户端都可以作为一个项目管理仓库，并且在本地也可以做版本控制，此时公司里可以找一台服务器当做一个特殊的客户端，当然如果它坏了，只是一个客户端坏了，所有人那边都是有代码的，不会造成太大的损失 根据他们的存储方式而言，分布式代码的管理方式要比集中式代码的管理方式，存储的内容多很多，因为每个人都要存完整的项目历史，但是，由于Git团队的极致优化压缩，所占用的存储空间并不是很大，相比SVN大那么一点点点 底层原理git其实本质是一个数据库，将各个文件，进行压缩后，得到一串hash值，保存到.git（通常隐藏目录）目录中，通过Git对象，Tree对象，Commit对象来对整个项目进行管理。 Git对象一个文件存储到Git中时，就是一个Git对象，如果该文件发生了改变，那么存储过后，会生成一个新的Git对象。 只能存储Git对象的内容，并不能存储文件名称。 Tree对象多个修改好的文件，可以放到同一个提交树上，并且可以指定对象的Git对象的Hash值所对应的文件名称，等于一次存储了该项目的所有文件。 一个树对象至少有两个Git对象，一个是文件对象对应的Git对象，一个是此树对象对应的Git对象。 Commit对象等于对整个项目快照进行了一次包裹，也就是包裹了一个tree对象，并且增加了其中提交备注，提交人，邮箱，时间等，并且可以指定他的父提交对象，也就是慢慢形成了一颗Commit树。 一个提交对象对应的是一个项目的版本，而其中包裹的树对象才是一个项目的快照。 高级指令git init 初始化项目git add ./ 添加文件到暂存区 git hash-object -w, git update-index ... 先将所有修改的文件生成Git对象，之后将其存入暂存区中 表面上是：工作区-暂存区，其实是：工作区-版本库-暂存区 git commit -m &quot;.....&quot; 创建一次提交 git write-tree, git commit-tree 先将暂存区中的内容生成一个树对象，放入版本库中，在将这个树对象包裹成一个提交对象，存储版本库中 git status 查看文件的状态已暂存，已修改，已提交 git commit 提交修改 git commit 直接提交当前缓存区的文件，进入Vim编辑器编写提交注释 git commit -m &quot;这里是注释信息&quot; 直接提交当前缓存区的文件，跳过Vim编辑器 git commit -a 直接提交当前所有追踪文件，跳过存入暂存区，直接提交 git diff 查看文件修改状况 git diff --staged 查看暂存区中的文件改变情况 git log 查看git提交历史记录 git log 查看完整的git提交记录 git log --oneline / git log --pretty=oneline 查看git历史一行 删除/重命名 git rm xxx 直接删除文件，只需要git commit，相当于工作目录删除，并且追踪 git mv xxx yyy 直接重命名，只需要git commit，相当于工作目录重命名，增加删除追踪和新增追踪，并且合并到rename 分支指令git的分支相比其他而言来说，较为快速，也是让其脱颖而出的功能 分支本质就是一个提交对象，Head默认指向master,切换分支就是让Head指向不同的分支，当发生提交时，本质上就Head带着分支走 git branch git branch 显示当前的分支列表 git branch xxx 创建xxx分支 git branch xxx &lt;commitHash&gt; 在指定的提交上创建分支 git branch -d xxx 删除分支, 要求不能自家删自己，要到别的分支来删除 git branch -D xxx 大D，强制删除 git branch -v 查看branch版本 git branch -r 查看远端的分支版本 git checkout xxx 检出分支 git checkout -b xxx 创建一个新的分支并切换过去 git merge xxx 合并分支当前的分支，会将xxx分支合并过来 git reset --hard &lt;branchName&gt; 使用分支强制合并 如果是克隆下来的分支，默认没有关联关系，需要手动合并跟踪分支，或者与本地创建关联 版本回退工作区，暂存区，版本库回退回退 git checkout --filename 撤销工作区的内容 git reset HEAD filename 撤销暂存区的内容 git reset HEAD~ 返回上一次提交，版本库的内容 git reset HEAD~2 返回上2次提交 git reset &lt;commitHash&gt; 返回到提交对象上 git reset --soft 仅是HEAD移动过去 修改HEAD指向 git reset --mixed默认情况，等于git reset，将HEAD移动过去，并且将未修改的文件全部放入工作目录 修改HEAD 修改暂存区的内容 git reset --hard（该操作是有破坏性的），直接回到那个状态 修改HEAD 修改暂存区的内容 修改工作目录的内容的内容 git reset本质上还是回到分支上，并没有真正的回退，只是HEAD带着分支返回到了指定的位置，当使用git reflog还可以查看到，当前的分支 尽量少使用reset --hard，应该多开分支，之后进行merge, git branch bugfix &lt;commitHash&gt; 之后切换过去，并且进行merge。 git checkout &lt;commitHash&gt;和git reset --hard &lt;commitHash&gt;的区别 checkout 仅是牵着HEAD走，而reset --hard是牵着HEAD，并且牵着分支走 checkout 不会破坏工作区文件，而reset --hard会破坏工作区的文件 查看版本记录 git log --oneline 只会查看当前HEAD所在分支的链 git reflog --oneline 会查看git的所有操作记录 git log --graph --decorate --all --oneline 查看当前git树状况 远程协作本地分支-远程跟踪分支-远程分支 本地分支：本地代码库的分支 远程分支：远程仓库的分支 远程跟踪分支：代码被pull时自动创建，他会跟随远端自己向前，需要根据使用本地分支来合并远程跟踪分支以达到效果。 在本地创建的代码，推送到远端。本地分支推送后，会生成远程跟踪分支。 创建远端 git remote -v 查看当前关联的远程分支 git remote add &lt;storageName&gt; &lt;sotrageURL&gt; 增加仓库 git remote rm &lt;storageName&gt; 删除仓库 git remote rename &lt;oldName&gt; &lt;newName&gt; 重命名仓库名称 远程推拉（无关联关系·不推荐）git push &lt;origin&gt; &lt;branchName&gt; 推送代码 git fetch &lt;origin&gt; 拉取代码之后切换到远程跟踪分支git checkout &lt;origin&gt;/&lt;branchName&gt;,之后查看当前状态(如果确定安全，也可不查询状态)如果没有问题的话，可以直接合并分支，git merge &lt;origin&gt;/&lt;branchName&gt; 删除远程跟踪分支 git push &lt;origin&gt; --delete &lt;branchName&gt; 删除远程分支 git remote prune &lt;origin&gt; --dry-run 列出远程分支已经无用，但是远程跟踪分支任存在 git remote prune &lt;origin&gt; 删除上述列出的远程跟踪 远程推拉（有关联关系·推荐） 默认情况下 clone下来的库，其master分支与远端的master分支是有关联的，但是和本地创建的库master分支与远端master无关联 创建远端关联1234567891011# 远程创建一个分支git push --set-upstream &lt;origin&gt; &lt;localBranch&gt;:&lt;originBranch&gt;# 新建跟踪分支关联git checkout -b 本地分支 远程跟踪分支git checkout --track 远程跟踪分支 #（本地，远程跟踪分支名称相同）# 已有的分支进行关联git branch --set-upstream-to=origin/testgit branch -u origin/test #（简写） 拉取代码在当前分之下，git pull 推送代码在当前分支下，git push]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数的this指向]]></title>
    <url>%2F2020%2F03%2F23%2F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[this确定机制 js中函数会建立一个作用域，如果是类其内部也是函数，也即创造了作用域会从当前作用域中寻找this 传统函数的this是运行时确定的123456789function foo () &#123; setTimeout(function () &#123; console.log(this.id) &#125;, 1000)&#125;const obj = &#123; id: 666 &#125;obj.foo = fooobj.foo() // 输出undefined 因为在事件循环中，timeout之后，由window调用了该函数,即运行时该this为window 箭头函数的this是定义时确定的123456789function foo () &#123; setTimeout(() =&gt; &#123; console.log(this.id) &#125;, 1000)&#125;const obj = &#123; id: 666 &#125;obj.foo = fooobj.foo() // 输出666 在函数被定义的时候，就确定了该调用者为obj 箭头函数会依次向上寻找作用域中的this123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 箭头函数仅是固化了this，在其函数内部并没有this实例由于箭头函数内并没有this，所以并不能使用bind,call,apply方法来再次确定this指向 类中的this指向12345678910111213141516171819202122232425class Person &#123; name: string = 'zhn' hello() &#123; console.log(`hello $&#123;this.name&#125;`) &#125; study = () =&gt; &#123; console.log(`study $&#123;this.name&#125;`); &#125; bye = function (this: Person) &#123; console.log(`bye $&#123;this.name&#125;`); &#125;&#125;const p = new Person()p.hello() // hello zhnp.study() // study zhnp.bye() // bye zhnconst proxy: any = &#123; name: 666 &#125;p.hello.call(proxy) // hello 666p.study.call(proxy) // study zhn 已经固化了thisp.bye.call(proxy) // bye 666 其中hello方法，作为其方法，会挂载到原型上，所以this，即实例对象 其中study方法，作为一个成员，实例属性，(为其挂载了初始化值)，由于是箭头函数，无法修改this指向（为当前绑定的环境） 其中bye方法，作为一个成员，实例属性，(为其挂载了初始化值)，由于是普通函数，可以修改this指向，默认运行时的调用者为person实例 字面量中的this指向字面量中定义函数的方法 使用属性值定义study: function () {}, 使用短属性的方式，和上述一样study() {}, 使用箭头函数，注意无法直接获取this study: () =&gt; {} 123456789101112131415161718192021222324const obj: any = &#123; name: 'obj', study: function () &#123; console.log(`study $&#123;this.name&#125;`); &#125;, hello() &#123; console.log(`hello $&#123;this.name&#125;`); &#125;, eat: () =&gt; &#123; // console.log(`eat $&#123;this.name&#125;`); &#125;, designFn() &#123; return () =&gt; &#123; console.log(`designFn $&#123;this.name&#125;`) &#125; &#125;&#125;obj.study.call(&#123; name: '666' &#125;) // 输出 study 666obj.hello.call(&#123; name: '666' &#125;) // 输出 hello 666obj.eat.call(&#123; name: '666' &#125;) // 由于箭头函数中直接使用this,ts会报错const fn = obj.designFn.call(&#123; name: '666' &#125;) // 箭头函数向上绑定了一层上下文fn() // 输出designFn 666 ts中使用this 在ts中，对象属性里使用this时，默认会为一个any类型的对象，可以自己申明该对象类型，之后将this带入 1234567891011interface Obj &#123; name: string; // ...&#125;let obj: Obj = &#123; name: 'z', fn(this: Obj) &#123; // this.name &#125;&#125; 箭头函数中，this是void类型，不可改变，不能显示申明 1const fn = (this: void) =&gt; &#123;&#125; // Error Arrow function can not have 'this' 在函数的接口申明中，可以申明出this 1234567891011interface Obj &#123; fn: (this: void) =&gt; &#123;&#125;&#125;const o1: Obj = &#123; fn: () =&gt; &#123; ... &#125;&#125;const o2: Obj = &#123; fn(this: void) &#123; ... &#125;&#125;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[event对象的几种定位]]></title>
    <url>%2F2020%2F03%2F12%2Fevent%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[系列均有x,y等两个方向的值 offset距离其父元素的左侧内部边框的距离,如果边框较宽，点在边框上为负值，因为是到边框内侧距离 client其距离浏览器左侧的距离 page其距离当前页面的边框距离（client+页面滚动的距离） screen其距离当前显示器的边框距离 图片来源,博客园]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM对象各定位值]]></title>
    <url>%2F2020%2F03%2F12%2FDOM%E5%AF%B9%E8%B1%A1%E5%90%84%E5%AE%9A%E4%BD%8D%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在使用盒模型的时候，这里默认使用的是box-sizing: content-box;也是经典的盒模型，如果采用的为box-sizing: border-box;会略有不同 offset系列offset表示的为距离父定位元素的偏移值，如果其父元素没有定位元素，则会较与文档最外层比较 offsetTop 其boder的上部外侧与父元素border下部内侧之间的距离,有点像margin-top offsetLeft 其border的左侧外部与父元素border右侧之间的距离,有点像margin-left offsetWidth 其元素的宽度，包括左右两侧的border宽度 offsetHeight 其元素的高度，包括上下两侧的border宽度 scroll系列scroll表示卷曲相关,一般是用其父元素的位置,一般在内容超出父元素的位置时，才会予以显示，一父元素为基准，要设置父元素overflow: auto; scrollTop 其内部元素卷曲向上出去的距离（看不见的距离）,其border上边距外侧开始，计算到父元素内容区 scrollLeft 其内部元素卷曲左上出去的距离（看不见的距离）,其border左边距外侧开始，计算到父元素内容区 scrollWidth 表示总共可以卷曲的宽度，（其子元素左右外侧边框开始计算） scrollHeight 表示总共可以卷曲的高度，（其子元素上下外侧边距开始计算） client系列client表示该元素自身，就是内容区域 clientTop 其内部距离顶部border顶部外测的距离，相当于border的宽度 clientLeft 其内部距离border左侧外侧的距离，相当于border的宽度 clientWidth 其内部左右两侧border内侧的距离，相当于不带border的宽度 clientHeight 其内部上下两侧border内侧的距离，相当于不带border的宽度 currentStyle和getComputedStyle由于element.style的方式仅能获取行间样式，所以要获取更多的样式，可以通过以下的方式 只能进行获取，不可进行修改 1234567const element = document.getElementById('#xx')// IE中element.currentStyle['color']// 非IE中(高级IE也支持)window.getComputedStyle(element, null)['color']]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建ssh连接]]></title>
    <url>%2F2020%2F03%2F11%2F%E4%BD%BF%E7%94%A8ssh%E8%BF%9B%E8%A1%8C%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[使用hexo等进行git推送的时候，推送时都需要我们输入账户密码，较为繁琐，这里使用ssh的方式可以较好的解决 生成ssh设置git的user与email如果第一次使用，需要设置git的账户和邮箱 12git config --global user.name "xxx"git config --global user.email "xxxx@xx.com" 检测是否存在ssh 一般都会安装到用户根目录下 ~ 123456cd ~/.sshls# 或者ll# 看是否存在 id_rsa 和 id_rsa.pub文件，如果存在，说明已经有SSH Key 生成本地ssh1ssh-keygen -t rsa -C "xxxxx@xxx.com" 之后可进行检测是否生成了ssh id_rsa.pub 是公钥 id_rsa 是私钥 进行ssh连接进入到代码托管平台，如github,再其设置中，security找到ssh选项，将id_rsa.pub的内容进行提交即可 拉取代码时，换为git@xxx,即在以后的提交中都可使用ssh的方式,进行链接]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美化盒子]]></title>
    <url>%2F2020%2F03%2F11%2F%E7%BE%8E%E5%8C%96%E7%9B%92%E5%AD%90%2F</url>
    <content type="text"><![CDATA[列举几种美化css盒子的方式 使用渐变背景渐变背景实际上使用的是背景图进行渐变绘制的 123.bg &#123; background-image: xxx&#125; 线性渐变 linear-gradient()第一个参数表示方向，与y轴的夹角,支持关键字to right,to bottom 之后的参数类似颜色标点的位置，如果不加位置，会自动平分位置。 123.bg &#123; background-image: linear-gradient(45deg, #d0418e 0%, #9a08e3 100%)&#125; 径向渐变 radial-gradient()第一个参数是径向渐变的形状，默认是椭圆形的渐变方式，可以更改为圆形的渐变方式，circle closest-side(最近的边), circle closest-corner as 10% 20%(最近的角) 1234567891011.bg &#123; background-image: radial-gradient(#d0418e, #9a08e3)&#125;.bg &#123; background-iamge: radial-gradient( circle closest-side, #d0418e 0%, #9a08e3 100% )&#125; 循环渐变 repeating-liner-gradient, repeating-radial-gradient,线性渐变和径向渐变的叠加其中会按照其定义的方式进行重复,可叠加多个值，使用,隔开 12345678910111213141516171819202122232425.bg &#123; background-image: repeating-liner-gradient( to right, transparent 0, // 0px开始 透明 transparent 10px, // 10结束 透明 rgba(208, 65, 232, 0.3) 10px, // 10px开始 rgba rgba(208, 65, 232, 0.3) 20px, // 20px结束 rgba )&#125;.tablecloth &#123; // 紫色的桌布效果 background-image: repeating-linear-gradient( to bottom, transparent 0, transparent 10px, rgba(208, 65, 232, 0.3) 10px, rgba(208, 65, 232, 0.3) 20px ), repeating-linear-gradient( to right, transparent 0, transparent 10px, rgba(208, 65, 232, 0.3) 10px, rgba(208, 65, 232, 0.3) 20px );&#125; 使用背景图使用图片不仅可以使用img标签,如果该图片去掉不会影响页面的功能，那么该图片应该就以背景图的形式呈现出来 background可以为一系列组合值 background-repeat 图片重复 repeat-x repeat-y no-repeat background-size 背景图的尺寸 x的值，y的值, 一般设置一个为固定值，另一个为auto，防止图片变形，80px auto contain 自动适应，放到最大的比例，不会裁剪，但是会产生空袭 cover 覆盖，也放到最大的比例，会对图片进行裁剪，直到完全填满背景图 background-position 背景图的位置 x:left,center,right.y:top, center,bottom.虽然未指明x,y但建议先声明x,在声明y left 10px top 10px 可以先声明关键字，再次确定具体的数值12background: url(https://...) left center;background-position: left 10px top 50%; background-clip, background-origin背景图填充位置 其可选值都有border-box(default), padding-box, content-box background-clip，如果背景图被裁剪时，从哪里开始进行裁剪 background-origin, 指明背景图从哪里进行填充 使用背景图的background的组合属性的写法 组合写法较为理解较为复杂，但是性能较好 组合写法时，不用考虑属性的顺序浏览器会自动识别 background-position, background-size都时具体的数值，所以shiyong/隔开,background-position/background-size background-origin,background-clip都是相同的值，写一个认定为相同，两个认定为origin clip 也可以使用多重背景，使用,隔开即可 设置边框其中边框border是三个复合值，不分先后顺序 border-width 边框的宽度 border-color 边框的颜色 border-style 边框的样式 solid实线 dashed虚线 dotted点虚线 double双平行线 其中border属性也可以分别设置 border-left-width,border-bottom-style 设置图片边框使用border-image: url(./...) 10 repeat 边框图片的资源 裁剪九宫格的单位，默认是100% 中间重复的效果 九宫格，是指将图片，用四条线拆分，分别是上右下左的方向，分成9块区域，4个角为边框角，中间的区域去除，上下左右中间的部分进行重复/拉伸等操作 使用border-radius 50%，即设置该角为的半圆，其实是x/y = 50%/50% 按照上右下左的顺序border-radius: 10px 20px 30px 40px 也可以用/区分左，右，其实是以画椭圆的方式进行绘制的0 50% 0 50%/0 100% 0 100% 其中也可以分别设置四个角的位置border-top-right-radius 50% 和 100%如果设置的值超出自然值，浏览器会做响应的优化 12345border-top-left-raduis: 100%; // 此时是1/4的圆border-top-left-raduis: 100%;border-top-right-raduis: 100%;// 此时会显示成50%的效果 使用shadow使用模糊背景，可以有一种立体的感觉，其使用多个值 box-shadow: x偏移 y偏移 模糊半径 拓展半径 颜色 x偏移 向x轴正方向偏移的位置 y偏移 向y轴正方向偏移的位置 模糊半径 模糊半径的大小 拓展半径 在此基础上拓展出去的半径 颜色 模糊颜色 可以使用,分隔多个值出去 123.shadow &#123; box-shadow: 10px 10px 100px yellowgreen, 0 20px 10px hotpink;&#125;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存策略]]></title>
    <url>%2F2020%2F03%2F07%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[浏览时，会通过一下几种方式访问资源 (新标签)地址栏回车 链接跳转 前进、后退 从收藏栏打开链接 (window.open)新开窗口 刷新（Command + R / F5） 强制刷新（Command + Shift + R / Ctrl + F5） 其中1-5会通过访问一系列的缓存策略 是否有缓存-&lt;过期策略&gt;-&lt;协商策略&gt;-&gt; 的方式进行缓存 当拿到资源时又会通过&lt;存储策略&gt;响应内容存入缓存当中 如果刷新的方式，则会直接进行&lt;协商策略&gt;，如果是强制刷新，则会全部拿资源 解释 过期策略，通过本地缓存的文件，验证是否过去，是否应用缓存，又Expires,Cache-control 协商策略，通过询问远端的服务器，是否需要抓取新的资源，是否需要重新获取，有ETag,Last-Modified 存储策略，响应内容存入缓存中 Expires,Cache-Control其中都属于&lt;过期策略&gt;的内容 Expires存储的时过期的时间，如果本地时间后于某一时刻，那么就称之为过期了 Expires: Sat Oct 20 2018 00:00:00 GMT+0800 (CST) Cache-control是一系列cache-directive（缓存指令）值，中间使用,隔开 可缓存性相关 public 在客户端和代理服务器缓存（公共资源适用） private 在客户端缓存，代理服务器不缓存（用户个人资源） no-cache 不进行过期策略，直接走协商策略（no-cache走协商策略，no-store是完全不缓存） 过期相关 max-age=&lt;seconds&gt; 多少秒后过期，如果和Expires同时设置，则Expires失效 其他 no-store 完全不缓存 仅列举了部分资源 ETag,Last-ModifiedLast-Modified存储的格式为，Last-Modified: &lt;day-name&gt;，&lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT,表示上一次修改的时间，该修改只会精确到秒，会向服务端询问是否发生了更改。 下次一次刷新的时候，会带有If-Modifued-Sience: xxx 就是上一次获取的last-modified,去和服务器做对比，如果请求过去，发现是上一次为修改过，则会返回304 ETag文件修改，则会改变该值，如果文件未发生改变，则返回304，ETag: &quot;e6sda124q84ds4&quot; 四种方式优缺点 Expires 优点：http1.0, 简单易用，通过绝对时间标识 缺点：服务器时间和本地时间不一致的问题，如果资源过期前对其进行了修改，客户端是无法知道的 Cache-Control 优点：http1.1内容，相对时间标识，较安全，可配置的指令也很多 缺点：http1.1才适用，不适用之前1.0版本，如果资源过期前进行了修改，客户端也是无法更改的 Last-Modified 优点：不存在版本问题，没过期直接返回304 缺点：精确到秒，不适用多次重复修改，如果资源并未发生实质性的修改，则也会重新返回 ETag 优点：不存在版本问题，没过期直接返回304，可以识别一秒内多次修改，如果资源修改，并未发生实质内容，则ETag值可以不做改变 缺点：计算ETag会有一定的性能开销，如果分布式服务器计算ETag不同,验证不会通过 最佳实践 适用很大的Cache-Control:max-age, 和Expires，适用ETag进行校验 适用业务逻辑，比如xxx/js/index.js?s84vcxzc添加hash或者，timestamp]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器工作原理]]></title>
    <url>%2F2020%2F03%2F07%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[宏观 将网址转换为IP地址，通过浏览器缓存-系统缓存-路由器缓存-ISP供应商缓存 去DNS服务器查询网址所对应的ip地址 向ip地址服务器发出请求 目标服务器解析请求，返回内容 浏览器相应内容，并呈现给用户 主要分析浏览器拿到文档时，他是如何进行渲染的 浏览器主要内核为webkit版和Gecko 大致流程浏览器首次绘制 1.渲染引擎从网络层获取文档内容 2.DOM部分有DOM解析器生成DOM树（DOM tree），样式部分由样式解析器生成样式规则（style rules） 2.两者通过附加（attachment）生成渲染树（render tree） 3.该渲染树进行布局(layout),添加坐标位置信息 4.最后经过绘制（painting）经由渲染引擎经行绘制 浏览器进行二次绘制 发生重绘（repaint）回流/重排（reflow） 重绘对应的是painting阶段，也就是改变了元素的样式，并未改变元素的位置，如background,color,visible等，对其他元素没有什么影响 回流对应的是layout阶段，也就是元素的位置发生了改变，需要浏览器根据当前窗口的大小重新计算各个元素的位置，进行定位后，在绘制，如果浏览器自身窗口大小也发生了改变，那么也就会应用于reflow,元素的位置是根据当前的窗口大小进行改变的 按照流程来讲，reflow -&gt; repaint，所以发生reflow时，一定会经历repaint, 发生repaint时，不会触发reflow 如何避免DOM回流 避免操作DOM，就是最好的避免DOM回流的方式，使用现代框架，基于virtualDOM以及DOMDiff能很好的解决问题，所以使用第三方框架是较好的一种选择，这里展示的是手动操作DOM时的一些优化建议 分离读写操作 读操作，放在一起，写操作放在一起，现代浏览器会做部分优化，会对连续的写操作进行缓存，一次处理 缓存布局信息 12345678910// 看似一次回流，其实中间穿插了读写，较影响性能element.style.width = element.clientWidth + 10 + 'px'element.style.height = element.clientHeight + 10 + 'px'// 缓存布局信息const widht = element.clientWidthconst height = element.clientHeightelement.style.width = width + 10 + 'px'element.style.height = height + 10 + 'px' 批量文档修改 使用fragment 12345678let fragment = document.createDocumentFragment()for (let i = 0; i &lt; 5; i++) &#123; const newLi = document.createElement('li') newLi.innerText = i fragment.appendChild(newLi)&#125;element.appendChild(fragment)fragment = null // 手动释放 使用字符串拼接 基于模板字符串的方式 12345let liContent = ''for (let i = 0; i &lt; 5; i++) &#123; liContent += `&lt;li&gt;$&#123;i&#125;&lt;/li&gt;`&#125;element.innerHtml = liContent 动画效果应该尽可能的脱离文档流，避免影响其他元素 CSS使用有硬件加速的效果，底层做了避免回流操作 1element.style.transform = 'translateX(200px)' 尽可能避免使用table布局 文档的特性是流式布局，所以使用table布局，会进行多次回流操作 渲染关键路劲css由于样式有层叠的属性，所以必须要等样式全部加载完后再进行,否则会进行多次重建CSSOM,一般建议将style放在head部分，建立在下文中的style标签容易会被阻塞，从而重建CSSOM html由于文档是从上到下构建的，从而可以一边接受一边展示，所谓的流式。 jsjs代码在执行时，也是从上到下执行的，但是由于其又可以改变css，也可以改变DOM结构，所以js执行的时候，CSSOM,DOM构建需暂停 一般情况构建如果只有html与css,即没有script代码嵌入到html中，那么会一边构建CSSOM，一边构建DOM，待两者最长的一个完成时（两者可以同时构建）,组成render-tree，经过定位，绘制呈现到浏览器上 如果有html,css,js,那么在执行到js的时候，必须要停止css,和html的解析，又因为样式必须一次性加载完毕（否则可能获取的错误的CSS），所以最终的加载顺序CSSOM -&gt; JS -&gt; HTML,所以如果js代码写在html之前，就无法获取之后的内容，因为之后的html还未执行到。 优化渲染关键路径三种因素会互相制约 关键资源的数量 关键路径的长度 关键字节的数量 关键资源指的是那些阻塞页面首次渲染的资源，如js,css,阻塞关键渲染，浏览器处理渲染的工作量越少，CPU占用的其他资源也越少 关键路径的长度是指关键路径的总耗时，每一步耗时越长其总体被阻塞的时间就会越长，其受到网络情况，关键资源数量，以及关键字节大小有关。 关键字节数量是指资源的字节大小，浏览器下载字节越少，其处理速度就会越快。 缩小DOM 缩减文件的尺寸，去除注释，去除无用的代码 使用gzip压缩 使用缓存 优化CSSOM 只将首屏资源放入，由于css会阻塞页面，在暂时用不到的地方可以设置为预加载，或者使用hack的方式加载 1&lt;link href="style.css" rel="stylesheet" media="print" onload="this.media='all'"&gt; 将主要的首屏渲染放入head中，减缓下载的时间，可参考critical css 少使用@import他会使文件串行加载 优化js js文件也要压缩，使用tree-shaking功能进行优化 使用异步加载js,&lt;script async src=&quot;...&quot;&gt;&lt;/script&gt;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-基础-选择器]]></title>
    <url>%2F2020%2F03%2F07%2Fcss-%E5%9F%BA%E7%A1%80-%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[html,css历史在 1990 年，Tim Berners-Lee 发明 HTML 时，主要是为了规范科研文档的格式。这时 HTML 是一个简单的标记语言，为文档赋予了基本的结构和意义，包括如标题、列表、定义等标签。后来为了展示更多的效果，以及对部分标签的滥用，比如table标签被用来布局等，样式和结构逐经行了抽离。 css历史 css1在1996年成为标准 css2在1998年成为标准 css3在2002就被提上议案，并不同的模块被提上不同的提案，不同模块单独控制，从level1开始，如果是之前已经有的内容，则题为level3并继续发展 html历史html经过4.01版本后，衍生出了xhtml1.0,由于其过于严格,最终无法落地，最终诞生出了html5. css的渐进增强与向后兼容渐进增强首先为最小的，公共部分的浏览器准备能用的内容，其次在为支持新特性的浏览器增加内容 向后兼容在使用新特性时，新属性在前，后属性在后，即使新特性用不了，也可以使用旧的兼容的特性。 厂商前缀 -webkit-适用于webkit内核浏览器 safari/chrome/opera -moz-适用于Mozilla内核 Firefox -ms-适用于微软的IE 其中可使用autofix，或者webpack中的postcss/postcss-preset-env来自动增加前缀信息。 语义化标签多使用语义化标签，能够便于浏览器识别，或是屏幕阅读器，或是单纯的处理文本的浏览器，或者盲文点触设备，更利于搜索引擎进行搜索 css选择器种类独立选择器自己单独就可使用 标签选择器匹配给定元素名称的元素 1input &#123;&#125; 类选择器选中class属性中包含指定的属性值，必须是完整的属性 1.intro &#123;&#125; id选择器，与之唯一的一个id,页面中唯一出现的属性 1#idname &#123;&#125; 通用选择器选择器选择所有的节点，也用.intro &gt; *表示.intro的所有子元素 1* &#123;&#125; 属性选择器根据属性来匹配， 属性值开头img[src^=&quot;http://&quot;] 属性值包含img[src*=&quot;http://&quot;] 属性值结束img[src$=&quot;http://&quot;] 12[type] &#123;&#125;[class='intro'] 伪元素选择页面的特殊区域，不是通过元素来表示的 排版类，暂时应用于inline中 首行::first-line, 首字母::first-letter, 存在于页面DOM中,content不为none时会显示 之前::before 之后::after 其他 输入框占位元素::placeholder 1::after &#123;&#125; 伪类选择页面中元素的特殊状态 1:hover &#123;&#125; 由于在移动设备中，不一定有真的悬浮状态，所以要慎重使用hover 超链接 普通链接（未点击过）a:link 访问过的链接 a:visited 悬停/键盘tab预选时 a:hover 活动状态，鼠标点击时 a:active 目标与反选浏览器的目标匹配id, 该元素被匹配 :target浏览器地址为: http://example.com/blog/1/#comment-3 元素id为hash值 &lt;article class=&quot;comment&quot; id=&quot;comment-3&quot;&gt;&lt;/article&gt; 1.comment:target &#123;&#125; 反选 :not()选中comment,但是不能是违法评论(.illegal) 1.comment:not(.illegal) &#123;&#125; 结构化伪类其中默认从1开始，如果设置了n，则n的取值从0开始递增 只选择元素 :nth-child() 正向选择 :nth-last-child() 从后开始计数选择 :first-child() :last-child() 选择同等类型的,过滤掉不符合类型的 :nth-of-type() 正向选择 :nth-last-of-type() 从后开始计数选择 表单伪类 :required,:optional 必填和选填项 :disabled,:read-only, :read-write 禁用，只读，读写 :vaild,:invaild, 有效，无效 组合选择器通过单独选择器的组合，其中s1,s2,s3表示独立选择器 由于浏览器渲染顺序，都是往后进行选择，如存在向前的选择器，那么浏览器会对一个文档进行多轮渲染 分组选择器用逗号最为分隔，多个选择器同时应用一种样式 1s1, s2, s3 &#123;&#125; 后代选择器用空格作为分割，选择其后代 1s1 s2 s3 &#123;&#125; 子选择器使用大于号作为分隔，只会选择器子元素，不会跨越元素去选 1s1 &gt; s2 &#123;&#125; 相邻元素选择器选择其后的相邻的元素，如果符合则选定，不符合则不选定，不会跳跃查于其所有的兄弟元素，也不会查其子元素 12// 查找s1紧跟的兄弟元素s2, 如果s1后的紧邻兄弟元素不是s2，则不予以选定s1 + s2 &#123;&#125; 一般同类选择器选择其后的相邻的元素，会跳跃查其所有的兄弟元素 12// 查找s1以后的所有兄弟元素s2, 紧跟元素有多少选择多少s1 ~ s2 &#123;&#125; css选择器的特殊性a, b, c, d css是采用4个级别判定该样式的优先级（从左往右比较顺序），每个级别只会在其位置上增减，并不会进位，相同优先级，从上到下的顺序排列 a=1,a是行内样式， b=ID选择器的个数 c=类选择器的个数和伪类选择器的个数 d=类型选择器和伪元素选择器的个数 123456&lt;div id="dv-1" class="box target current"&gt;&lt;/div&gt;div &#123;&#125; // 0.0.0.1div .box &#123;&#125; // 0.0.1.1.box.target.current // 0.0.3.0#dv-1 &#123;&#125; // 0.1.0.0 css的继承所有父元素的属性均会继承给其子元素，该元素有自己的样式，则会覆盖继承样式（针对同样式而言） 12345678&lt;body&gt; &lt;h1&gt;css&lt;/h1&gt;&lt;/body&gt;body &#123; color: red; &#125;h1 &#123; color: blue; &#125;最终内容为blue h1收到body的样式继承为red, 又因为h1设置了自己的颜色，所以会覆盖继承的red,为blue 1234567&lt;body&gt; &lt;h1&gt;css&lt;/h1&gt;&lt;/body&gt;body &#123; font-size: 50px; &#125;最终h1的字号为浏览器自带（并非body继承的50） h1收到body的样式继承为50px,因为浏览器默认对标题有字号设置，所以覆盖继承的50px,为之前字号大小 1234567891011// 特列&lt;body&gt; &lt;h1&gt; hello&lt;em&gt;css&lt;/em&gt; &lt;/h1&gt;&lt;/body&gt;* &#123; color: red; &#125;h1 &#123; color: blue; &#125;最终hello呈现blue，css呈现red *等于为每个元素都设定了样式，虽然h1的blue继承给了内部的em，但是之前的*为其设置的样式进行了覆盖，所以呈现red]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[送你个月亮，让你安然入睡]]></title>
    <url>%2F2020%2F02%2F27%2F%E9%80%81%E4%BD%A0%E4%B8%AA%E6%9C%88%E4%BA%AE%EF%BC%8C%E8%AE%A9%E4%BD%A0%E5%AE%89%E7%84%B6%E5%85%A5%E7%9D%A1%2F</url>
    <content type="text"><![CDATA[天上最亮的星，是启明星，原来他那么亮。]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用yum安装nginx并配置https服务]]></title>
    <url>%2F2020%2F02%2F14%2F%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AEhttps%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[centos7 运行环境为腾讯云 使用yum安装nginx添加nginx到yum源1rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装nginx1yum install -y nginx 启动nginx12345# 启动nginxsystemctl start nginx# 开机自启systemctl enable nginx 安装certbot安装epel 增强源1234yum -y install epel-releasewget -O /etc/yum.repos.d/epel-7.repo http://mirrors.aliyun.com/repo/epel-7.repo# 刷新yum源yum clean all &amp;&amp; yum makecache &amp;&amp; yum update 安装yum-utils123yum -y install yum-utilsyum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional 安装python2-certbot-nginx 使用python2开发，再nginx.conf文件中，去掉中文字符 1yum install python2-certbot-nginx 使用certbot开启https 如果自定义make编译安装nginx，要更改相关路径，添加软连接 将certbot配置到nginx1certbot --nginx 配置步骤 输入你的邮箱名: xxx@xxx.com 同一协议: A 允许邮件推送: Y 选择添加https配置域名: 1 2 输入相关数字使用空格隔开 同时保留http,https: 1]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用now-cli部署前端项目到zeit上]]></title>
    <url>%2F2020%2F02%2F08%2F%E4%BD%BF%E7%94%A8now-cli%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%88%B0zeit%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[用zeit( https://zeit.co/ )部署项目，用来做演示，做demo都是一个不错的选择。 安装now-cli12345# 使用npmnpm i now -g # 或者使用yarnyarn global add now 登录1now login 部署静态网站标准网站的结构，如果是单页应用，用此方式路由之后，手动刷新会出现404的问题，可以使用hashRouter解决 目录结构： 12345├─css├─img└─js││ index.html 使用now进行部署,处于当前目录中 12345# 一键部署now# 重新命名项目now --name foo 部署前端项目直接在项目更目录中进行部署即可，自动build,这种部署方式有不存在路由刷新问题 12345# 一键部署now# 部署生产环境now --prod 官方文档https://zeit.co/docs/now-cli#commands/now]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则加强]]></title>
    <url>%2F2020%2F01%2F12%2F%E6%AD%A3%E5%88%99%E5%8A%A0%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[方法1234String.prototype.match // 匹配RegExp.prototype.test // 是否符合RegExp.prototype.exec // 执行，进行捕获 字面量，构造函数创建的区别字面量创建，元字符使用比较简单，构造函数需要特殊转义，转义符才能使用12345// 字面量方式创建let reg1 = /\d+/;// 由构造函数创建,注意由于使用字符串的方式，要注意转义的问题，一般将\变为\\即可let reg2 = new RegExp('\\d+'); 如果要拼接正则，只能使用构造函数的方式123456789let name = 'zhn'let reg = /^@'+type+'@$/reg.test('@zhn@') // falsereg.test("@'''''''typeeeee'@") // truelet name = 'zhn'let reg = new RegExp('^@' + name +'@$')reg.test('@zhn@') // truereg.test("@'''''''typeeeee'@") // false 正则匹配修饰符i =&gt; ignoreCase 忽略大小写m =&gt; multiline 多次匹配g =&gt; global 全局匹配 常用元字符量词元字符1* + ? &#123;m&#125; &#123;m,&#125; &#123;m,n&#125; 特殊元字符12\ . ^ $ \n \w \s \b \t a|b|c [abc] [a-z] [^n34]() (?:) (?=) (?!) 普通元字符1/RegExp/ -&gt; 匹配 &apos;RegExp&apos; 括号相关() 表示分组改变优先级， 1234567891011121314151617// 表示18|29,会出现较为混乱的结果let reg = /^18|29$/reg.test('18') // truereg.test('29') // truereg.test('189') // truereg.test('129') // truereg.test('1829') // truereg.test('829') // true// 结合小括号完成需求let reg = /^(18|29)$/reg.test('18') // truereg.test('29') // truereg.test('189') // falsereg.test('129') // falsereg.test('1829') // falsereg.test('829') // false [] 表示本身含义仅表示一个字母中括号内仅表示一位字母（所有出现的可能性，也只能代表出现的一次） 1234567891011reg = /^[@+]$/ // 包含在内reg.test('+') // truereg.test('@@') // false // 2个字母reg.test('@+') // falsereg.test('ab') // false // 2个字母reg = /^[^@+]$/ // 不能出现在内reg.test('+') // falsereg.test('@@') // false // 2个字母reg.test('@+') // falsereg.test('a') // false 特殊元字符（及元字符在中括号内） 注意，\是表示转义,[\d] 表示的为\d, 如果是[\\d],则表示\或者d所以在字符串中，也不要忘记转义的存在 123456789101112131415reg = /^[\d]$/reg.test('\\') // falsereg.test('d') // falsereg.test('6') // truereg = /^[\\d]$/reg.test('\\') // truereg.test('d') // truereg.test('6') // falsereg = /^[\w]$/ // \w 即数字字母下划线reg = /^[\\w]$/ // 只表示 \ 和 w, (如果要用字符串做检测，同样需要对字符串\转义 '\\')reg = /^[10-29]$/ // 表示1 | 0-2 | 9 正则的懒惰性在正则匹配中，会在其实例对象上的lastIndex记录上一次匹配的位置 1234567let reg = /\d+/greg.exec('2020-01-08') // 0console.log(reg.lastIndex) // 4reg.exec('2020-01-08') // 5console.log(reg.lastIndex) // 7reg.exec('2020-01-08') // 8console.log(reg.lastIndex) // 10 正则方法exec中，会展现出其懒惰性，主要取决于是否加g,也即regExp.global是否为true,在为true的情况下，才会继续匹配 这里的懒惰是指正则是否会继续在记录匹配，/\d+/与/\d+/g在reg.exec中都会只匹配一次，只是g模式可以继续执行reg.exec。而str.match中，g可以一次性全匹配出来，即匹配成也给数组[&#39;2020&#39;,&#39;01&#39;,&#39;06&#39;] 12345678910111213141516let reg = /\d+/greg.exec('2020-01-08') // 0console.log(reg.lastIndex) // 4reg.exec('2020-01-08') // 5console.log(reg.lastIndex) // 7reg.exec('2020-01-08') // 8console.log(reg.lastIndex) // 10let reg = /\d+/reg.exec('2020-01-08') // 0console.log(reg.lastIndex) // 0reg.exec('2020-01-08') // 0console.log(reg.lastIndex) // 0reg.exec('2020-01-08') // 0console.log(reg.lastIndex) // 0 利用惰性求值，处理execall,核心12345678let reg = /\d+/glet str = '2019-01-08'let res = reg.exec(str)while(res) &#123; console.log(res) // 依此输出2019，01，08 res = reg.exec(str)&#125; 使用了惰性求值后，regExp均会记录lastIndex 12345let res = reg.exec(str)while(reg.test(str) === true) &#123; // 此时会做一次匹配 移动一次lastIndex console.log(res) res = reg.exec(str) // 此时会做一次匹配 移动一次lastIndex&#125; 正则贪婪性懒惰性： 每次捕获时仅捕获第一个符合的匹配串 贪婪性： 满足条件就会一直匹配 12345678let reg = /\d+/glet str = '2020-01-10'str.match(reg) // ["2020", "01", "10"]let reg = /\d+?/glet str = '2020-01-10'str.match(reg) // ["2", "0", "2", "0", "0", "1", "1", "0"] ?的五大作用 /\d?/ 表示0次或1次 /\d+?/ 表示最终捕获一个 /(?:)/ 只分组不捕获 /(?=)/ 正向匹配预查 /(?!)/ 正向不匹配预查 /(?&lt;=)/ 负向匹配预查 /(?&lt;!)/ 负向不匹配预查 正则替换，replace匹配字符串替换的问题每次匹配一个 123let str = 'zhn and zhn'str = str.replace('zhn', 'me') // 'me an zhn'str = str.replace('zhn', 'me') // 'me an zhn' 可能造成重复匹配 123let str = 'zhn and zhn'str = str.replace('zhn', 'goodzhn') // 'goodzhn and zhn'str = str.replace('zhn', 'goodzhn') // 'goodgoodzhn and zhn' 使用正则匹配较优，String.prototype.replace(reg, [String] | [Fn]),与正则搭配是比较好的 记得全局匹配 g 12345let str = 'zhn and zhn'str = str.replace(/zhn/g, 'me') // 'me an me'let str = 'zhn and zhn'str = str.replace(/zhn/g, 'goodzhn') // 'goodzhn and goodzhn' 单词首字母大写转换 123456789let str = 'good good study, become a good man.'let reg = /\b([a-zA-Z])[a-zA-Z]+\b/gstr = str.replace(reg, (...args) =&gt; &#123; let [content, $1] = args // 首字母大写，并且除去首字母的内容 return `$&#123;$1.toUpperCase()&#125;$&#123;content.substr(1)&#125;`&#125;)console.log(str) // Good Good Study, Become a Good Man. 正向负向预查正则表达式中匹配出：形参，函数体 12const bodyReg = /(?&gt;=\&#123;)(.|\n)+(?=\&#125;)/mconst paramsReg = /(?&gt;=\().+(?=\)\s+\&#123;)/]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[End.2019]]></title>
    <url>%2F2019%2F12%2F31%2FEnd-2019%2F</url>
    <content type="text"><![CDATA[在2019年的尾巴，给自己总结一下，人嘛，毕竟还是要多反思自己才对。 2019年，不大不小的年纪了，现在还是21岁，马上就22岁了，再接再厉，想要的，靠自己的双手都能得到。 学习大学的课程也都上完了，时间真快，今年一下子全上完了，不出意外，下学期就实习，毕业设计，自己就大学毕业了，曾经想努力修完课程，然而现在，突然一下，就都没了，大学生活还算是充实吧，自己也学习了前端，还蛮不错，继续努力吧。 工作去公交云实习了，也算是人生第一家公司吧，就叫他老东家把，也很感谢Marco带我上道。其实还蛮快的，觉得自己还像个孩子，突然就要开始工作了，冲吧，加油。 生活生活上，算是不幸，也算是万幸，怎么说呢，有好有坏，坏的呢，就不说了，人们总是会对有些事情耿耿于怀，努力就好，好事呢，感觉自己在慢慢的成长，唉，感觉自己要长大了，爸爸妈妈老了，现在这个样子，肯定不行，所以呢，这就是我的动力，好好的，不管发生了什么，都过去好了，人生这本书总是要翻页的。就这样吧，毕竟抱怨也什么都不会得到，袖子一撸，就是干。 其他其他吗，也没什么了，希望她过得好好的，哈哈哈哈，那就这样吧，浩南哥，要努力呀。毕竟现在凭实力单身，或许真正自己还没那个能力，拿起刀我就无法拥抱你 放下刀我就无法保护你,先让自己强大起来吧，嗯加油。 总结时间蛮快的，要多花时间给身边的人，其实呢，还是要先努力强大自己，对于这一年被我有意无意伤害的人，说一声抱歉，对那些在意我，爱护我的人，说一声谢谢，其实在这里还是最感谢我的爸爸妈妈，你们是我最强大的动力，谢谢。 最后，新年愿望，2020年，保持一颗好学的心，静下心来去学习前端，本身就是我的爱好，有什么理由被别人拉下呢，还有就是希望我爸爸妈妈身体健康。Over!仅此而已，新年快乐，2020。 我曾难自拔于世界之大也沉溺于其中梦话不得真假 不做挣扎 不惧笑话 –《起风了》·吴青峰]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结题4]]></title>
    <url>%2F2019%2F12%2F27%2F%E6%80%BB%E7%BB%93%E9%A2%984%2F</url>
    <content type="text"><![CDATA[填充数据处理1234567let obj = &#123; 1: 111, 2: 222, 5: 555,&#125;let arr = [null, null, 111, 222, null, null, 555, null, null, null, null, null] 创建数组，按照index依次放入123let arr = new Array(12) .fill(null) .map((item, index) =&gt; obj[index-1] || item) 利用keys的特性1234567891011121314let arr = new Array(12).fill(null)Object.keys(obj).forEach(item =&gt; arr[item-1] = obj[item])``` ## 转换数组后检查加入length属性，模拟成一个类数组，转换过来，不过要对照次序关系```jsobj.length = 13let arr = Array.from(obj) .slice(1) .map(item =&gt; typeof item === 'undefined' ? null : item) 三种排序方式冒泡排序(改变该数组)依次比较前后的元素，是否需要交换位置 123456789101112function bubble (arr) &#123; for (let i = 0; i &lt; arr.length - 1; i++) &#123; for (let j = 0; j &lt; arr.length - i - 1; j++) &#123; // 小于则交换 if (arr[j] &gt; arr[j+1]) &#123; let temp = arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; &#125; &#125;&#125; 插入排序(返回一个新数组)直接重新生成一个数组，插入每一项的时候按照顺序插入即可 1234567891011121314151617181920212223242526function insert (arr) &#123; const result = [] // 默认放入第0个元素 result.push(arr[0]) for (let i = 1; i &lt; arr.length; i++) &#123; const nextValue = arr[i] // 查找需要插入的位置 for (let j = result.length - 1; j &gt;= 0 ; j--) &#123; // 从后往前，找到了比它刚好小的，则放入这个后面即可 if (result[j] &lt; nextValue) &#123; // 插入到之后，应该是index+1 result.splice(j+1, 0, nextValue) break &#125; // 比较之后，到了最后的元素,是当前最小的元素 if (j === 0) &#123; result.unshift(nextValue) &#125; &#125; &#125; return result&#125; 快速排序类似一种分治的策略，左边比较一下，右边比较一下 12345678910111210,3,6,7,5,8,11. 找到7左侧（小）：3,5,6,1 2.找到5， 左侧(小)：3,1 1,3 右侧(大): 6右侧（大）：10,8 ....类似二叉树的中序遍历 12345678910111213141516171819202122232425262728function quick (arr) &#123; // 如果数组只有一项不必要继续下去,有可能一部分是空的，为0 if (arr.length &lt;= 1) &#123; return arr &#125; // 寻找中间项 const middleIndex = Math.floor(arr.length / 2) // 取出中间项(并从原数组剔除) // arr = [...arr.slice(0, middleIndex), ...arr.slice(middleIndex+1)] const middleValue = arr.splice(middleIndex, 1)[0] // 准备左右数组递归下去 const leftArr = [] const rightArr = [] for (let i = 0; i &lt; arr.length; i++) &#123; arr[i] &lt; middleValue ? leftArr.push(arr[i]) : rightArr.push(arr[i]) &#125; // 左右数组分别进行,并返回 // return [ // ...quick(leftArr), // middleValue, // ...quick(rightArr), // ] return quick(leftArr).concat(middleValue, quick(rightArr))&#125; 数组交集，并集，补集123456789function intersect (arr1, arr2) &#123; // arr1中存在arr2 return arr1.filter(v =&gt; arr2.includes(v) === true)&#125;function union (arr1, arr2) &#123; // arr1全部铺入，arr2铺入不在arr1存在的元素 return [...arr1, ...arr2.filter(v =&gt; arr1.includes(v) === false )]&#125; 数组旋转移动数组，[1,2,3,4] -&gt; 2 [3,4,1,2] 真实移动12345function roate (arr, offset) &#123; // 偏移中间的位置 const middle = arr.length - offset return [...arr.slice(middle), ...arr.slice(0, middle)]&#125; 模拟队列操作1234567function roate (arr, offset) &#123; const result = [...arr] for (let i = 0; i &lt; offset; i++) &#123; result.unshift(result.pop()) &#125; return result&#125; 函数柯里化，实现累加指定累加次数，使用递归其实是使用递归等待函数，直到凑齐了所有的参数 123456789101112131415161718192021function currying (fn, argsLength) &#123; return function (...args) &#123; // 参数数量达到即可执行 if (args.length &gt;= argsLength) &#123; return fn.call(null, ...args) &#125; // 为达到参数，继续柯里化 return currying(fn.bind(null, ...args), argsLength - args.length) &#125;&#125;function add (...args) &#123; return args.reduce((sum, current) =&gt; sum + current, 0)&#125;const curryAdd = currying(add, 4)console.log(curryAdd(1, 2, 3, 4)) // 10console.log(curryAdd(1)(2, 3, 4)) // 10console.log(curryAdd(1)(2, 3)(4)) // 10 使用特殊方法触发累加toString,在某些特定的状态下时，会自动触发。 123456789101112131415161718192021function add (...initArgs) &#123; const args = initArgs // 后续函数作用仅仅是增加args const adder = (...currentArgs) =&gt; &#123; args.push(...currentArgs) return adder &#125; // 手动覆盖toString adder.toString = () =&gt; &#123; return args.reduce((sum, current) =&gt; sum + current, 0) &#125; return adder&#125;console.log(add(1, 2, 3, 4).toString()) // 10console.log(add(1)(2, 3, 4).toString()) // 10console.log(add(1)(2, 3)(4).toString()) // 10]]></content>
      <tags>
        <tag>恰饭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结题3]]></title>
    <url>%2F2019%2F12%2F26%2F%E6%80%BB%E7%BB%93%E9%A2%983%2F</url>
    <content type="text"><![CDATA[排序问题，自己添加排序项，后续再删除String.prototype.localeCompare(),类似于调用字母顺序比较 1234567891011121314let arr1 = [ 'A1','A2', 'B1', 'B2', 'C1', 'C2' ]let arr2 = ['A', 'B', 'C']// arr = [ 'A1','A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C']// 简单调用sort方法，使用localeCompare,返回结果是字母顺寻 [A, A1, A2, ....]// 先对arr2处理一下arr2 = arr2.map(item =&gt; item + '啦啦')let arr = arr1.concat(arr2)// 汉字顺序要滞后与字母arr = arr .sort((prev, next) =&gt; prev.localeCompare(next)) .map(item =&gt; item.replace('啦啦', '')) 异步编程12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 1000)&#125; 闭包12345678910111213// 整个方法闭包for (var i = 0; i &lt; 10; i++) &#123; (function(i) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 1000) &#125;)(i)&#125;// 回调函数闭包for (var i = 0; i &lt; 10; i++) &#123; setTimeout((i =&gt; () =&gt; console.log(i))(i), 1000)&#125; 使用let块级作用域12345for (let i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 1000)&#125; 使用bind预处理1234const fn = i =&gt; console.log(i)for (var i = 0; i &lt; 10; i++) &#123; setTimeout(fn.bind(null, i), 1000)&#125; 匿名函数名称问题匿名函数不能为其申明名称，但是如果申请后，是不许与在重新赋值 &#39;use strict&#39;模式下，会直接报错，非严格模式下，不会报错。 123(function b () &#123; // b = 20; 无效&#125;)() 作为一个块级内部变量(参数)可以做修改所用 匿名函数的命名本来就是不被推荐的，如果有形参重名，那么以形参为准 123456var b = 20(function b (b) &#123; b = 10 consoel.log(b) // 10&#125;)()console.log(b) // 20 ==, ====== 值和类型完全一致，严格== 值相等即可，其判别的依据如下类型相同的情况下，会直接比较 类型不相同,会转换类型进行比较 {}=={}, 两个对象进行比较，是比较堆内存的地址 null==undefined 相等， / null !== undefined NaN != NaN [12] = ‘12’, 调用toString后，在进行字符串的比较 其余情况都是进行数字的比较 boolean true=1, false=0 number = number string = Number(‘str’), 如果有非数字则会变为NaN undefined = NaN Object(object - Number(obj.toString()), null - NaN) 保证成立123if (obj == 1 &amp;&amp; obj == 2 &amp;&amp; obj == 3) &#123; console.log('OK')&#125; 覆盖toString12345678910111213let obj = &#123; n: 0, toString() &#123; return ++this.n &#125;&#125;const arr = [1, 2, 3]let obj = &#123; toString() &#123; return arr.shift() &#125;&#125; 覆盖defineProperty将a,作为window的一个变量即可 123456const arr = [1, 2, 3]Object.defineProperty(window, 'obj', &#123; get() &#123; return arr.shift() &#125;&#125;) 模拟push,push的简易实现123456789Array.prototype.push = function (value) &#123; // 默认插入，到尾部 this[this.length] = value // length长度严格意义是浏览器对其控制增减操作 this.length++ return this.length&#125; 12345678910let obj = &#123; 2: 3, // this[2] = 1 2: 1 3: 4, // this[3] = 2 3:2 length: 2, // 2 -&gt; 3 -&gt; 4 push: Array.prototype.push&#125;obj.push(1)obj.push(2)console.log(obj) // &#123; 2:1, 3:2, length: 4 ...&#125;]]></content>
      <tags>
        <tag>恰饭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结题2]]></title>
    <url>%2F2019%2F12%2F26%2F%E6%80%BB%E7%BB%93%E9%A2%982%2F</url>
    <content type="text"><![CDATA[图片懒加载 delay load主要核心 懒加载，不要给他img的src赋值适当的时候，再将img的地址赋值给src,这样可以做到按需加载，&lt;img src=&quot;&quot; data-src=&quot;xxx&quot;/&gt;,等到合适的时机进行替换即可 懒加载处理时机懒加载的对象已经完全出现在了视口内，即当前视口的底端距离window（height + scrollTop）,必须要&gt;= 该对象距离顶部的距离img（height + offset.Top） 事件相关委托给window事件，图片加载完成的事件,img.addEventListener(&#39;onLoad&#39;, handle) 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container &#123; width: 410px; margin: 0 auto; &#125; .imgBox &#123; height: 180px; margin-bottom: 20px; background-color: #BBB; &#125; .imgBox img &#123; display: none; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt;&lt;/div&gt; &lt;script src="../node_modules/jquery/dist/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="./delayLoad.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const $container = $('.container');const $window = $(window);// 动态创建图片let str = ''new Array(20).fill(null).forEach(item =&gt; &#123; str += `&lt;div class="imgBox"&gt; &lt;img src="" data-img="https://i0.hdslb.com/bfs/archive/a84e5a2751c81ddf51ecb7267eb118284da6c4b7.jpg@1100w_484h_1c_100q.jpg"/&gt; &lt;/div&gt;`&#125;)$container.html(str)// 获取每一个imgBox$imgBoxs = $container.children('.imgBox')console.log($imgBoxs);/** * 懒加载 * 计算视口（当前显示的位置）底部 &gt;= 该图片底部到顶部的距离 */const handleDeladyLoad = () =&gt; &#123; // 获取视口底部到顶部的距离 let viewPortTop = $window.outerHeight() + $window.scrollTop() $imgBoxs.each((index, item) =&gt; &#123; let $item = $(item); let $img = $item.children('img') let isLoad = $item.attr('isLoad') // 获取图片到顶部的距离 let imgTop = $item.outerHeight() + $item.offset().top // 是否需要加载出图片 if (imgTop &lt;= viewPortTop &amp;&amp; isLoad !== 'true') &#123; // 标记加载完成 $item.attr('isLoad', true) // 设置图片src字段，并加载图片 $img.attr('src', $img.attr('data-img')) $img.on('load', () =&gt; $img.fadeIn()) &#125; &#125;)&#125;// 挂载加载完成，和滚动事件$window.on('load scroll', handleDeladyLoad) 数组扁平化ES6方法flat1arr.flat(Infinity) 使用ES6的set进行存储1Array.from(new Set(arr)) 使用toString，再分割1arr.toString().split(',').map(item =&gt; Number(item)) 使用stringify去除[,]1JSON.stringify(arr).replace(/(\[|\])/g, '').split(',').map(item =&gt; Number(item)) 手动扁平化检测元素中是否含有数组，有则继续展下去 concat是将传入的参数，合并到数组中去，比如concat(1, [2, 3], [4, [5], 6]) 1, 直接放入 [x, 1] [2,3]， 直接合并 [x, 2, 3] [4, [5], 6], 合并每一项 [x, 4, [5], 6] 1234while(arr.some(item =&gt; Array.isArray(item))) &#123; // 将该数组每一项拆开合并进去 arr = [].concat(...arr)&#125; 手动递归实现方法一123456789101112131415161718function myFlat (arr) &#123; let result = [] // 循环每一项，不是数组的存储起来 const put = arr =&gt; &#123; for (let i = 0, item; item = arr[i++]; ) &#123; if (Array.isArray(item)) &#123; put(item) continue &#125; result.push(item) &#125; &#125; put(arr) return result&#125; 实现方法二123456789101112131415function myFlat (arr) &#123; let result = [] for (let i = 0, item; item = arr[i++];) &#123; if (Array.isArray(item)) &#123; // 当前每一项是否是数组 // result = [...result, ...myFlat(item)] result = result.concat(myFlat(item)) &#125; else &#123; // 如果是数据，直接push result.push(item) &#125; &#125; return result&#125; 英文字母组成字符串前后添加空格正则匹配，\b表示单词边界，不仅是一个空格 123let str = '这里是HDU，你好HDUer未来一起努力'let reg = /\b[a-z]+\b/igstr = str.replace(reg, value =&gt; ` $&#123;value&#125; `).trim() 自定义的$attr,要求可以进行获取标签中的任何元素任意位置获取所有的标签，document.getElementByTagName(&#39;*&#39;) 正则中，无论是字符串还是模板字符串，\都要注意转义符的存在，比如/\b/, regExp正则中new RegExp(\b)需求123456789&lt;div class='box aa' /&gt;&lt;div data-count='666' /&gt;&lt;div class='box clearfix' /&gt;&lt;div data-count='123' data-type='QQ' /&gt;&lt;div data-type='QQ' /&gt;&lt;div class='clearfix' /&gt;$attr('data-count', '123') -&gt; [&lt;div data-count='123' data-type='QQ' /&gt;]$attr('class', 'box') -&gt; [&lt;div class='box aa' /&gt;, &lt;div class='box clearfix' /&gt;] 实现，主要是要注意其特殊性，class属性可多选12345678910111213141516171819202122232425function $attr (property, value) &#123; // 获取页面所有的元素 let elements = document.getElementsByTagName('*') const arr = [] // 转换为数组形式 elements = Array.from(elements) // 依此寻找 elements.forEach(item =&gt; &#123; let itemPropertyValue = item.getAttribute(property) // 特殊处理class, 正则匹配内部元素 if (property === 'class') &#123; const reg = new RegExp(`\\b$&#123;value&#125;\\b`) if (reg.test(itemPropertyValue)) &#123; arr.push(item) &#125; // 处理其他值，直接判断是否相同 &#125; else &#123; if (itemPropertyValue === value) &#123; arr.push(item) &#125; &#125; &#125;) return arr&#125; 实现一个内置的new方法 创建原型对象 调用构造函数 返回构造函数 12345678910function myNew (Fn, ...args) &#123; // 手动创建字面量对象， 并进行挂载 // const obj = &#123;&#125; // Object.setPrototypeOf(Fn.prototype) // Object.create以某个原型挂载一个对象 const obj = Object.create(Fn.prototype) Fn.call(obj, ...args) return obj&#125;]]></content>
      <tags>
        <tag>恰饭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结题1]]></title>
    <url>%2F2019%2F12%2F26%2F%E6%80%BB%E7%BB%93%E9%A2%981%2F</url>
    <content type="text"><![CDATA[call 与 apply 的区别, 性能相关call, apply均为function原型上的方法，他们的作用都是改变this指向，唯一不同的就是传递参数的方式 fn.call(obj, 10, 20, 30)fn.apply(obj, [10, 20, 30]) call的性能要比apply好一些(尤其是传递给函数的参数超过3个的时候)，推荐call 基于es6对象展开符，可以使用call代替apply fn.apply(obj, arr)fn.call(obj, …arr) 性能：测试网站，一定要注明环境，个人测试只能作为参考 性能测试console.time(‘A’)// …codeconsole.timeEnd(‘A’) 实例调取方法，链式调用，(5).add(3).minus(2)原型上的写法，原型链拓展数字要加括号才可以进行拓展 箭头函数 箭头函数很简洁 箭头函数，没有this指向，使用call等也无法改变其this的指向 箭头函数没有arguments，可以使用申明式args let fn = (...args) =&gt; {} new的过程创建一个空对象，把原型挂上来，(构造器内)之后进行相关this赋值，返回该this 12345678function Obj1 () &#123; return 123 &#125;// new Obj1 =&gt; obj1实例function Obj3 () &#123; &#125;// new Obj3 =&gt; obj3实例function Obj2 () &#123; return &#123;name: 'z'&#125; &#125;// new Obj2 =&gt; &#123; name: 'z' &#125; 不适合箭头函数没有this指向,但是情境下又需要有this指向的功能,需要使用到this时才有问题 字面量对象内部 12345const obj = &#123; sum1: function () &#123;&#125;, // OK sum2 () &#123;&#125;, // OK sum3: () =&gt; &#123; &#125;, // ERROR&#125; 原型上的方法 回调函数，使用到this的 1button.addEventListener('click', function () &#123; this.focus() &#125; ) 构造函数 重新replace([REG], [CALLBACK])123456789101112131415String.prototype.myReplace = function (reg, callback) &#123; let destStr = this // 首次检验是否匹配 let regResult = reg.exec(this) while(regResult) &#123; // 得到匹配结果，并进行回调，并用返回值修改原str let replaceStr = callback.call(destStr, regResult) destStr = destStr.replace(regResult[0], replaceStr) // 进行下一次匹配 regResult = reg.exec(destStr) &#125; return destStr&#125; 内部迭代1234567const each = (arr, callback) =&gt; &#123; for (let i = 0, item; item = arr[i++]; ) &#123; let flag = callback.call(arr, item, i, arr) if (flag === false) &#123; break; &#125; &#125;&#125; indexOf,正则匹配去进行查找字符串1234567String.prototype.myIndexOf = function (reg) &#123; const reg = new RegExp(reg) const res = reg.exec(this) // 如果没有匹配到则返回-1 否则直接调用正则匹配结果的res.index,即首次出现的位置 return res === null ? -1 : res.index&#125; 关于对象中key，键的相关对象的键默认都是一个字符串12345const obj = &#123;&#125;, a = '123', b = 123obj[a] = 'a'; obj[b] = 'b'; // 最终obj[a] = 'b' 因为obj[123] = obj['123'] 对象中key使用一个symbol来创建12345const obj = &#123;&#125;, a = Symbol(123), b = Symbol(123);obj[a] = 'a'; obj[b] = 'b';// 最终obj[a] = 'a' 因为Smbol(123) !== Smbol(123) Symbol.for() 会在Symbol池中寻找或创建放入symbol池 Symbol(123) !== Symbol(123) Symbol.for(123) === Symbol.for(123) 对象中key使用一个应用值来创建123456const obj = &#123;&#125;arr = [12,34]; obj[arr] = 'arr';// &#123;12,34: 'arr' &#125;o1 = &#123; name: 'z' &#125;; obj[o1] = 'o1';// &#123;[object Object]: 'o1' &#125; 会调用对象的toString方法来当成key值传递进去。 判断对象构造器的方式 typeof， typeof &#39;str&#39; 只能判断，boolean, number, string, undefined, function, object(null + object + array) Object.prototype.toString.call(obj) 能够针对与object对象进行更细致一层的判 [object Undefined] [object Number] [object Date] [object Array] [object String]… [object Xxx] 只能进行原型判断了， Object.getPrototypeOf(obj) === Person.prototype 直接比较是否时原型对象（注意__proto__非标准，es推荐使用Object.getPrototypeOf(obj)来获取） 正则匹配网址 ?: 不进行分组 ? 可有可无，所以内部需要的只需要+即可 \w 数字，字母，下划线 开头结尾 1/^(?:(http|https|ftp):\/\/)?((?:[\w-]+\.)+[a-z0-9]+)((?:\/[^\/#?]*)+)?(\?[^#]+)?(#.+)?$/i 匹配协议1/(?:(http|https|ftp):\/\/)?/i 匹配域名匹配www. baidu. 12306.后匹配 xxx 1/((?:[\w-]+\.)+[a-z0-9]+)/i 匹配地址/xxx.html /xxx 1/((?:\/[^\/#?]*)+)?/i 匹配查询参数?a=b 1/(\?[^#]+)?/i 匹配hash#sda任意 1/(#.+)?/i]]></content>
      <tags>
        <tag>恰饭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在typescript中使用eslint]]></title>
    <url>%2F2019%2F12%2F18%2F%E5%9C%A8typescript%E4%B8%AD%E4%BD%BF%E7%94%A8eslint%2F</url>
    <content type="text"><![CDATA[基于vscode进行配置开发 改变tslint之前有使用tslint来对代码质量进行保障，由于tslint是eslint的一个子集,并且鉴于eslint的发达生态，所以使用eslint来代替tslint是比较好的一个选择，并且tslint团队也建议转移使用eslint。 项目中使用eslint这里直接使用umi出品的fabric来进行校验即可，并且其中也包含了其他配置，可根据自己的需要来进行使用，主要就是一些规则的优化。 删除项目中的eslint相关，与tslint相关使用fabric中的eslint项目根目录中的.eslintrc.js12const fabric = require(&apos;@umijs/fabric&apos;);module.exports = fabric.eslint; 自己定义规则由于fabric中也是eslint配置的规则，则可以应用解构赋值的方式进行规则的拓展 项目根目录中的.eslintrc.js1234567module.exports = &#123; extends: [require.resolve('@umijs/fabric/dist/eslint')], rules: &#123; // your rules &#125;,&#125; 在vscode中配置eslint环境 安装插件eslint 在配置文件中添加对ts的相关支持，使得可以自行进行依赖配置。 vscode并不会自动lint ts的相关文件，在settings.json中添加123456&quot;eslint.validate&quot;: [ &quot;javascript&quot;, &quot;javascriptreact&quot;, &quot;typescript&quot;, &quot;typescriptreact&quot; ],]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker构建gitlab]]></title>
    <url>%2F2019%2F11%2F24%2F%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2gitlab%2F</url>
    <content type="text"><![CDATA[gitlab功能比较庞大，所占用资源也很多，建议放在资源好一点的服务器，虚拟机运行4GB+,遇到问题可直接看最后面，可能会有所帮助 特性 使用docker-compose构建 使用docker的方式进行构建，基于gitlab-ce社区版搭建（可根据需要获取ee版） 使用nginx做一层反向代理，最终通过一个二级域名的方式可直达gitlab 最终的目的是使用二级域名，直接映射过去 123456789101112131415# 本地资源192.168.204.138 -&gt; 服务器二级域名 gitlab.vm.com -&gt; 192.168.204.138 (此处是本机做了个hosts)# 映射关系服务器中:7080 -&gt; gitlab-docker:80服务器中:7443 -&gt; gitlab-docker:443 (后面没有使用)服务器中:7022 -&gt; gitlab-docker:22 (用于ssh连方式)# 访问关系192.168.204.138:7080 -&gt; gitlab-dockergitlab.vm.com:7080 -&gt; gitlab-docker# 最终使用nginx做一层反向代理gitlab.vm.com -&gt; gitlab-docker 安装docker123456789101112curl https://get.docker.com/ &gt; install-docker.sh # 下载安装脚本sh install-docker.sh # 执行安装脚本# 修改docker阿里yum源vim /etc/docker/daemon.json# daemon.json&#123; "registry-mirrors": ["https://brnzp166.mirror.aliyuncs.com"]&#125; 设置开机自启动systemctl enable docker 安装docker-compose(基于国内镜像)12345# 下载docker-composecurl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose# 赋予权限chmod +x /usr/local/bin/docker-compose 设置外部目录由于是docker镜像运行, 所以我们需要把gitlab的配置, 数据, 日志存到容器外面, 即将其挂载到宿主机。 123mkdir -p /home/software/gitlab/etcmkdir -p /home/software/gitlab/logsmkdir -p /home/software/gitlab/data 制作docker-compose.yml文件由于使用了docker-compose帮助我们部署，所以不需要进行拉取镜像等，他会自动帮我们执行 找一个目录存放docker-compose.yml文件，这里使用/home/software/gitlab目录 新建文件 123cd /home/software/gitlabvim docker-compose.yml 编辑docker-compose.yml文件内容,如有要求可自行修改对应目录 1234567891011121314151617181920212223242526272829303132333435# docker-compose.ymlgitlab: image: 'gitlab/gitlab-ce:latest' restart: unless-stopped hostname: 'gitlab.vm.com' # 最终暴露出去的host environment: GITLAB_OMNIBUS_CONFIG: | # 外部可以访问到gitlab的url external_url 'http://gitlab.vm.com' # ssh相关（注意可能会和ssh连接工具端口冲突） gitlab_rails['gitlab_ssh_host'] = 'gitlab.vm.com' gitlab_rails['gitlab_shell_ssh_port'] = 7022 # email相关 gitlab_rails['smtp_enable'] = true gitlab_rails['smtp_address'] = "smtp.163.com" # smtp服务器地址 gitlab_rails['smtp_port'] = 465 gitlab_rails['smtp_user_name'] = "123456@163.com" # 发送邮件的邮箱 gitlab_rails['smtp_password'] = "授权码" # 邮箱的授权码 gitlab_rails['smtp_domain'] = "smtp.163.com" gitlab_rails['smtp_authentication'] = "login" gitlab_rails['smtp_enable_starttls_auto'] = true gitlab_rails['smtp_tls'] = true gitlab_rails['gitlab_email_from'] = '123456@163.com' # 发送邮件的邮箱 ports: - '7080:80' - '7443:443' - '7022:22' volumes: - '/home/software/gitlab/etc:/etc/gitlab' - '/home/software/gitlab/logs:/var/log/gitlab' - '/home/software/gitlab/data:/var/opt/gitlab' 检测配置成功运行docekr切换到刚刚的docker-compose.yml文件存在的地址（此时是在/home/software/gitlab） 1234cd /home/software/gitlab# 后台运行dockerdocker-compose up -d 使用docker ps查看当前docker的运行状况，等待gitlab的状态为（healthy/unhealthy，约5分钟左右）,也即打包完毕后，访问192.168.204.138:7080，如果可以看到欢迎界面，恭喜你，搭建就成功了 以后直接切换去docker-compose.yml文件存在的地址,使用docker-compose up -d即可重启，并且上文设置了docker开机自启。 此时设置的密码为root账户，即以后用户名为root的账户，超级管理员 可点击头像框 settings -&gt; preferences -&gt; language 切换为中文 测试邮箱服务修改完成后，进入到另一个终端中，进入gitlab-docker内 12345678docker exec -it gitlab /bin/bash# 进入到该container中，执行重新配置，等待完成gitlab-ctl reconfigure# 测试邮箱是否完成gitlab-rails console # 进入邮件控制台, 稍等一会才能进入Notify.test_email('test_another@qq.com', 'Message Subject', 'Message Body').deliver_now 使用nginx反向代理 反向代理说通俗就是，你去访问192.168.204.138的时候，服务器趁你不知道安排了192.168.204.138：7080给你服务，此时是后台服务器，通过一个中间商，给你服务。 使用yum安装nginx1234567891011121314# 下载对应当前系统版本的nginx包(package)wget http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm # 建立nginx的yum仓库rpm -ivh nginx-release-centos-7-0.el7.ngx.noarch.rpm # 根据/etc/yum.repos.d/nginx.repo中的信息下载安装nginxyum install nginx # 启动nginx服务systemctl start nginx # 开机自启nginx服务systemctl enable nginx 配置反向代理使用此种方式安装的nginx，配置文件是较为分散的，可以使用whereis nginx查看 12345678910111213141516# 进入到nginx配置目录cd /etc/nginx/conf.d# 增加一个针对gitlab的proxy, 一定要为*.conf， 查看 /etc/nginx/nginx.conf 就懂了vim proxy_gitlab.conf# 我的反向代理，gitlab.vm.com:80 -&gt; http:127.0.0.1:7080# 即docker映射出的gitlab 目录server &#123; listen 80; server_name gitlab.vm.com; location / &#123; proxy_pass http://127.0.0.1:7080; &#125;&#125; 重启nginx服务systemctl restart nginx 访问即可http://gitlab.vm.com 可能出现的问题SELINUX(针对反向代理)linux安全模块，此处直接关闭（不推荐这种做法，可以去找selinux较好的解决方案） 123vim /etc/sysconfig/selinuxSELINUX=disabled firewalld由于防火墙的存在，可能造成浏览器一直转圈的状况 本地虚拟机，直接关闭（不推荐，可以去找firewalld较好的解决方案） 123systemctl stop firewalld # 关闭防火墙systemctl disable firewalld # 永久关闭（当然也不推荐啦） gitlab-docker无限重启可能是配置出了问题，之前配置extends_url出现这种状况，所以此时并未在进行过配置 可以切换进去(此处gitlab-docker的name就叫gitlab,也可以替换为&lt;containerID&gt;，docker ps -a即可查看)，查看哪里出了问题 1docker container logs gitlab nginx服务器启动异常nginx服务启动说权限的问题，此处可能是修改了SELINUX导致的问题，可以先将selinux切换回之前的模式，重启后，待nginx可正常启动后，重启在修改SELINUX即可 爆内存因为gitlab对设备的还是有一定要求的gitlab硬件要求 如果卡慢的话，可以试一试增加虚拟内存 12345678910111213# 4GB虚拟内存dd if=/dev/zero of=/home/swap bs=1024 count=4194304# 格式化分区mkswap /home/swap# 开启swap分区(关闭swap分区 swapoff /home/swap)swapon /home/swap# 挂载分区vim /etc/fstab/home/swap swap swap default 0 0 参考docker方式构建gitlab(官方文档) 云服务器增加swap分区]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简易实现Graph]]></title>
    <url>%2F2019%2F11%2F12%2Fjs%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0Graph%2F</url>
    <content type="text"><![CDATA[图结构更加贴近生活，能更多的模拟生活中的一些结构,表示一种网状，能更好的表示节点之间的联系与关系。 12345I - E -| B - A - C - | F -| | | | | - D - G | - - — H 图的种类有向图有方向的图，B-&gt;A, A-&gt;B,可以使用邻接矩阵来表示，但是使用邻接表的时候，分为邻接表，逆邻接表（根据入度出度）。 无向图没有方向的图，A-B，表示了A与B，和B与A的联系，可以使用邻接矩阵来表示，也可以使用邻接表来表示 存储形式邻接矩阵使用一个二维数组的形式来表示，很想坐标系，使用两个轴所对应的坐标寻找两个点之间的关系，当边不一样时，即存在了权时，采用邻接矩阵的方式也比较好表示，直接在相应的位置上即为他们的度即可。 当一个图较为稀疏时，可能会存在大量不必要存储的0，造成了空间的浪费 1234567891011121314151617// 比如存在一个图/** * A - B - c * \D/ * * A B C D * A 0 1 0 0 * B 1 0 1 1 * C 0 1 0 1 * D 0 1 1 0 */[ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0],] 邻接表将顶点(vertex),与边(Edge)分别进行记录的一种方式，每个定点的入度，出度分别可以组成逆邻接表，邻接表 在使用邻接表时，分别记录，可以使用[&#39;A&#39;, &#39;B&#39;]来记录定点信息，使用{ vertex: [ vertex1, vertex2 ] }来记录边的信息 遍历方式使用一种方式，将图内的所有节点都访问一遍的方式，注意以下两点 遍历的时候，必须给图一个初始的顶点 每个顶点分为3种状态，white(未访问),gray(正在访问状态中),black(访问结束),初始化时，所有的点都应该时white的,只将white放到即将要访问中，gray表示正在访问，会造成循环，black已经访问过了，会造成重复 bfs,breadth first search, 广度优先 每一个元素所有的节点都要访问完再去他们的子元素这样访问，采用一层一层的方式，可以使用队列的方式实现，将一层塞入队列中，这一层的子元素，再次塞入队列，就保证了对头是同层的 dfs,depth first search, 深度优先 每一个元素一旦访问后就要走到头，采用递归函数的方式实现，每一个点都是递归的访问，所以直到所有点都是访问过的，才会一层一层递归回来，也就是这一个点走完了 两种方式注意事项 处理white型节点，保证不循环应用，不重复应用等 在改变为gray时就要handler掉他，等他的子节点也都遍历完了之后，就可以black掉了。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/** * 图结构 * 采用邻接表的形式，无向图 */function Graph () &#123; // 表示存储的点 this.vertexes = [] // 表示存储的边 this.edge = &#123;&#125;&#125;/** * 添加一个点,点存在就不再添加了 */Graph.prototype.addVertex = function (v) &#123; if (this.edge.hasOwnProperty(v) === true ) &#123; return true &#125; // 添加节点，初始化边 this.vertexes.push(v) this.edge[v] = []&#125;/** * 添加一条边 */Graph.prototype.addEdge = function (v1, v2) &#123; // 当前是否存在该点 if (this.edge.hasOwnProperty(v1) === false) &#123; this.addVertex(v1) &#125; if (this.edge.hasOwnProperty(v2) === false) &#123; this.addVertex(v2) &#125; // 增加两条边的关系 this.edge[v1].push(v2) this.edge[v2].push(v1)&#125;/** * 输出邻接表的存在形式 */Graph.prototype.toString = function () &#123; let str = '' this.vertexes.forEach(vertex =&gt; &#123; str += `$&#123;vertex&#125; -&gt;` this.edge[vertex].forEach(otherVertex =&gt; str += ` $&#123;otherVertex&#125;`) str += '\n' &#125;) return str&#125;/** * 初始化所有颜色的方法 * W-white, G-gray, B-black */Graph.prototype.initializeColor = function () &#123; // 初始化所有点顺序的一个color const colors = &#123;&#125; this.vertexes.forEach((v) =&gt; colors[v] = 'W') return colors&#125;/** * DFS-&gt;广度优先 * 使用队列入队，出队实现 */Graph.prototype.bfs = function (initV, handler) &#123; // 获取所有点的颜色表 const colors = this.initializeColor() // 准备队列，并放入初始化点进行遍历 const queue = new Queue() queue.enqueue(initV) while (queue.isEmpty() === false) &#123; // 取出要遍历的节点 const currentVertex = queue.dequeue() const currentEdges = this.edge[currentVertex] // 处于遍历状态 colors[currentVertex] = 'G' // 依次放入每一个邻接表中的点 for (let i = 0, v; v = currentEdges[i++]; ) &#123; // 已经遍历或是访问了，就不在处理了 if (colors[v] !== 'W') &#123; continue &#125; // 放入该点，并且改变该点的颜色 queue.enqueue(v) colors[v] = 'B' &#125; // 处理该点 handler(currentVertex) &#125;&#125;/** * dfs-&gt;深度优先 * 采用递归的形式 */Graph.prototype.dfs = function (initV, handler) &#123; /** * 递归方法，置成灰色，然后遍历，处理，置成黑色 */ const dfsVisit = (currentVertex, colors, handler) =&gt; &#123; colors[currentVertex] = 'G' // 处理该点 handler(currentVertex) const currentEdges = this.edge[currentVertex] for (let i = 0, v; v = currentEdges[i++]; ) &#123; if (colors[v] !== 'W') &#123; continue &#125; dfsVisit(v, colors, handler) &#125; colors[currentVertex] = 'B' &#125; // 获取颜色 const colors = this.initializeColor() // 开启遍历 dfsVisit(initV, colors, handler)&#125;const graph = new Graph()graph.addVertex('A')graph.addVertex('B')graph.addVertex('C')graph.addVertex('D')graph.addVertex('E')graph.addVertex('F')graph.addVertex('G')graph.addVertex('H')graph.addVertex('I')graph.addEdge('A', 'B')graph.addEdge('A', 'C')graph.addEdge('A', 'D')graph.addEdge('C', 'D')graph.addEdge('C', 'G')graph.addEdge('D', 'G')graph.addEdge('D', 'H')graph.addEdge('B', 'E')graph.addEdge('B', 'F')graph.addEdge('E', 'I')console.log(graph.toString())const bfsList = []graph.bfs('A', v =&gt; bfsList.push(v))console.log('bfsList', bfsList)const dfsList = []graph.dfs('A', v =&gt; dfsList.push(v))console.log('dfsList', dfsList)]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现简易BinarySearchTree]]></title>
    <url>%2F2019%2F11%2F11%2Fjs%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93BinarySearchTree%2F</url>
    <content type="text"><![CDATA[二叉搜索树,二分查找法，他将数组的这种特性，应用到了数组上，主要是数组在频繁增删元素时，尤其是对于有顺序的元素，他会移动大量的元素，从而造成性能的下降，由此就有了利用链表的想法，但是又为了能有二分搜索法的特性，所以就以二分搜索法类似的顺序排列下来 左侧是小于父节点的数据，右侧是大于父节点的数据，也即二分的特性 注意点插入要按照特性查找到符合条件的位置，进行插入 删除涉及到替补的元素，可使用前驱，或者是后继来进行替换，但是这里要注意找到前驱/后继元素的时候，对其他的元素更改其挂载的父节点的位置，也就是自动变换位置。 失衡当插入数据时，会产生失衡现象，即一侧树特别长，另一侧很短，此时性能会急剧下降，BST也就变成了一个链表，解决方法有两种 AVL树（用的不多） 红黑树（比较普遍） 红黑树（解决失衡的方式）红黑树的原理就是讲每一个节点分为红/黑这两种形态的节点，更具一定的规律下，就尽可能的保证了此树是一颗尽可能平衡的数（可能会有看起来有点失衡，但并不违背规则，当在插入某一种叶子时，立马回调整回来） 左旋转 右旋转 其中，红黑树保证以下这五条原则，即可最大限度保证平衡 每个节点不是红色就是黑色 根节点总是黑色的 节点是红色的，那么他打的子节点一定是黑色的 每个叶子节点（NIL）必须是黑色（此处指null,‘不存在’的节点，只要有值，就不能算叶子节点），并且不能有两个连续的红色 从根节点到叶子节点或者空节点的距离，包含相同数目的黑色节点 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330function Node (key) &#123; this.key = key this.left = null this.right = null&#125;function BinarySearchTree () &#123; this.root = null&#125;/** * 插入元素 */BinarySearchTree.prototype.insert = function (key) &#123; const newNode = new Node(key) // 如果当前树空 if (!this.root) &#123; this.root = newNode return true &#125; // 寻找适合的位置插入 this.insertNode(this.root, newNode) return true&#125;/** * 内部插入结点 */BinarySearchTree.prototype.insertNode = function (root, newNode) &#123; /** * 判断当前的root所代表的值，和当前元素的key的情况 * 小于key,插入左侧：1.无左结点，直接替换，否则继续递归插入 * 大于key,插入右侧：1.无右结点，直接替换，否则继续递归插入 */ if (newNode.key &lt; root.key) &#123; if (root.left === null) &#123; root.left = newNode &#125; else &#123; this.insertNode(root.left, newNode) &#125; return true &#125; if (newNode.key &gt; root.key) &#123; if (root.right === null) &#123; root.right = newNode &#125; else &#123; this.insertNode(root.right, newNode) &#125; return true &#125; if (newNode.key === root.key) &#123; return false &#125;&#125;/** * 先序遍历 * preOrderTraversal */BinarySearchTree.prototype.preOrderTraversal = function (handle) &#123; /** * 先序遍历节点 */ const preOrderTraversalNode = function (root, handle) &#123; if (root !== null) &#123; // 先序处理 handle(root.key) preOrderTraversalNode(root.left, handle) preOrderTraversalNode(root.right, handle) &#125; &#125; /** * 从根节点开始遍历 */ preOrderTraversalNode(this.root, handle)&#125;/** * 中序遍历 * midOrderTraversal */BinarySearchTree.prototype.midOrderTraversal = function (handle) &#123; /** * 中序遍历节点 */ const midOrderTraversalNode = function (root, handle) &#123; if (root !== null) &#123; midOrderTraversalNode(root.left, handle) // 中序处理 handle(root.key) midOrderTraversalNode(root.right, handle) &#125; &#125; midOrderTraversalNode(this.root, handle)&#125;/** * 后序遍历 * postOrderTraversal */BinarySearchTree.prototype.postOrderTraversal = function (handle) &#123; /** * 后序遍历节点 */ const postOrderTraversalNode = function (root, handle) &#123; if (root !== null) &#123; postOrderTraversalNode(root.left, handle) postOrderTraversalNode(root.right, handle) // 后序处理 handle(root.key) &#125; &#125; postOrderTraversalNode(this.root, handle)&#125;/** * 寻找最大值 * 遍历到最右侧 */BinarySearchTree.prototype.max = function () &#123; let node = this.root let key = null while (node !== null) &#123; key = node.key node = node.right &#125; return key&#125;/** * 寻找最小值 * 遍历到最左侧 */BinarySearchTree.prototype.min = function () &#123; let node = this.root let key = null while (node !== null) &#123; key = node.key node = node.left &#125; return key&#125;/** * 寻找到特定的值 * 由于这里省略了data数据，真实情况返回需要数据即可 */BinarySearchTree.prototype.search = function (key) &#123; if (this.root === null) &#123; return null &#125; let node = this.root while (node !== null) &#123; if (key &lt; node.key) &#123; // 小于根，在左侧树内 node = node.left &#125; else if (key &gt; node.key) &#123; // 大于根，在右侧树内 node = node.right &#125; else &#123; // 等于根，寻找到该元素 return node.key &#125; &#125; /** * 找到叶子节点并未找到，说明不存在 */ return null&#125;BinarySearchTree.prototype.delete = function (key) &#123; // 保存删除节点的条件 let current = this.root let parent = null let childrenDirection = 'left' /** * 循环，找到要删除的元素 */ while (current.key !== key) &#123; parent = current if (key &lt; current.key) &#123; childrenDirection = 'left' current = current.left &#125; else &#123; childrenDirection = 'right' current = current.right &#125; // 如果找到叶子节点还没有，则退出 if (current === null) &#123; return false &#125; &#125; // 此时current为要删除的元素 /** * current为一个叶子节点 */ if (current.left === null &amp;&amp; current.right === null) &#123; // 当前删除的是根节点 if (current === this.root) &#123; this.root = null return true &#125; // 删除此叶子节点 parent[childrenDirection] = null return true &#125; /** * current为一个单孩子节点,只有一个节点存在 */ if (current.left === null || current.right === null) &#123; // 当前删除的是根节点 if (current === this.root) &#123; this.root = current.left ? current.left : current.right return true &#125; // 删除单孩子的父节点 parent[childrenDirection] = current.left ? current.left : current.right &#125; /** * 获取一个节点的后继节点，并挂载相关节点 */ const getSucceedNode = function (deleteNode) &#123; let parent = null let current = deleteNode.right while (current.left !== null) &#123; parent = current current = current.left &#125; /** * 此时current是要删除的后继 * 1.没有parent,不需要处理其他节点，deleteNode.right * 2.有parent,需要处理其他节点，deleteNode.right.left.left.left */ if (parent !== null) &#123; parent.left = current.right current.right = parent &#125; current.left = deleteNode.left return current &#125; /** * current做一个双孩子节点，此处统一使用后继去代理 */ let succeedNode = getSucceedNode(current) if (current === this.root) &#123; this.root = succeedNode return true &#125; parent[childrenDirection] = succeedNode return true&#125;const bst = new BinarySearchTree()bst.insert(10)bst.insert(5)bst.insert(15)bst.insert(3)bst.insert(7)bst.insert(12)console.log(bst)const preOrderTraversalList = []bst.preOrderTraversal(key =&gt; preOrderTraversalList.push(key))console.log(preOrderTraversalList)const midOrderTraversalList = []bst.midOrderTraversal(key =&gt; midOrderTraversalList.push(key))console.log(midOrderTraversalList)const postOrderTraversalList = []bst.postOrderTraversal(key =&gt; postOrderTraversalList.push(key))console.log(postOrderTraversalList)console.log('max', bst.max())console.log('min', bst.min())console.log(bst.search(10))console.log(bst.search(12))console.log(bst.search(11))bst.delete(5)const result = []bst.preOrderTraversal(key =&gt; result.push(key))console.log(result)]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现简易HashTable]]></title>
    <url>%2F2019%2F11%2F07%2Fjs%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93HashTable%2F</url>
    <content type="text"><![CDATA[哈希表，既想应用数组取数据的方便，但是有想避免在操作数组的时候，由于按照顺序，所以导致数组内会频繁的增加，删除元素，所以数组内的数据会频繁的变换原有的位置，诸多的不同，所以诞生出了hashTable这种数据结构 其本身就是一个数组，只不过这个数组不在使用原有的下标值来标识元素，而是采用每一个数据的key,通过一个hash函数来转换为下标值，对外界来说，就是使用key来将数据存储在数组中 Hash函数(生成编码 + 压缩,哈希化)hash函数就是将所对应的key,转换为所对应的相对唯一的一个函数值，其通常采用的是如下的方式进行转换 采用质数在数论中的研究发现，使用质数会有很好的唯一性，等其他的特性 霍纳法则（秦九韶算法） 与我国古代，就有了秦九韶算法，基本思路与霍纳法则一致 也就是多项式的分解。普通多项式，O(n^2)乘法，O(n)加法，改进后O(n)乘法，O(n)加法。 使用同一编码格式在javascript中，使用unicode,即charCodeAt() 压缩，哈希化通常生成的数组下标，可能几十万，上百万，但是数组并未有那么多元素，所以适当压缩即可。（虽然还是有可能压缩，但是相同的概率大大变小） 12345678910111213141516// 大部分采用37这个质数/** * str e.g * s -&gt; 115 * t -&gt; 116 * r -&gt; 114 */const code = 114 * 37^2 + 116 * 37^1 + 114 * 37^0 code = ((114 * 37) + 116) * 37 + 114// 采用压缩化// 使用容量取模操作即可const hashIndex = code &amp; size 解决冲突在进行hash函数的时候，尽可能的保证每一个key所对应的hash值是唯一的，但是还是会有冲突的情况，这里主要有两种解决方式 链地址法hashTable中每一个位置不存储具体的数值，而是采用一个数组/链表，依次放入数据，当有冲突发生时紧跟在后面即可，这样的方式对于解决冲突是比较简单的，对于发生冲突时，数据压入位置也是有讲究的 压入头部，建议采用链表，比如最新压入的数据是变化最频繁的， 压入尾部，建议采用数组/链表,比如微信新增的好友联系是比较少的，相对于老朋友。 开放地址法 线性探测 二次探测 再哈希法 也即发生冲突的时候，采用适当的原则寻找下一个位置，但是这种方式可能会造成聚集的现象，比如线性探测法，对于一组连续的数据，冲突放下一位等，这样一来就可能会有一段空间是集中存在数据的，这对哈希表性能是会有一定程度的影响。 在查找数据的时候，要按照放数据的方式，再次查找直到找到null为止，并且当有数据删除的时候，不能置为null,这会对后面的数据产生影响，应该用其他标志来表示。 承载因子（loaderFactor）表示当前的元素所占的位置，count / limit，链地址法可超过1，因为实际的限制并没有盛放元素。对于开放地址法，0 &gt; loadeFactor &gt; 1,因为他实际承载的元素都是放在容器中的 loaderFactory &lt; 0.25，要进行缩容操作，此时元素过少，也会影响性能。 0.75 &lt; loaderFactory，要进行扩容操作，此时元素过多，也会影响性能。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212/** * hash表结构 * 此处采用链地址法来进行查找 */function HashTable () &#123; this.storage = [] this.count = 0 this.limit = 7&#125;/** * 获取该key在hashTable中的数组下标 */HashTable.prototype.hashIndex = function (key) &#123; let hashCode = 0 for (let i = 0; i &lt; key.length; i += 1) &#123; hashCode += 37 * hashCode + key.charCodeAt(i) &#125; const hashIndex = hashCode % this.limit return hashIndex&#125;/** * 通过key，将data数据放入hashTable中 * 如果key相同，则会覆盖数据 */HashTable.prototype.put = function (key, data) &#123; // 1.获取在hashTable中的数组下标 const hashIndex = this.hashIndex(key) // 2.获取bucket，获取链 let bucket = this.storage[hashIndex] // 3.初始化操作 if (!bucket) &#123; bucket = [] this.storage[hashIndex] = bucket &#125; let isUpdate = false // 4.判断是否是修改操作 for (let i = 0; i &lt; bucket.length; i += 1) &#123; const tuple = bucket[i] if (tuple[0] === key) &#123; tuple[1] = data isUpdate = true break &#125; &#125; // 此时是新增操作 if (isUpdate === false) &#123; bucket.push([key, data]) &#125; this.count += 1 // 扩容 if (this.count &gt; this.limit * 0.75) &#123; // 找到扩大2倍后，最近的一个质数 const nextLimit = this.nextPrime(this.limit * 2) this.resize(nextLimit) &#125; return true&#125;/** * 获得某个数据 */HashTable.prototype.get = function (key) &#123; // 1.获取在hashTable中的数组下标 const hashIndex = this.hashIndex(key) // 2.获取bucket，获取链 let bucket = this.storage[hashIndex] if (!bucket) &#123; return null &#125; // 返回该数据 for (let i = 0; i &lt; bucket.length; i += 1) &#123; const tuple = bucket[i] if (tuple[0] === key) &#123; return tuple[1] &#125; &#125; // 未找到数据 return null&#125;/** * 删除某个元素 * 返回删除的元素 */HashTable.prototype.delete = function (key) &#123; // 1.获取在hashTable中的数组下标 const hashIndex = this.hashIndex(key) // 2.获取bucket，获取链 let bucket = this.storage[hashIndex] if (!bucket) &#123; return null &#125; let deleteElement = null for (let i = 0; i &lt; bucket.length; i += 1) &#123; const tuple = bucket[i] if (tuple[0] === key) &#123; // 删除元素 bucket.splice(i, 1) deleteElement = tuple[1] break &#125; &#125; if (!deleteElement) &#123; return null &#125; this.count -= 1 // 缩容,最少容量为7 if (this.count &lt; this.limit * 0.25) &#123; // 找到缩小2倍后，最近的一个质数,并且不能小于7的容量 let nextLimit = this.nextPrime(Math.floor( this.limit / 2)) nextLimit = nextLimit &lt;= 7 ? 7 : nextLimit this.resize(nextLimit) &#125; return deleteElement&#125;/** * 改变容量操作 */HashTable.prototype.resize = function (size) &#123; const oldStorage = this.storage this.storage = [] this.count = 0 this.limit = size // 遍历oldStorage中每一bucket,并依次添加过去 for (let i = 0; i &lt; oldStorage.length; i++) &#123; const bucket = oldStorage[i] if (!bucket) &#123; continue &#125; // 依次存入 bucket.forEach(([key, data]) =&gt; &#123; this.put(key, data) &#125;) &#125;&#125;/** * 工具方法，判断是否为一个质数 */HashTable.prototype.isPrime = function (num) &#123; const sqrtNum = Math.floor(Math.sqrt(num)) for (let i = 2; i &lt;= sqrtNum; i += 1) &#123; if (num % i === 0) &#123; return false &#125; &#125; return true&#125;/** * 获得最为相近的质数，为向后查找 */HashTable.prototype.nextPrime = function (num) &#123; while (!this.isPrime(num)) &#123; num += 1 &#125; return num&#125;const hashTable = new HashTable()hashTable.put('key1', 'value1')hashTable.put('key2', 'value2')hashTable.put('key1', 'value11')hashTable.put('key3', 'value3')console.log(hashTable.get('key1'))console.log(hashTable.get('key2'))console.log(hashTable.get('key3'))hashTable.delete('key3')console.log(hashTable.get('key3'))]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise简单实现]]></title>
    <url>%2F2019%2F11%2F04%2FPromise%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Promise/A+规范是Promise实现的准则，这里只是准备了最基本的相关功能 简易版异步实现我们需要在Promise内部定义我们要操纵的异步方法，并且在then中给他注册回调，也就是当我们使用resolve的时候，他才会执行回调 1234567891011121314151617181920212223function MyPromise (fn) &#123; this.value = null this.error = null this.onFulfilled = null this.onRejected = null function resolve (value) &#123; this.value = value this.onFulfilled(this.value) &#125; function reject (error) &#123; this.error = error this.onRejected(this.error) &#125; fn(resolve, reject)&#125;MyPromise.prototype.then = (onFulfilled, onRejected) =&gt; &#123; this.onFulfilled = onFulfilled this.onRejected = onRejected&#125; 使用123456new MyPromise((resolve) =&gt; &#123; // fetch resolve(data)&#125;).then(res =&gt; &#123; console.log(res)&#125;) 当then注册完回调之后，等待resolve函数执行后，会自动触发回调 存在的问题 当执行同步任务的时候，由于异步任务还没有被注册，从而导致了异步回调尚未注册，就执行了（面临报错等） 当多个Promise链式调用的时候,then里注册的都是第一个Promise,但是我们实际想要的做法却是，每一个Promise注册一个then12345p1 p2 p3 p1.then(f1).then(f2).then(f3)// 本意，f1做p1的回调注册，f2做p2的回调注册，f3做p3的回调注册// 但是由于链式调用返回的是自身，所以无法进行链式调用 jQuery中，链式调用值得是返回他自身，因为jQuery作为一个工具，返回自身并没有问题，但是Promise对象，每一个状态都应该是一个独立的，所以链式调用时，不能返回自身，应该返回对应的产生新的Promise 固化实例，Promise的状态一旦改变，并不能再次发生改变123456789let myPromise = new Promise((resolve, reject) =&gt; &#123; // fetch /** * 只有resolve会执行，因为状态被固化了 */ resolve() reject()&#125;) 基本版的实现 这里将所有的代码写在此处,处于简洁的目的,并不是很健壮,只是将最基本的逻辑列了出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** * 固化状态 */const PENDING = 'pending'const FULFILLED = 'fulfilled'const REJECTED = 'rejected'/** * 用来传递解析Promise的方法 * （此方法要最后再看） */const resolvePromise = (proxyPromise, x, resolve, reject) =&gt; &#123; if (x instanceof MyPromise) &#123; /** * 如果当前x是一个Promise对象，则直接绑定回调，待这个Promise执行完毕后， * 自己resole掉，这里的resolve,就是proxyPromise的resolve * 再调用proxyPromise，也就是让新生成的Promise继续走下去 */ x.then(resolve, reject) &#125; else &#123; /** * 如果当前x是一个普通的值，就说明上一个Promise只是返回一个同步结果 * 那么我们刚刚包裹的那层Promise其实就是多余的（只是通用性，我们都包裹方便） * 立马放行即可 */ resovle(x) &#125;&#125;function MyPromise (fn) &#123; let self = this self.value = null self.error = null self.status = PENDING /** * 由于我们只会使用上一个的Promise的状态，但是其回调函数又是再then中创建的那个Promise调用的， * 所以此处仅仅什么也没有，后文使用之处也仅仅都是用到self.value, self.error而已，至于回调函数 * 都会绑定到下一个Promise上 */ self.onFulfilled = value =&gt; value self.onRejected = error =&gt; &#123; throw error &#125; function resolve (value) &#123; // 固化性，只有PENDING状态才能执行 if (self.status === PENDING) &#123; self.value = value self.status = FULFILLED self.onFulfilled(self.value) &#125; &#125; function reject (error) &#123; // 固化性，只有PENDING状态才能执行 if (self.status === PENDING) &#123; self.error = error self.status = REJECTED self.onRejected(self.error) &#125; &#125; // 执行Promise函数体 fn(resolve, reject)&#125;MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; const self = this let proxyPromise onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value onRejected = typeof onRejected === 'function' ? onRejected : error =&gt; &#123; throw error &#125; // 只有再PENDING状态下才能绑定回调 if (self.status === PENDING) &#123; proxyPromise = new MyPromise((resolve, reject) =&gt; &#123; self.onFulfilled = (value) =&gt; &#123; try &#123; /** * 绑定上一个onFulfilled回调函数为then中传递的回调函数 */ let x = onFulfilled(value) /** * 将当前的返回值和此处then中生成的proxyPromise做联系 * 也即确定什么时候可以让这个proxyPromise继续下去 */ resolvePromise(proxyPromise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125; self.onRejected = (error) =&gt; &#123; try &#123; let x = onRejected(error) resolvePromise(proxyPromise, x, resovle, reject) &#125; catch (error) &#123; reject(error) &#125; &#125; &#125;) &#125; else if (self.status === FULFILLED) &#123; // 此时状态已经变为执行完毕了，直接执行这里的then，只不过需要使用原本存在的value值 proxyPromise = new MyPromise((resolve, reject) =&gt; &#123; try &#123; let x = onFulfilled(self.value) resolvePromise(proxyPromise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; else if (self.status === REJECTED) &#123; // 此时状态已经变为被拒绝了，直接执行这里的then，只不过需要使用原本存在的error值 proxyPromise = new MyPromise((resolve, reject) =&gt; &#123; try &#123; let x = onRejected(self.error) resolvePromise(proxyPromise, x, resolve, reject) &#125; catch (error) &#123; rejected(error) &#125; &#125;) &#125; /** * 每次then结束，都会返回也给全新的Promise,并且给下一个then做为回调函数注册的对象 * * p1 p2 p3 * promise.then(f1).then(f2) * 这里生成的p2其实是自动为p3做服务，也就是达到了一种虚假的链式调用效果，我后面一个then调用前一个的结果 */ return proxyPromise&#125;/** * catch方法其实是一个语法糖，之前onRejected方法默认都写为了 error =&gt; &#123; throw error &#125; * 有因为then中生成的代理proxyPromise的reject方法都是再try-catch中执行的，生成的错会被层层抛出， * 直到最后一层 */MyPromise.prototype.catch = function (onRejected) &#123; this.then(null, onRejected)&#125; 使用12345678910111213141516171819202122232425262728293031323334353637const p = new MyPromise(resolve =&gt; &#123; // fetch const data1 = fetchData1() resolve(data1)&#125;)const f1 = (data) =&gt; &#123; // 处理data return new MyPromise(resolve =&gt; &#123; // fetch const data2 = fetchData2() resolve(data2) &#125;)&#125;const f3 = (data) =&gt; &#123; // 处理data return new MyPromise(resolve =&gt; &#123; // fetch const data3 = fetchData3() resolve(data3) &#125;)&#125;/** * 只要有一个错误就会被抛到最后 */const handleError = (error) =&gt; &#123; console.log(error)&#125;p.then(f1).then(f2).then(f3).catch(handleError) 注意点 要达到使用的链式调用效果，就要每一次then中都应该返回一个新的Promise.这样下一个then才会注册到他 为了保证所有异步，同步方法都能执行下去，统一进行处理，如果值为promise，则给他注册then,也就是等他这个返回的promise执行完毕后，能够自动触发此处的proxyPromise执行下去，如果发现是一个普通对象，直接resolve掉即可。 关于健壮性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 返回一个新的promise,数组遍历，记录执行完的数量，等到所有都执行完毕后，才能resolve大的 */MyPromise.prototype.all = function (promises) &#123; return new MyPromise((resolve, reject) =&gt; &#123; let count = 0 const result = [] for (let i = 0; i &lt; promises.length; i += 1) &#123; promises[i].then((data) =&gt; &#123; result[i] = data if (++count === promises.length) &#123; resolve(result) &#125; &#125;, (error) =&gt; &#123; reject(error) &#125;) &#125; &#125;)&#125;/** * 返回一个新的promise,数组遍历，只有任意一个promise执行完毕就可以resovle */MyPromise.prototype.race = function (promises) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i += 1) &#123; promises[i].then((data) =&gt; &#123; resolve(data) &#125;, (error) =&gt; &#123; rejected(error) &#125;) &#125; &#125;)&#125;/** * 返回一个立即resovle */MyPromise.prototype.resolve = function (value) &#123; return new MyPromise((resolve, reject) =&gt; &#123; resovle(value) &#125;)&#125;/** * 返回一个立即reject */MyPromise.prototype.reject = function (error) &#123; return new MyPromise((resolve, reject) =&gt; &#123; reject(error) &#125;)&#125;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React错误边界]]></title>
    <url>%2F2019%2F11%2F01%2FReact%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C%2F</url>
    <content type="text"><![CDATA[在development环境下，会追踪上下文错误执行栈，也即在producetion中，可以看到效果 getDerivedStateFromError将当前渲染组件捕获error时，执行此方法，并且返回结果导入到state 1234567891011state = &#123; hasError: false &#125;static getDerivedStateFromError (error) &#123; return &#123; hasError: true &#125;&#125;render () &#123; if (this.state.hasError) return &lt;h1&gt;Some Thing wrong&lt;/h1&gt; return this.props.children&#125; 其实就是在render中使用了一个判断，而这个判断的改变是在获取到错误时触发 componentDidCatch当前的组件捕获到错误的时候，会执行此生命周期函数 1234componentDidCatch (error, info) &#123; // 上报错误信息 logErrorToService(error)&#125; 使用try-catch该错误边际仅仅处理由渲染引发的问题，也即被ErrorBoundary包裹的部分，事件处理器中还是要使用tryCatch 123456789101112131415// 这种情况发生的错误是无法被错误边际捕获的handleToggleError = () =&gt; &#123; throw new Error('error')&#125;// 事件处理中还是要使用try-catch自行处理handelToggleError = () =&gt; &#123; try &#123; throw new Error('error') &#125; catch (error) &#123; &#125;&#125;&lt;button onClick=&#123;handleToggleError&#125;&gt; toggle error &lt;/button&gt;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React的Render-Prop技术]]></title>
    <url>%2F2019%2F11%2F01%2FReact%E7%9A%84Render-Prop%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Render Prop是一种组件使用porps提供的方法去渲染children,外部方便共享内部数据 传统方式1234567891011121314// 简单渲染子组件const LinkerWrapper = (Component) =&gt; &#123; const currentLink = 'www.fe.com' const Proxy = (props) =&gt; &#123; return ( &lt;Component link=&#123;currentLink&#125; &#123;...props&#125; /&gt; ) &#125;&#125;const Outer = LinkerWrapper(Nav)// 此时Outer中就是有link属性的了 这种方法在声明的时候，就已经确定了高阶组件要拓展什么属性 使用Render Prop12345678910111213141516171819const Linker = (props) =&gt; &#123; const currentLink = 'www.fe.com' return props.render(currentLink)&#125;// 为link属性增加值const Outer = ( &lt;Linker render=&#123;(link) =&gt; (&lt;Nav link=&#123;link&#125;/&gt;) &#125; /&gt;)// 为href属性增加值const Outer = ( &lt;Linker render=&#123;(link) =&gt; (&lt;Nav href=&#123;link&#125;/&gt;) &#125; /&gt;) 这种方式的好处是比较简单，所有的组装都是用的时候才根据需要进行组装，并没有用到其他的特性，就是将一个porps的方法指定为他的子组件渲染的方法 不一定是Render这里仅仅是直观，让人可以一次了解到，这个属性就是将来要渲染的时候，使用的porp方式，也可以使用其他的属性名,仅仅是传递一个方法做children的生成函数 1234567891011const Linker = (props) =&gt; &#123; const currentLink = 'www.fe.com' return props.componentRender(currentLink)&#125;const Outer = ( &lt;Linker componentRender=&#123;(currentLink) =&gt; (&lt;Nav href=&#123;link&#125;/&gt;) &#125; /&gt;) 使用children属性children属性比较特殊了，它既可以作为porps传递，也可以直接作子元素传递 porps传递 &lt;Button childre={&#39;click me&#39;} /&gt; 子元素传递 &lt;Button&gt;click me&lt;/Button&gt; 所以可以使用children作为Render Prop的一种形式，更加直观，其实会自动将子元素最为children属性传递下去 12345678910111213141516171819const Linker = (props) =&gt; &#123; const currentLink = 'www.fe.com' return props.children(currentLink)&#125;// 正常作为props属性const Outer = ( &lt;Linker children=&#123;(currentLink) =&gt; (&lt;Nav href=&#123;link&#125;/&gt;) &#125; /&gt;)// 作为特殊的props属性const Outer = ( &lt;Linker&gt; &#123;link =&gt; (&lt;Nav href=&#123;link&#125;/&gt;) &#125; &lt;/Linker&gt;) 最好使用PropTypes声明出来123Linker.propTypes = &#123; childre: PropTypes.func.isRequire&#125; 相同children的顺序问题子元素会覆盖children属性 123456&lt;button children=&#123;'props'&#125; /&gt; =&gt; &lt;button&gt;props&lt;/button&gt;&lt;button&gt;children&lt;/button&gt; =&gt; &lt;button&gt;children&lt;/button&gt;// 两者都声明的情况下， 最终显示效果为&lt;button children=&#123;'props'&#125;&gt;children&lt;/button&gt;&lt;button&gt;children&lt;/button&gt;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoose常用crud]]></title>
    <url>%2F2019%2F10%2F22%2Fmongoose%E5%B8%B8%E7%94%A8crud%2F</url>
    <content type="text"><![CDATA[此处均省略了回调函数，可以在末尾使用回调函数，也可以使用await, promise等 mongoose连接mongoDB node内部提供了一个mongoDB模块，封装效果不如mongoose 12345678const URL = 'mongodb://&lt;username&gt;:&lt;password&gt;@&lt;ip&gt;:&lt;port:27017可省略&gt;/&lt;DBName&gt;'mongoose.connect(URL, &#123; useNewUrlParser: true &#125;) .then(() =&gt; &#123; console.log(`connect mongo success`) &#125;) .catch(err =&gt; &#123; console.log('connect mongo failure', err) &#125;) 理解mongoose的三个对象 应该有一个Schema-&gt;Model-&gt;Document的过程 Schema约束对象，用来规范文档的结构的 123const &#123; Schema &#125; = mongooseconst userSchema = new Schema(&#123; ... &#125;) Model对应到MongoDB中的集合，也就是之前定义过的 1234const UserModel = mongoose.model('users', userSchema)// 注意，定义model的名称的时候，mongoose会自动转换成复数// 简单判断是否s结尾 children -&gt; childrens Document每一个collection中的文档对象，也就是操作的每个存储文档,也就是mongoose取出来的样子 1const user = new UserModel(&#123; ... &#125;) Model上的curd const UserModel = mongoose.model(&#39;users&#39;, userSchema) create1UserModel.create(&#123; ... &#125;) find123456789UserModel.find(conditions, [projection])// 无论什么情况都会返回也给数组 []// 只能挑选显示，或过滤 &#123; email: 1, name: 0 &#125; 报错projection = &#123; email: 1 &#125; // 实际只有email, _id属性projection = &#123; email: 0 &#125; // 其他（除email）所有, _id属性// 字符串挑选，有则显示，-_id，可以过滤掉idprojection = 'email name' findOne, findById123UserModel.findOne(conditions, [projection])UserModel.findById(id, [projection])// 此时会返回 &#123;&#125;, 有多个条件满足，返回第一个对象，找不到为null count, countDocuments 提示count接口将被弃用，使用Collection.countDocuments替代 12UserModel.countDocuments()// 直接返回数量 updateMany1234UserModel.updateMany(conditions, doc, [projection])// 修改多条数据// 此时返回更新结果 &#123; n: 1, nModified: 1, ok: 1 &#125;， 此时仅仅为替换// n -&gt; 匹陪 nModified -&gt; 修改的条数 updateOne, update12345UserModel.update(conditions, doc, [projection])UserModel.updateOne(conditions, doc, [projection])// 修改一条数据，多条仅为第一个// 此时返回更新结果 &#123; n: 1, nModified: 1, ok: 1 &#125;， 此时仅仅为替换doc指定// n -&gt; 匹陪 nModified -&gt; 修改的条数 deleteMany123UserModel.deleteMany(&#123;&#125;)// 删除所有的数据// 此时返回删除结果 &#123; n: 1, ok: 1, deletedCount: 1 &#125; deleteOne123UserModel.deleteOne(&#123;&#125;)// 删除单个数据，多条仅为第一个// 此时返回删除结果 &#123; n: 1, ok: 1, deletedCount: 1 &#125; Document上的curd 这里模拟直接返回了文档对象，实际要据情况而定 set, get, save只有保存了之后，才会同步到数据库中 1234567891011const user = await UserModel.findById('xxx')user.get('name')user.set('name', 'newNameValue')// 修改也可以直接`.`操作最后，同步回去即可user.nameuser.name = 'newNameValue' user.save()// 此时返回的是更新后的数据，即同步到数据库中 toObject Document对象可以直接访问id属性指向_id,当转换过后，只有_id 123const user = await UserModel.findById('xxx')user.toObject()// 此时返回的是普通js对象，不在具有document的相关方法]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于webpack中proxy跨域]]></title>
    <url>%2F2019%2F10%2F20%2F%E5%85%B3%E4%BA%8Ewebpack%E4%B8%ADproxy%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[主流跨域3中方式1.jsonp2.服务端配合cros3.服务器反向代理主要讨论第三种，反向代理的方式 情景 API-cgi www.api.com 后端服务器 www.rd.com 前端服务器 www.fe.com 我们的目的是通过，www.fe.com去拿取www.api.com上的资源，但由于跨域，我们需要后端服务器帮我们抓取一下，做一次转发（同源策略只是浏览器制定的） 12发请求： www.fe.com -&gt; www.rd.com -&gt; www.api.com得响应： www.api.com -&gt; www.rd.com -&gt; www.fe.com 在devServer中配置代理 API-cgi www.api.com 前端服务器 www.fe.com 我们使用devServer来搭建一个代理服务器 1234567891011121314// webpack.config devServerdevServer: &#123; proxy: &#123; '/api': &#123; target: 'http://www.api.com', /* 表示重发的请求去除api,此字段是我们加的 */ pathRewrite: &#123;'^/api' : ''&#125;, changeOrigin: true, /* 如果有https, 可配置此项 */ secure: false, &#125; &#125;,&#125;, 修改发送的请求由于我们在开发的时候devServer，所以前端服务器也是假设在devServer，而我们的proxy也是假设在devServer上的，所以我们需要去请求我们的proxy 1234567# 本意发请求： www.fe.com -&gt; www.api.com得响应： www.api.com -&gt; www.fe.com# 修改后发请求： www.fe.com -&gt; www.fe.com/api得响应： www.fe.com/api -&gt; www.fe.com 其实我们请求了fe上的proxy，他会去真正请求www.api.com,之后拿到数据在返还给我们，而我们是不知道的，由于前后都是www.fe.com所以是属于同源的。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引入eslint]]></title>
    <url>%2F2019%2F10%2F20%2F%E5%BC%95%E5%85%A5eslint%2F</url>
    <content type="text"><![CDATA[node 8+, npm 3+, 使用其官方的eslint脚手架工具 安装推荐安装到devDependencies 1yarn add eslint -D 初始化12345# 全局eslint --init# 本地env./node_modules/.bin/eslint --init 根据相关的提示安装即可，过程中可能还需要在安装一些其他的包eslint插件在npm上搜索eslintplugin即可看到相关的eslint插件，选择下载即可,并参照其相关说明，在.eslintrc.json中添加规则即可]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react中ref相关]]></title>
    <url>%2F2019%2F10%2F17%2Freact%E4%B8%ADref%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[基于React 16.8 在挂载ref的时候，如果这个ref是直接挂载到dom上的，那么当组件挂载完成的时候，ref指向的就是DOM示例 在挂载ref的时候，如果这个ref是直接挂载到component上的，那么当组件挂载完成的时候，ref指向的就是组件实例 由于在函数式组件当中，是没有实例的，所以都是通过ref转发直接挂载到具体的dom上 在组件中使用refReact.createRef()来创建一个ref,然后进行挂载 类式组件12345678910111213141516171819class Component4 extends React.Component &#123; constructor () &#123; super() this.ref = React.createRef() &#125; render () &#123; const &#123; children, &#125; = this.props return ( &lt;button ref=&#123;node =&gt; this.ref = node&#125; onClick=&#123;() =&gt; &#123;console.log(this.ref)&#125;&#125; &gt; &#123;children&#125; &lt;/button&gt; ) &#125;&#125; 函数式组件12345678910111213141516const Component3 = (props) =&gt; &#123; const &#123; children &#125; = props const ref = React.createRef() return ( &lt;button ref=&#123;ref&#125; onClick=&#123;() =&gt; &#123;console.log(ref)&#125;&#125; &gt; &#123;children&#125; &lt;/button&gt; )&#125; 在父组件使用子组件的ref,传递ref在类式组件12345678910111213141516171819202122232425262728// Component1.jsclass Component1 extends React.Component &#123; constructor () &#123; super() this.buttonRef = React.createRef() &#125; render () &#123; const &#123; children, &#125; = this.props return ( &lt;button ref=&#123;node =&gt; this.buttonRef = node&#125; &gt; &#123;children&#125; &lt;/button&gt; ) &#125;&#125;// App.jsconst App = (props) =&gt; &#123; const ref2 = React.createRef() // 当挂在完成的时候 ref2的指向就是button组件 return ( &lt;Component2 ref=&#123;ref2&#125;&gt;Component2&lt;/Component2&gt; )&#125; 此时如果要在类式组件中获取到DOM的ref的话，可以通过一种曲线救国的方式，就是组件内部自行挂载一个ref到this实例的对象上，父组件通过访问子组件的Component的Ref对象，找到他相应内部挂载的DOM的ref即可 比如在上个例子中，我们可以通过ref1.buttonRef拿到button的DOM对象 在函数式组件12345678910111213141516171819// Component2.jsconst Component2 = React.forwardRef((props, ref) =&gt; &#123; const &#123; children &#125; = props return ( &lt;button ref=&#123;ref&#125;&gt;&#123;children&#125;&lt;/button&gt; )&#125;)// App.jsconst App = (props) =&gt; &#123; const ref1 = React.createRef() // 当挂在完成的时候 ref1的指向就是子组件Component1实例 return ( &lt;Component1 ref=&#123;ref1&#125;&gt;Component1&lt;/Component1&gt; )&#125;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原型链相关]]></title>
    <url>%2F2019%2F10%2F15%2Fjs%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[首先是__proto__是不推荐使用的，这是大部分浏览器内部使用的一个对象，但是由于大部分浏览器都支持他了，所以ES’被迫’将这个属性写到了附录里面，但是也只是在浏览器环境中支持，其他环境不推荐支持该属性，应该使用Object.getPrototypeOf()来获取对象上的原型 prototype属性 当一个函数被创建的时候，他的原型对象就诞生了 该属性是函数上用来使用的，为什么只有函数才有该属性了，应为js使用对象来new对象的时候，prototype就是指向的他的构造器，所以每一个函数其实都有可能成为一个构造器，可以用来new的，自然他们就需要挂载一个公共的指向对象，用来保存一些公共的方法，用来节省空间。也就有了prototype执行构造器。 所以__proto__ === prototype === Object.getPrototypeOf() new的时候其实就是从Object继承个对象，挂载原型，然后把它绑定构造器执行 什么是原型链 1234567891011① foo的构造器function Foo () &#123;&#125; 的原型, Foo.prototype② 函数的构造器function Function () &#123;&#125; 的原型, Function.prototype③ 对象的构造器function Object () &#123;&#125; 的原型, Object.prototype④ 函数的构造器function Function () &#123;&#125; 的原型, Function.prototype⑤ function，由new Function()创造出来的的构造器function Function () &#123;&#125; 的原型, Function.prototype⑥ function Function 是最特殊的, 他的原型对象__prop__就是他的proptype对象，也就是 Function.prototype Object.prototype.__proto__按道理Object.prototype.__proto__也是一个对象，应该指向Object的构造器的原型即，Object.prototype,但是这样就造成了循环的重复引用，导致寻找一个对象的原型链上的属性方法时，永远找不到尽头,所以为null prototype与constructor构造函数拥有一个prototype属性，指向的是原型对象，然而原型对象上，有一个属性指向的constructor属性指向的是构造器的那个函数 如何判断一个对象是否在另一个对象的原型链上判断是否在我自己的原型链上object instanceof constructor123456let Foo = function () &#123;&#125;let fooObject = new Foo()fooObject instanceof Foo // truefooObject instanceof Functino // falsefooObject instanceof Object // true 判断是否在别人的原型链上prototypeObj.isProptotypeOf(object)123456let Foo = function () &#123;&#125;let fooObject = new Foo()Foo.isProptotypeOf(fooObject) // trueFunction.isProptotypeOf(fooObject) // falseObject.isProptotypeOf(fooObject) // true 如何拒绝原型链，只看自己身上的属性hasOwnProperty1234let obj = &#123; age: 18 &#125;obj.hasOwnProperty('age') // trueobj.hasOwnProperty('toString') // false 实战（判断对象上的属性）1234567891011121314151617181920function foo () &#123; this.some = '222' let ccc = 'ccc' foo.okkoro = 'okkoro' foo.prototpye.a = 'aaa'&#125;foo.koro = 'koro'foo.prototpye.test = 'test1'let foo1 = new foo ()foo1.prototpye.test = 'test2'// 最终foo1上的属性（仅说明与此题相关的）foo: &#123; some: '222' __proto__: &#123; a: 'aaa', test: 'test2' &#125;&#125; 首先要明白new的时候，首先从object继承了一个对象过来，然后把当前构造器的原型给他了他，他的原型上就有了a,之后又手动挂载了一个test,(后面被修改掉了，因为总是指向的关系) 在实际的属性上，foo1仅有some一个属性，也就是构造函数中this的效果 至于okkoro,koro这两个属性仅仅是foo的静态属性，通过foo1是无法访问到的，因为foo1和foo的关系仅仅是原型对象上的关系，实际挂载的属性是不相联系的。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置spa前端工程]]></title>
    <url>%2F2019%2F10%2F13%2Fnginx%E9%85%8D%E7%BD%AEspa%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[spa应用最终打包的dist中，是会以index.html作为入口文件，如果一旦使用browserURL的这种方式来做路由的跳转，那么在部署的时候，可能会出现以下问题 1234567www.blog.com在正常情况下,在应用内，跳转式没问题的www.blog.com/profiewww.blog.com/artcile如果是刷新网页，服务器就会提示。profile资源不存在，这是由于路由导致的，我们在spa内解析的路由没有正确的被识别，反而当成了一种资源 在nginx的配置文件中，要使用如下的配置 123456789101112131415161718server &#123; listen 8080; server_name localhost; root /usr/project/dist; index index.html; location / &#123; try_files $uri $uri/ @router; index index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; location @router &#123; rewrite ^.*$ /index.html break; &#125; &#125;]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中EventLoop相关]]></title>
    <url>%2F2019%2F10%2F13%2F%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3EventLoop%2F</url>
    <content type="text"><![CDATA[浏览器中的EventLoop与node中的EventLoop是不同的 在js中，是单线程的，所以只能把任务放进一个任务队列中，依次调用这个队列来完成所有事情 可以想象成js就是一个公交车，所有的任务过来先排队，等到了时间公交车会过来一趟拉走，此时不管现在是什么情况，他只会将当前的人拉走，至于还没有到的人就只能等下一趟公交车。 如何执行异步操作的当执行到异步任务的时候，首先他会将此任务交给 Event table去处理，等到异步操作结束的时候，再压入任务队列task queen,所以在事件循环的时候，他并不会去了解这个任务是否经完成（公交司机，见有人他就拉走，如果那个人有事暂时还来不了，那就等下一班车，以此类推），所以一旦任务完成，就将注册的回调任务压入任务队列，EventLoop做完当前任务队列的事情时候，再来执行他 setTimeout的问题123456789101112131415161718192021// 此时执行下来总耗时4731let startTime = new Date().getTime();setTimeout(()=&gt;&#123; console.log(`开始执行回调的相隔时差：$&#123;new Date().getTime()-startTime&#125;`);&#125;, 1000);for(let i = 0;i&lt;40000;i++)&#123; console.log(1)&#125;/* 如果将setTimeout的延时去除 */// 此时执行下来总耗时4698let startTime = new Date().getTime();setTimeout(()=&gt;&#123; console.log(`开始执行回调的相隔时差：$&#123;new Date().getTime()-startTime&#125;`);&#125;, 0);for(let i = 0;i&lt;40000;i++)&#123; console.log(1)&#125; 可以看到运行的时间并没有由于运行结果而改变，是因为此时的timeout在压入task queen的时候，主线程还有任务没有执行完，所以也就造成了当前已经有新任务压入了，但是没有来得及运行 123456789101112131415161718192021任务比较空的时候，会得到及时的相应主线程 任务队列 1 | 2 | | | 3 3 | 任务比较满的时候，造成了延迟，定时器不准主线程 任务队列 1 | 1 | 1 | 1 | 2 1 | 1 | 1 | 2 | micro-task &amp; macro-task除去同步，异步的角度来看，还可以分为微任务（除去Process.nextTick、Promise.then catch finally(注意我不是说 Promise)、MutationObserver），其他都可以当做宏任务。mirco-task的好处就是，他可以插队，如果有个setTimeout，已经执行完了，在quenTask中等待了，promise.then可以先与他执行 12345678910111213141516console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);// script start// promise1// promise2// setTimeout node则将EventLoop分为6个阶段（依次循环），其中每一个阶段都是一类的marco-task的task queue timers： 执行setTimeout, setInterval中的到期的callback pending callback: 上一轮循环中少数的I/O,callbcak会延迟到这里执行 idle,prepare: 仅在内部使用 poll 最为重要的阶段，执行I/O等，callback check 执行setImmediate的callback close 执行close的callback事件 timers虽然定时器任然是不准确的，但是将timers放到了EventLoop的最前面，也是为了保证，尽量准时执行定时器任务 poll 执行I/O,callback 处理poll queue中的task任务 task有任务，执行他，一直到队列为空或者系统相关限制 task为空，会去看是否有setImmediate,有则直接跳到check，否则在这里阻塞等待 其他的一些阶段会有特殊执行，比如socket,close的时候，就会到close去执行 process.nextTick他是一个终极插队王，比micro-task还厉害 关于micro-task与macro-task123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//nodeconsole.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;)// 1 // 7 // 6 // 8 // 2 // 4 // 9 // 11 // 3 // 10 // 5 // 12 // chrome console.log('1');setTimeout(function() &#123; console.log('2'); new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;)// 1// 7// 8// 2// 4// 5// 9// 11// 12 至于node中，setTimeout中是同一类的macro-task，所以他们会全部执行完，等待切换的时候，在执行micro-task,然而在chrome中，每一个macro-task是单独执行的，所以每一个任务执行完的时候，都有机会去做macro-task]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署yapi与使用守护进程supervisor]]></title>
    <url>%2F2019%2F10%2F10%2F%E9%83%A8%E7%BD%B2yapi%2F</url>
    <content type="text"><![CDATA[多款API文档管理工具都体验了一下，从开源以及后期维护来说，yapi确实是不错的选择，由去哪前端团队出品，并且一直在维护，虽然相比同行业eolinker来说，还是有一定距离，但是对于内网部署，使用来说，yapi确实是不错的选择了。 安装MongoDB 配置阿里yum源 1234567891011cd /etc/yum.repos.d/# 添加源vim mongodb-org.repo# mongodb-org.repo[mongodb-org]name=MongoDB Repositorybaseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/7Server/mongodb-org/3.2/x86_64/gpgcheck=0enabled=1 更新yum源 1yum update 3.安装MongoDB12yum install -y mongodb-orgservice mongod start 安装YApi部署cli1npm install -g yapi-cli --registry https://registry.npm.taobao.org 使用页面配置（打开9090端口）1yapi server 配置12345678910111213vim config.json# 建议使用163邮箱，效果比较好 "mail": &#123; "enable": true, "host": "smtp.163.com", "port": 465, "from": "可用于发送邮件的163邮箱", "auth": &#123; "user": "163邮箱", "pass": "163邮箱对应的密码或授权码" &#125;&#125; 启动切换到安装目录下，使用node启动服务1node vendors/server/app.js 总的来说安装还是很简单的，是一款非常不错的工具，并且安装也很容易 使用Supervisor守护安装12yum install python-setuptools -yeasy_install supervisor 修改配置12345678910# 创建目录mkdir /etc/supervisor# 创建模板文件echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf# 添加自定义配置vim /etc/supervisor/supervisord.conf# supervisord.conf 追加，加载目录下的文件[include]files = conf.d/*.conf 增加YApi.conf1234567891011vim /etc/supervisor/conf.d/YApiGhost.conf# YApiGhost.conf[program: YApiGhost]command=node vendors/server/app.jsdirectory=/usr/yapi/yapiautorestart=truestderr_logfile=/var/log/YApiGhost.err.logstdout_logfile=/var/log/YApiGhost.out.loguser=rootstopsignal=INT 启动守护进程1supervisord -c /etc/supervisor/supervisord.conf 设置开机启动1234567891011121314151617vim /usr/lib/systemd/system/supervisord.service# supervisord.service[Unit]Description=Supervisor daemon[Service]Type=forkingExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.confExecStop=/usr/bin/supervisorctl shutdownExecReload=/usr/bin/supervisorctl reloadKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.target 设置开机启动1systemctl enable supervisord 使用supervisorctl管理12345678910# 开启supervisord -c /etc/supervisor/supervisord.conf# 关闭supervisorctl shutdownsupervisorctlstop &lt;Service name&gt;start &lt;Service name&gt;restart &lt;Service name&gt;]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不适合使用箭头函数的场景]]></title>
    <url>%2F2019%2F10%2F10%2F%E4%B8%8D%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[箭头函数无法绑定this12345678910111213const fn1 = (p) =&gt; &#123; console.log(p) console.log(this)&#125;function fn2 (p) &#123; console.log(p) console.log(this)&#125;fn1.apply(&#123;name: 'zzz'&#125;, ['fn1']) // fn1 undefinedfn2.apply(&#123;name: 'zzz'&#125;, ['fn2']) // fn2 &#123; name: 'zzz' &#125;fn1.call(&#123;name: 'zzz'&#125;, 'fn1') // fn1 undefinedfn2.call(&#123;name: 'zzz'&#125;, 'fn2') // fn2 &#123; name: 'zzz' &#125; 在对象内使用需要注意的定义字面量的方法在对象内定义方法的时候，如果该方案使用到了this，那么则需为传统函数的形式123456789101112131415161718192021// 错误的使用const calculator = &#123; array: [1, 2, 3], sum: () =&gt; &#123; console.log(this) // this指向的是外部window对象 return this.array.reduce((result, item) =&gt; result + item, 0) &#125;&#125;// 正确的使用const calculator = &#123; array: [1, 2, 3], sum1: function () &#123; console.log(this) // 指向对象本身 return this.array.reduce((result, item) =&gt; result + item, 0) &#125;, sum2 () &#123; // 和上面是一样的 console.log(this) // 指向对象本身 return this.array.reduce((result, item) =&gt; result + item, 0) &#125;&#125; 定义原型上的方法原型上定义的方法，有时目的就是取到对象this，进行操作，也不能使用箭头函数的形式123456789101112131415function Cat(name) &#123; this.name = name;&#125;// 正确的使用方式Cat.prototype.sayCatName = function () &#123; console.log(this) // cat实例 return this.name&#125;// 错误的使用方式Cat.prototype.sayCatName = () =&gt; &#123; console.log(this); // =&gt; window return this.name; // 外部取不到就会报错&#125;; 定义事件的回调函数上因为回调函数目的是当前的对象，在之后还能调用它，也就是强烈需要this的信息当时用了箭头函数的时候，会丢失this12345678910111213const button = document.getElementById('myButton')// 错误的使用button.addEventListener('click', () =&gt; &#123; console.log(this) // =&gt; window this.innnerHTML = 'new Button Text' // 报错，此时window无innerHTML属性&#125;)// 正确的使用button.addEventListener('click', function () &#123; console.log(this) // =&gt; button this.innnerHTML = 'new Button Text'&#125;) 定义构造函数箭头函数定义在构造函数中是没有意义的1234567891011// 错误使用const Fish = (name) =&gt; &#123; this.name = name&#125;console.log(new Fish('feifei')) // 报错，Fish不是构造函数// 正确使用const Dog = function (name) &#123; this.name = name&#125;console.log(new Dog('heihei')) 代码风格虽然使用箭头函数可以少去花括号，少去return, 一行完成，但是一定要是在代码可读的情况下，与代码可维护性相比较，过短的代码会影响对其的解读性]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于react中的context的理解]]></title>
    <url>%2F2019%2F10%2F08%2F%E5%85%B3%E4%BA%8Ereact%E4%B8%AD%E7%9A%84context%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本例只是做说明性，具体代码要运行起来，还需要加入些其他元素 主要解决的问题在应用中可能会有很多组件会去使用到的组件，并且当使用父子传递这一机制的时候，会显得过于臃肿繁琐，所以要使用上下文的方式来进行传递。 1.创建一个context12345// theme-context.jsimport React from 'react'export const ThemeContext = React.createContext('dark') // 默认为dark 2.使用context内容-class12345678910111213// Demo.jsimport &#123; ThemeContext &#125; from './theme-context'class Demo extends React.Component &#123; render () &#123; const theme = this.context return (&lt;div&gt;&#123;theme&#125;&lt;/div&gt;) &#125;&#125;Demo.contextType = ThemeContext 2.使用context内容-function12345678910111213// Demo.jsimport &#123; ThemeContext &#125; from './theme-context'function Consumer (props) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;div&gt;&#123;theme&#125;&lt;/div&gt; )&#125; &lt;/ThemeContext.Consumer&gt; )&#125; 3.传递启用1234567891011121314151617181920212223// App.jsimport React from 'react'import &#123; ThemeContext &#125; from './theme-context'import Demo from 'demo'function Wrapper (props) &#123; return (&lt;Demo /&gt;)&#125;class App extends React.Component &#123; render ( return ( &lt;div&gt; &lt;ThemeContext.Provider value="light"&gt; &lt;Wrapper /&gt; // 此时 Wrapper 内的 Demo 使用的是就近的 light &lt;/ThemeContext.Provider&gt; &lt;Wrapper /&gt; // 此时 Wrapper 内的 Demo 使用的是默认值 dark &lt;/div&gt; ) )&#125; 在hook中使用context父组件还是要使用&lt;MyContext.Provider value={} /&gt;这种方式将上下文对象全局传递出去，不同的就是使用到context的组件，可以使用function组件，来方便的接收12345678910// Demo.jsimport React from 'react'import &#123; ThemeContext &#125; from './theme-context'function Demo (props) &#123; const theme = React.useContext(ThemeContext) // ... context中变化时，该组件会同步刷新&#125; 需要注意的问题context会使用参考标识，也就是说，可能value不变的情况下，他会通知使用到context组件重新渲染1234567891011121314&lt;Provider value=&#123;&#123;something: 'something'&#125;&#125;&gt; &lt;Toolbar /&gt;&lt;/Provider&gt;// 此时此组件刷新的时候，他会通知组件 value发生了改变（尽管字面量并没有发生改变）// 可以将value的值提到state中去存储state = &#123; value: &#123;something: 'something'&#125;&#125;&lt;Provider value=&#123;this.state.value&#125;&gt; &lt;Toolbar /&gt;&lt;/Provider&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于react中循环渲染数据时key的问题]]></title>
    <url>%2F2019%2F10%2F05%2F%E5%85%B3%E4%BA%8Ereact%E4%B8%AD%E5%BE%AA%E7%8E%AF%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E6%97%B6key%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[key的影响循环元素之所以需要一个key，就是因为他无法确认这两个元素在前后是否还有关联，因为他们大都是类型相同的，会造成重新渲染或者是一些聚焦状态等丢失，所以要根据这个key来判断是否是当前元素123456789101112131415let todos = [&#123; id: 1, title: 'eat' &#125;, &#123; id: 2, title: 'coding' &#125;]todos.map((todo, index) =&gt; ( &lt;p key=&#123;index&#125;&gt; &lt;span&gt;&#123;todo.title&#125;&lt;/span&gt; comment: &lt;input /&gt; &lt;/p&gt;))todos.map((todo, index) =&gt; ( &lt;p key=&#123;todo.id&#125;&gt; &lt;span&gt;&#123;todo.title&#125;&lt;/span&gt; comment: &lt;input /&gt; &lt;/p&gt;)) 当我们在输入框输入一定的内容的时候，我们切换一下数组的内容1todos = [ todos[1], todos[0] ] 此时两种方式绑定的不同结果可能就会，造成元素改变了，上一次输入的内容与标签对应异常 当我们点击切换元素内的顺序时]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[devServer实现局域网内访问]]></title>
    <url>%2F2019%2F10%2F04%2FdevServer%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[在react项目中，经常会使用到devServer, 此时如果设备在同一局域网下应该是可以胡同的（同一wifi环境） 检查本机防火墙设置 开启devServer相关配置（重点） 1234567devServer: &#123; port: 8080, disableHostCheck: true, host: '0.0.0.0', ...&#125;,]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eolinkerAMS开源版架设]]></title>
    <url>%2F2019%2F10%2F04%2FeolinkerAMS%E5%BC%80%E6%BA%90%E7%89%88%E6%9E%B6%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[java版地址 https://gitee.com/haonan98/eoLinker-AMS-Lite-For-Java 所需环境 java8+ mysql5.5+ 创建数据库创建数据库eolinker_os，并执行eolinker_os.sql 更改相关连接配置更改配置文件,setting.propperties 运行jar包java -jar xxx 后续进入引导即可 项目地址http://ip:port/eolinker_os/index.html 开源感谢https://www.eolinker.com]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[814]]></title>
    <url>%2F2019%2F08%2F14%2F814%2F</url>
    <content type="text"><![CDATA[又是一个814，22岁了，长大了一岁，哈哈哈哈，以后每年就在这里记录一下吧，明天公交云就开工资了，算人生第一桶金吧，哈哈哈，加油 杭州·公交云 22 实习4knext age =&gt; 6k 加油咯！]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序内，生成自定义二维码]]></title>
    <url>%2F2019%2F08%2F14%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%86%85%EF%BC%8C%E7%94%9F%E6%88%90%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近在开发中，需要生成自定义的二维码，于是做了一个包出来，分享给大家一起使用。适用于微信小程序的二维码生成器，基于Canvas生成，支持中文的输入。可在原生小程序，mpvue，taro中使用。（文末有一个使用示例） github地址 wxmp-qrcode 安装1npm install wxmp-qrcode 使用 创建一个canvas,设置其id,与canvas-id， 并设置canvas的样式，二维码基于其大小生成并居中 1&lt;canvas id="cav-qrcode" canvas-id="cav-qrcode"&gt;&lt;/canvas&gt; 引入包并使用 12import QR from 'wxmp-qrcode'QR.draw(str, canvasId) api123456789101112131415/** * 根据canvas尺寸，画出合适居中的qrcode * @param &#123;Object&#125; str 二维码的内容 (必须) * @param &#123;Object&#125; canvasId canvasId的值 (必须) * @param &#123;Object&#125; $this 传入组件的this,兼容在组件中生成二维码 （可选，可省略该参数） * @param &#123;Object&#125; callback 回调函数 (可选) */draw: function (str, canvasId, $this, callback)/*** 清除canvas内容* @param &#123;Object&#125; canvasId canvasId (必须)* @param &#123;Object&#125; callback 回调函数 （可选）*/clear: function (canvasId, callback) 注意 canvas中 id, canvas-id必须保持一致 id 获取canvas节点，自动计算大小使用, 二维码大小基于canvas自动生成 canvas-id 绘制二维码使用 如果在组件中使用，需要传入组件的this，draw(str, canvasId, componentThis) 具体参见 wx.createCanvasContext 可以保存二维码为临时图片地址 具体可参见 wx.canvasToTempFilePath bug: 该方法有时保存的图片会有一个竖条。1234567891011121314createQrCode: function (content, canvasId) &#123; QR.api.draw(content, canvasId) this.canvasToTempImage(canvasId)&#125;,//获取临时缓存图片路径canvasToTempImage: function (canvasId) &#123; wx.canvasToTempFilePath(&#123; canvasId, success: function (res) &#123; let tempFilePath = res.tempFilePath; // 临时图片地址，可在放入图片src中使用 &#125; &#125;)&#125; 原生小程序wxmp中使用 在项目设置中选择 使用npm模块 如果第一次使用npm模块，需要首先在根目录中npm init, 之后再安装模块 npm i wxmp-qrcode 在工具中选择 构建npm index.wxml 1234&lt;view class="container"&gt; &lt;canvas id="&#123;&#123;canvasId&#125;&#125;" canvas-id="&#123;&#123;canvasId&#125;&#125;"&gt;&lt;/canvas&gt; &lt;button bindtap="creatQRCode"&gt; 生成二维码 &lt;/button&gt;&lt;/view&gt; index.wxss 12345678canvas &#123; border: 1rpx solid #eee; width: 400rpx; height: 400rpx;&#125;button &#123; margin-top: 100rpx;&#125; index.js 12345678910111213import QR from './qrcode'Page(&#123; data: &#123; canvasId: 'canvasId', QRdata: '你好 wxmp-qrcode' &#125;, creatQRCode () &#123; let str = this.data.QRdata let canvasId = this.data.canvasId QR.draw(str, canvasId) &#125;&#125;)]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[taro中集成redux-saga]]></title>
    <url>%2F2019%2F08%2F14%2Ftaro%E4%B8%AD%E9%9B%86%E6%88%90redux-saga%2F</url>
    <content type="text"><![CDATA[taro中redux处理方案是采用redux-thunk,这里采用redux-saga解决异步问题，引入目前最新redux-saga@1.0.5 引入方式一可以直接下载种子项目，已经引入了saga，并做好了相关配置，可在此基础上再次开发taro-redux-saga-seed123456789// 下载种子项目git clone https://github.com/Z-HNAN/taro-redux-saga-seed// 安装依赖cd taro-redux-saga-seednpm i // 启动项目-小程序(微信开发者工具查看效果，有一个3s延迟的add示例)npm run dev:weapp 引入方式二在自己已经有的项目上引入，按照后续步骤自行引入即可 安装redux-saga1npm i redux-saga 更改目录形式将每个文件放在模块中，利于查找，便于引入，后面引入saga文件也比较清晰，当然这里只是一个个人喜好，也可按照自己的目录形式来安排，这里只做一个参考,请多留意引入文件路径是否正确。1234567891011121314151617└─src │ app.jsx │ app.less │ index.html │ ├─pages │ └─index │ action.js │ index.jsx │ index.less │ reducer.js | saga.js │ └─store index.js reducer.js saga.js 引入index模块的saga pages/index/saga.js捕获当前模块中的action 1234567891011import &#123; put, delay, takeEvery&#125; from 'redux-saga/effects'function* asyncAddRequest (action) &#123; const &#123; timeout &#125; = action.payload yield delay(timeout) yield put(&#123; type: 'ADD' &#125;)&#125;export default function* () &#123; yield takeEvery('ASYNC_ADD', asyncAddRequest)&#125; 配置根saga文件 store/saga.js启动各个模块的saga 123456789import &#123; all &#125; from 'redux-saga/effects'import index from '../pages/index/saga'export default function* () &#123; yield all([ index() ])&#125; 在store中引入sagaMiddleware store/index.jssaga连接到store 引入saga 配置saga中间件到middlewares 启动saga 12345678910111213141516171819202122232425262728293031323334353637import &#123; createStore, applyMiddleware, compose &#125; from 'redux'/* 引入saga */import createSagaMiddleware from 'redux-saga'import rootSaga from './saga'import rootReducer from './reducer'const composeEnhancers = typeof window === 'object' &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123; // Specify extension’s options like name, actionsBlacklist, actionsCreators, serialize... &#125;) : compose/* 生成sagaMiddleware */const sagaMiddleware = createSagaMiddleware();const middlewares = [ /* 应用saga */ sagaMiddleware]/* 处理redux-logger */if (process.env.NODE_ENV === 'development' &amp;&amp; process.env.TARO_ENV !== 'quickapp') &#123; middlewares.push(require('redux-logger').createLogger())&#125;const enhancer = composeEnhancers( applyMiddleware(...middlewares), // other store enhancers if any)export default function configStore () &#123; const store = createStore(rootReducer, enhancer) /* 启动saga */ sagaMiddleware.run(rootSaga) return store&#125; 检测 pages/index/index.jsx 本例以taro的redux为基础进行测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import Taro, &#123; Component &#125; from '@tarojs/taro'import &#123; View, Button, Text &#125; from '@tarojs/components'import &#123; connect &#125; from '@tarojs/redux'import &#123; add, minus, asyncAdd &#125; from './action'import './index.less'const mapStateToProps = (state) =&gt; &#123; return &#123; counter: state.index.num &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; add: () =&gt; &#123; dispatch(add()) &#125;, asyncAdd: () =&gt; &#123; dispatch(asyncAdd(&#123; timeout: 3000 &#125;)) &#125;, minus: () =&gt; &#123; dispatch(minus()) &#125; &#125;&#125;@connect(mapStateToProps, mapDispatchToProps)class Index extends Component &#123; config = &#123; navigationBarTitleText: '首页' &#125; componentWillReceiveProps (nextProps) &#123; // console.log(this.props, nextProps) &#125; componentWillUnmount () &#123; &#125; componentDidShow () &#123; &#125; componentDidHide () &#123; &#125; render () &#123; return ( &lt;View className='index'&gt; &lt;Button className='add_btn' onClick=&#123;this.props.add&#125;&gt;+&lt;/Button&gt; &lt;Button className='dec_btn' onClick=&#123;this.props.minus&#125;&gt;-&lt;/Button&gt; &lt;Button className='dec_btn' onClick=&#123;this.props.asyncAdd&#125;&gt;async&lt;/Button&gt; &lt;View&gt;&lt;Text&gt;&#123;this.props.counter&#125;&lt;/Text&gt;&lt;/View&gt; &lt;View&gt;&lt;Text&gt;Hello, Redux-saga&lt;/Text&gt;&lt;/View&gt; &lt;/View&gt; ) &#125;&#125;export default Index]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reselect解读]]></title>
    <url>%2F2019%2F08%2F14%2Freselect%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[基于1.0.0 进行解读 简单回顾一下高阶函数1234567891011121314151617181920212223function myMemorize(fn) &#123; let lastRet = null let lastParam = null let resultFuc = fn return (...args) =&gt; &#123; if (lastRet &amp;&amp; args.every((value, index) =&gt; value === lastParam[index])) &#123; // 有缓存结果，并且参数完全一致 return lastRet &#125; // 缓存结果不一致 lastParam = args lastRet = resultFuc(...args) return lastRet &#125;&#125;let add = (a, b) =&gt; a + blet memAdd = myMemorize(add)console.log('---------------------------')add(1, 2) =&gt; 3 计算add(1, 2) =&gt; 3 计算memAdd(1, 2) =&gt; 3 计算memAdd(1, 2) =&gt; 3 缓存 目的进行缓存数据，他对纯函数的结果进行一次缓存，（纯函数Pure Function：给定确定的输入输出，他的值都是不变的，所以有了缓存的需求，不用每一次都计算） 另外，在react中，由于React的Diff算法，他会打补丁，那么如果给的state相同的话，就会跳过这个补丁，也就省去了此次的刷新操作，节省了时间。然而在原本的React中，state更新时，所有的state都会被通知到，内容完全一样，只是他们的内存地址不同，所以就导致了Diff会打上一个无用的补丁，做一些不必要的视图刷新操作。 流程使用高阶函数，将上一次的纯函数的参数，和函数运算的结果，做存储，如果此次的参数和上一次的完全相同，那么就认为可以使用上一次的缓存，也就达到了存储的目的。大量运用到了高阶函数的思想。 主要的方法 createSelectorCreator(memoize)用来做生成一个select,他的高阶函数作用是定制化了记忆函数 123456789101112131415161718192021createSelectorCreator (memoize) &#123; /** * dependencies 他所要依赖的相关函数 * resultFunc 运行最终结果的函数 */ return (dependencies, resultFunc) =&gt; &#123; // 拿到一个定制化的memoize const memoizeResultFunc = memoize(resultFunc) // 返回selector,他的作用是处理每一个state const selector = (state, props, ...args) =&gt; &#123; // 执行每一个dependency,获取到每一个参数 const params = dependencies.map( dependency =&gt; dependency(state, props, ...args) ); // 通过定制记忆函数返回数据 return memoizedResultFunc(...params); &#125;; return selector &#125;&#125; defaultMemoize(func)默认的一个记忆函数，他的高阶函数作用是，记住了上一次参数和结果 123456789101112131415defaultMemoize (func) &#123; let lastParams = null; let lastResult = null; return (...params) =&gt; &#123; // 如果上一次有结果，并且 每个参数都相同，就返回结果 if (lastParams !== null &amp;&amp; params.every((value, index) =&gt; value === lastParams[index])) &#123; return lastResult; &#125; // 记忆上一次的参数，真正执行一次，并把结果都缓存起来 lastParams = params; lastResult = func(...params); return lastResult; &#125;;&#125; defaultEqualityCheck(a, b)这个函数的作用是判断连个参数是否相等，上面使用了硬比较 ===, 当然也可以用其他的判断方法代替一下 12value === lastParams[index]defaultEqualityCheck(value, lastParams[index]) 执行过程1234567891011121314const state = &#123; shop: &#123; items: [&#123;id:1, value: 1&#125;,&#123;id:2, value: 2&#125;,&#123;id:3, value: 3&#125;] &#125;&#125;const shopItemsSelector = state =&gt; state.shop.itemsconst totalSelector = createSelector( shopItemsSelector, (items) =&gt; items.reduce((acc, item) =&gt; acc + item.value, 0))let total = totalSelector(state) 12345678910111213// 1. 创建出selectorlet selector = createSelector([fun1, fun2], fun3)let someState = (function(state, props) &#123; let state1 = fun1(state, props) let state2 = fun2(state, props) return fun3(state1, state2)&#125;)(state, props)// 2. 记忆结果return fun3(state1, state2),// 将直接执行fun3替换为已经记忆化过的memoizedResultFuncreturn memoizedResultFunc(state1, state2)他去判断state的值是否相同，如果相同，就直接返回出一个上一次存储的结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[redux中常用的efffects]]></title>
    <url>%2F2019%2F08%2F14%2Fredux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84efffects%2F</url>
    <content type="text"><![CDATA[redux-saga中effect的使用redux-saga 中将有副作用的方法，都放到了外部单独的文件中去执行1action1(plain object)——&gt;redux-saga监听—&gt;执行相应的Effect方法——&gt;返回描述对象—&gt;恢复执行异步和副作用函数—&gt;action2(plain object) 方便进行测试，如果effect方法执行的结果的返回值就是将要执行的对象，那么可以认为，在今后这个action执行的时候，他的结果就是正常的，也就是说redux-saga的作用就是，我们可以提前获取到即将执行的方法，以及他的参数，但是他的具体执行时间是未知的 redux-effect的相关effect方法 v 1.0.5 take 监听方法，并返回一个action对象 takeLatest yield takeLatest(&#39;xxx&#39;, xxxRequest) call 调用某个方法 yield call(fn, ...args) put 发出一个action，其参数就是action对象，也就是即将发给reducer做真正的处理 put({type: &#39;XXXX&#39;, payload: {}}) select 获取state，返回的结果是state对象，可以进行获取数据 let xxx = yield select((state) =&gt; state.xxx); debounce 防止时间抖动，过一段时间发一次请求 yield debounce(1000, &#39;FETCH_AUTOCOMPLETE&#39;, fetchAutocompleteFn) delay 延迟多少ms的一个，类似于timeout yield delay(500) all 监听所有的saga,启动所有的方法 all([ saga1(), saga2() ])]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Fragment]]></title>
    <url>%2F2019%2F08%2F14%2FFragment%2F</url>
    <content type="text"><![CDATA[可以理解为,是一个空的jsx标签1&lt;&gt;&lt;/&gt; // 这其实是&lt;React.Fragment&gt;&lt;/React.Fragment&gt;的语法糖 当前父组件中是一个table中的tr 123&lt;table&gt; &lt;tr&gt; &#123;children&#125; &lt;/tr&gt;&lt;/table&gt; 如果children是传统上的div, 1234&lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt;&lt;/div&gt; 那么最终展示的效果为,展示会出现,显示异常12345678&lt;table&gt; &lt;tr&gt; &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt; &lt;/tr&gt;&lt;/table&gt; 使用React.Fragment时1234&lt;React.Fragment&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt;&lt;/React.Fragment&gt; 那么最终展示的效果为,展示会出现，显示正常123456&lt;table&gt; &lt;tr&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-enhancer浅析]]></title>
    <url>%2F2019%2F08%2F13%2Fredux-enhancer%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在redux的createStore中，还有两个参数createStore(reducer, [preloadedState], [enhancer])这里主要分析enhancer,这是一个增强器，用来增强redux的各个方法，也就是替换createStore方法的函数， 简单回顾一下createStore(reducer)就是创建出一个store,然后汇总所有的reducer，将所有的state过一遍123456789101112131415161718192021222324252627282930313233343536373839function createStore ( reducer ) &#123; let state, listenArr = [] function getState () &#123; return JSON.parse(JSON.stringify(state)) // 返回一个拷贝，防止直接修改state中数据 &#125; function dispatch ( action ) &#123; // 执行reducer返回结果,并且语法要求 reducer(state = &#123;&#125;, action) 这里state语法要求有默认值， 并且最后返回了，所以执行一次就有值 state = reducer(state, action) for (let i = 0, fn; fn = listenArr[i++]; )&#123; if (typeof fn === 'function') &#123; fn() &#125; else &#123; listenArr.splice(i, 1) i-- &#125; &#125; &#125; // 初始化一下，没有实际作用，返回用户默认state, dispatch(&#123;type: '_INIT_DEFAULT_STATE'&#125;) function subscribe ( fn ) &#123; if ( !listenArr.includes(fn) ) &#123; // 防止重复添加 listenArr.push(fn) &#125; return function unsubscribe () &#123; let delIndex = listenArr.indexOf(fn) listenArr[delIndex] = null // 防止数组塌陷 &#125; &#125; return &#123; getState, dispatch, subscribe &#125;&#125; 什么是enhancer,就是代替了createStore，可以创建出一个符合你的要求的一个store他的返回值是一个createStore,应该有和原函数一样的参数12345678910111213141516171819202122232425export default function autoLogger () &#123; // 返回一个函数 createStore, 替代原先的 return createStore =&gt; (reducer, initialState, enhancer) =&gt; &#123; // 拿到原来的store,等于已经创建好了，直接装饰就可以 const store = createStore(reducer, initialState, enhancer) // 覆盖原先的dispatch function dispatch (action) =&gt; &#123; console.log(`dispatch an action: $&#123;JSON.stringify(action)&#125;`); const res = store.dispatch(action); const newState = store.getState(); console.log(`current state: $&#123;JSON.stringify(newState)&#125;`); return res; &#125; // 返回最修改后的store return &#123; ...store, dispatch &#125; &#125;&#125;// 创建出自定义的loggercreateStore(reducer, autoLogger()) enhancer就是一个允许覆盖的createStore当然他也是侵入性的，会破坏掉原始的store结构,下面的例子就破坏的dispatch经过这个enhancer处理的dispatch就是一个毫无作用的dispatch,所以说他是侵入式的12345badEnhancerfunction dispatch (action)&#123; console.log('hello')&#125; 什么是middleware他就是官方提供的一个enhancer,只是最后允许修改dispatch可以看出，他的功能和enhancer一样的123456789export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; // 省略 return &#123; ...store, dispatch &#125; &#125;&#125; 多层enhancer 当我们要使用很多enhancer的时候，我们可能要包很多层 12345678910111213141516171819202122232425262728function enhancer1 (reducer, initState, () =&gt; &#123; return enhancer2 =&gt; (reducer, initState, () =&gt; &#123; return enhancer3 =&gt; (reducer, initState, enhancer) &#123; return createStore(reducer, initState, enhancer) &#123; // enhancer3的逻辑 const store3 = createStore(reducer, initState, enhancer) // ... 覆盖方法 return &#123; ...store3 &#125; &#125; return createStore(reducer, initState, enhancer) &#123; // enhancer2的逻辑 const store2 = createStore(reducer, initState, enhancer) // ... 覆盖方法 return &#123; ...store2 &#125; &#125; &#125; return createStore(reducer, initState, enhancer) &#123; // enhancer1的逻辑 const store1 = createStore(reducer, initState, enhancer) // ... 覆盖方法 return &#123; ...store1 &#125; &#125; &#125;)&#125;) 通常使用compose进行组合, 包裹将applyMiddleware,也要组合进去最后会返回一个依次嵌套的enhancer，类似一个洋葱模型 12345const enhancer = compose( applyMiddleware(...middlewares), autLogger(), otherEnhancer(),); 当然，如果不需要enhancer，直接createStore(reducer, applyMiddleware())即可]]></content>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async与await的理解]]></title>
    <url>%2F2019%2F07%2F07%2Fsync%E4%B8%8Eawait%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[具体的执行情况V8与浏览器环境可能会略有差异，这里主要做一些原理说明，具体的执行顺序可能需要视实际情况来定。 asyncasync是将一个方法等待，但是其并不是暂停到那边，而是将其抛出主线程，进入就绪队列等待，而整个async函数的返回值也是一个Promise对象，具体区分以下情况123456789101112131415161718192021222324252627282930async function fn1 () &#123; // .... return 'foo'&#125;// -&gt; Promise.resolve('foo')async function fn2 () &#123; // .... &#125;// -&gt; Promise.resolve(undefined)async function fn3 () &#123; // .... return new Promise((resolve, reject) =&gt; &#123; resolve('success') &#125;)&#125;// -&gt; Promise.resolve('success')async function fn4 () &#123; // .... return new Promise((resolve, reject) =&gt; &#123; reject('fail') &#125;)&#125;// -&gt; Promise.reject('fail') 也就是说，async的作用，最后返回一个Promise对象。 awaitawait是将Promise的内容取出来的一个方式，方便我们进行异步编程的操作，他是取出Promise.resolve()的返回值，要根据需求加入try-catch来满足需求，他的操作必须在async中执行，因为要暂时抛出主线程（“暂时停止”）1234567891011121314151617181920212223242526272829// resolve的情况，也是正常的情况下function getDataSuccess () &#123; return new Promise((resolve, reject) =&gt; &#123; resolve('success') &#125;)&#125;(async () =&gt; &#123; let dataSuccess = await getDataSuccess() console.log(dataSuccess) // 输出--&gt; success&#125;)()// 如果有reject的情况，需要配合try-catchfunction getDataFail () &#123; return new Promise((resolve, reject) =&gt; &#123; reject('fail') &#125;)&#125;(async () =&gt; &#123; try &#123; let dataFail = await getDataFail() console.log(dataFail) &#125; catch (error) &#123; console.log(error) // 输出--&gt; error &#125;&#125;)() async和await搭配使用12345678910111213141516171819202122232425// 其中async的作用相当于返回了Promise.resolve( foo() ) async foo () &#123; &#125;// await的作用取出数据 await bar()new Promise(resolve =&gt; &#123; resolve( bar() )&#125;).then(val =&gt; &#123; ret = val &#125;)// 两个部分和起来相当于两块Promiseasync fn() &#123; return new Promise( ..... )&#125;let ret = await fn()...======== 等价于 =======new Promise((resolve) =&gt; &#123; resolve( Promise.resolve(fn()) )&#125;).then((val)=&gt;&#123; const v1 = val ...&#125;) 注意，由于浏览器的不同，以及运行环境的不同，可能运行顺序会略有差异 以下仅自己分析（不一定正确），可供思路参考，如有问题，欢迎指正。 12345678910111213141516171819202122232425262728async function testSometing() &#123; console.log("执行testSometing"); return "testSometing";&#125;async function testAsync() &#123; console.log("执行testAsync"); return Promise.resolve("hello async");&#125;async function test() &#123; console.log("test start..."); const v1 = await testSometing(); console.log(v1); const v2 = await testAsync(); console.log(v2); console.log(v1, v2);&#125;test();var promise = new Promise((resolve)=&gt; &#123; console.log("promise start.."); resolve("promise");&#125;);promise.then((val)=&gt; console.log(val));console.log("test end...") 执行情况一12345678910111213141 test start...2 执行testSometing3 promise start..4 test end...5 promise *6 testSometing *7 执行testAsync *8 hello async9 testSometing hello async// 这种情况是 由于await 的函数是一个async,相当于两层Promise,如上，所以他抛出线程2次，让后面的运行（较难理解一种）-&gt; async的函数Promise抛出（剩余2个） -&gt; new Promise的Promise抛出(剩余一个)-&gt; 运行栈空了,调入 -&gt;async的函数Promise抛出（剩余1个）-&gt; new Promise的Promise执行-&gt; 运行栈空了,调入 -&gt;async的函数Promise执行 执行情况二123456789101112131 test start...2 执行testSometing3 promise start..4 test end...5 testSometing *6 执行testAsync *7 promise *8 hello async9 testSometing hello async// 这种情况是把两个Promise放到一起，也是比较容易理解的一种方式-&gt; async的函数Promise抛出 -&gt; new Promise的Promise抛出-&gt; 运行栈空了,调入 -&gt; async的函数Promise执行 -&gt; new Promise的Promise执行]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由router]]></title>
    <url>%2F2019%2F07%2F05%2F%E8%B7%AF%E7%94%B1router%2F</url>
    <content type="text"><![CDATA[react-router-dom 在3.x以上使用react-router-dom,在以下使用react-router BrowseRouter VS HashRouter BrowseRouter url变换的方式，多用于服务端渲染的方式 其依靠h5的 history API 123http://www.demo.com/http://www.demo.com/personal/http://www.demo.com/personal/login/ HashRouter 使用哈西路由， 使用js构造history API， 基于history stack来完成的 123http://www.demo.com/#/http://www.demo.com/#/personal/http://www.demo.com/#/personal/login/ Router匹配规则一般情况下是都可以匹配的123456789101112131415161718192021222324252627282930313233343536373839401. http://www.demo.com/#/2. http://www.demo.com/#/user都能匹配到&lt;Route path=&quot;/&quot; component /&gt; 1. 2.&lt;Route path=&quot;/&quot; exact component /&gt; 1.// 权限校验&lt;Route path=&quot;/pay&quot; render=&#123;() =&gt; &#123; let flag = localStorage.getItem(&apos;FLAG&apos;) if (flag &amp;&amp; flag === &apos;SAFE&apos;) &#123; return &lt;Pay/&gt; &#125; return &apos;当前环境不安全，终止交易&apos;&#125;&#125;/&gt;// 使用 Switch组件只匹配一个,即匹配一个后跳出&lt;HashRouter&gt;&lt;Swtich&gt; &lt;Route path=&quot;/&quot; exact component=&#123;A&#125;/&gt; // 由于` / `匹配的太广泛，所以加一下react &lt;Route path=&quot;/user&quot; component=&#123;A&#125;/&gt; &lt;Route path=&quot;/pay&quot; component=&#123;A&#125;/&gt; &lt;Route render=&#123;() =&gt; &#123;return &apos;404&apos;&#125; &#125;/&gt; 或者 &lt;Redirect to=&apos;/&apos; /&gt;&lt;/Switch&gt;&lt;/HashRouter&gt;&lt;Router /&gt; 不设置Path是匹配所有的// 重定向&lt;Redirect to=&quot;/?lx=404&quot; /&gt;&lt;Redirect to=&#123;&#123; pathname: &apos;/&apos;, search: &apos;?/lx=404&apos;&#125;&#125; /&gt;// 如果加入了PUSH属性， 会加入到HISTORY SATCK中增添一条记录&lt;Redirect from=&apos;/custom&apos; to=&apos;/custom/list&apos; /&gt;如果请求的HASH是 &apos;/custom&apos; 那么就重定向到 &apos;/custom/list&apos; &lt;Link&gt; 与 &lt;NavLink&gt;必须都包裹在中 原理：最终都会转换成&lt;a href=&quot;#/&quot; &gt;xxx&lt;/a&gt; 使用：12345678910111213141516&lt;Link to=&apos;/&apos;&gt;&lt;/Link&gt; 普通的跳转&lt;Link to=&#123; &#123; pathname: &apos;xxx&apos;, search: &apos;xxx&apos;, state: &apos;xx&apos;&#125; &#125; &gt;&lt;/Link&gt;&lt;NavLink&gt;使用方法一样 可以点击的跳转，但是其原理是匹配hash，并不是onClick增加的active&lt;NavLink activeClass=&quot;active&quot; activeStyle&gt;一般一级路由的nav不能简单使用NavLink的点击添加active,（因为Nav已经被渲染好了，并没有因为hash的改变而重新渲染）注意：当 &lt;NavLink to=&quot;/&quot; /&gt; 时, 要使用 exact1. 解决方案1 -&gt; 将nav放到各Nav组件中（不推荐）2. 解决方案2 -&gt; 使用withRouter包起来 export default withRouter(connect()(Nav)), 只要让其通过路由管控就可以，模拟成受路由管控的组件，即可根据路由对的改变而更新 受控组件在props上增添的属性 HISTORY 基于 history stack历史信息栈 PUSH 追加一条信息 this.props.history.push(‘./plan’) GO 前往第几条 1，往后的一页， -1 往前的一页 GO-BACK &lt;=&gt; GO(-1) GO-FORWARD &lt;=&gt; GO(1) LOCATION 获取当前hash路由渲染组件信息 pathname 当前hash地址 search 当前 问号 + 传值http://www.demo.com/#/plan?lx=1 -&gt; ?lx=1 state 基于REDIRECY/LINK/NAV-LINK, 对象中设置state,即可在这获取1&lt;LINK to=&#123; &#123;pathname: 'plan', search:'', state: &#123;&#125;&#125; &#125; MATCH 获取当前路由匹配结果 PARAMS 如果匹配地址参数，路径传参才使用 传递参数 search ?id=1， 需要解析，可支持刷新，地址栏有状态 state to={ {pathname: &#39;/&#39;, state: id} }, 直接获取，地址栏无状态，但是不可刷新，可以做成支付页等 URL传递 将参数作为地址一部分 restful /detail/3 更改路由规则 &lt;Route path=&quot;/detail:id&quot; component={A}/&gt; 设置pathname to={ {pathname: &#39;/detail/${id}&#39; } } 解析 获取到match, let { match: {param} } = this.props param.id即可]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux与react-redux]]></title>
    <url>%2F2019%2F07%2F05%2Fredux%E4%B8%8Ereact-redux%2F</url>
    <content type="text"><![CDATA[Redux redux并不是为react而出，他可以运用到jQuery, vue等项目中 统一的状态管理，将所有的状态值放在一起，通过对Reducer发送dispatch来达到统一管理用户 -&gt; reducer reducer -&gt; 数据 类似一种中介者的模式 应用场景 组件之间通信 数据临时缓存(即localstore的功能)，性能优化 主要流程用户发出修改，dispatch -&gt; reducer, 接收到数据，到reducer中进行匹配查找，修改成功后，执行之前订阅过的方法 subscribe。用户在订阅事件中进行了setState,触发视图更新 主要方法 创建一个reducer 1234let reducer = (state, action) &#123; // .... action.type 为dispatch的type类型 return state // 返回最终的数据仓库&#125; 创建出数据仓库store 12import &#123; createStore &#125; from 'redux 'let store = createStore(reducer) 对需要的数据进行取出(getState) 12let &#123;getState&#125; = store// let &#123;xx&#125; = getState() 订阅事件(subscribe) 12345678let &#123; subscribe &#125; = storesubscribe(() =&gt; &#123; // .... setState() 一般调用setState可以触发render更新&#125;)// 取消订阅let unSubscribute = subscribe()unSubscribute() 触发事件(dispatch) 1234let &#123; dispatch &#125; = storedispatch(&#123; type: XXX_XXX //一般使用大写字母&#125;) react-redux是react对redux的进一步封装，让其操作更简洁 使用步骤 根组件上提供Provider,并且使用其包围起来，并传入store 1&lt;Provider store=&#123;store&#125;&gt;&lt;div&gt;....&lt;/div&gt;&lt;/Provider&gt; 构造组件为connect组件 12345678910class Head extends React.Component&#123; ... &#125;mapStateToProps = (state) =&gt; &#123; return &#123;...state.xxx &#125; &#125;mapDispatchToProps = (dispatch) =&gt; &#123; return todo () &#123;...&#125; &#125;export default connect(mapStateToProps, mapDispatchToProps)(Head)// mapStateToProps，mapDispatchToProps两个方法都是讲数据挂在到Props上// 其余均内部按照正常，到时候改编数据 = 改变状态 触发componentWillReceiveProps// 完成重新渲染，并且会根据使用的数据自动绑定subscribe上去// 即所有的state,dispatch方法从this.props上解构即可 从props上解构 1let &#123; n &#125; = this.props 注意： 使用导出的组件进行jsx语法编写 如果传入的props与redux转换后的属性冲突后，会发生覆盖 原理 ProviderProvider 仅仅是将store放入上下文路径中，为了以后可以更好使用，直接渲染子元素即可 123render () &#123; return this.props.children&#125; connect该方法最终还是渲染Conponent, 直接在render()中渲染即可 123render () &#123; return &lt;Componenet &#123;...this.state&#125; &#123;...this.props&#125;/&gt;&#125; 将所有的state，或者dispatch中函数挂在到props本质是挂载到自己的state上，方便后续setState(...) 来触发重新渲染，然而给下一层的时候，就是&lt;Component {...state}/&gt;，也即将属性传递，从而在子组件中可以直接通过this获取到 自动订阅由于他自己是以state的形式存储的，所以在ComponentDidMount中就订阅当数据发生改变，重新渲染，所以给子组件的Props改变，会触发componentWillReceiveProps, 并且接下来会触发一系列的更新事件，从而达到了自动更新的目的。 工程化目录1234567891011|-store| |-action // 总的action目录| |-personal.js| |-vote.js| |-index.js // 汇总导出 import Action .... from '.../store/action'| |-reducer // 存放reducer| |-personal.js| |-vote.js| |-index.js // 汇总导出的 import Reducer .... from '.../store/reducer'| |-action-types.js // 存放的所有action个中type类型常量 import * as TYPE from '.../store/action-types'| |-index.js // 汇总reduce 并且创建出store,导出即可 reducer个项的reducer还是以之前的方式，合并reducer考虑到重复的问题，所以进行了一层对象空间命名 12345678import &#123; combineReducers &#125; from 'redux'let reducer = combineReducers(&#123; personal, vote&#125;)// 取数据的时候let &#123; name, age &#125; = Store.getStore().personal actionaction中,返回值是之前dispatch的参数，这里只是为了统一管理，其实还是之前的原理 12345678let vote = &#123; support () &#123; return &#123; type: TYPE.VOTE_SUPPORT &#125; &#125;&#125;// 使用的时候Store.dispatch(Action.vote.support()) 中间件 使用 123import &#123; createStore, applyMiddleware &#125; from 'redux'let store = createStore(reducer, applyMiddleware(xxx中间件1，xxx中间件2...) ) redux-logger: 用于在控制台清晰显示出当前的REDUX的操作信息，以及修改后的状态信息 1直接使用，无需配置，控制台会打印出相应的操作过程 redux-thunk: 处理异步Dispatch派发任务 123456789101112addCustom (payload) &#123; return dispatch =&gt; &#123; setTimeout(() =&gt; &#123; dispatch(&#123; type: TYPE.ADD_CUSTOM, payload &#125;) &#125;, 3000) &#125;&#125;dispatch ( Action.custom.addCustom(payload) )// 原理，第一次发出 action为undefined，并将state原样返回，获取到数据，再发一次正常的 redux-promise: 处理异步Dispatch派发任务,支持promise操作 12345678910111213addCustom (payload) &#123; return &#123; type: TYPE.ADD_CUSTOM, payload: new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(payload) &#125;, 3000) &#125;) &#125;&#125;dispatch ( Action.custom.addCustom(payload) )// 原理，第一次发出正常的，当发现接收到的数据为Promise，则不进行改变state(即不存储state),// 后续完成后，再发一次正常的，并改变state]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react组件使用]]></title>
    <url>%2F2019%2F07%2F05%2Freact%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[jsx的使用 不建议将JSX直接渲染到dom中，一般都是渲染到一个DIV中（可能会频繁跟换，div比较适合） {}内是js，表达式，但是一定要存在返回值才可以，for 与 if 都不可以，不能直接放一个对象（ 除了给style赋值 除了React.element对象 一般循环创建JSX元素都是采用map方法来完成，注意使用key={}来绑定key的值 React的流程 使用Babel将JSX语法规则 解析成React.createElement(type, props, children),仅仅是形式，也就是将JSX语法表述出来，但是此时并没有执行。 React.createElement(type, props, children) 执行，创建一个虚拟DOM，主要包含一下的部分 123456&#123; type: 'xxx', // 创建的元素标签名称 props: &#123; key: value, children&#125;, // 用于标签上的属性， 并且将children放入 ref: xxx, key: xxx&#125; RenderDOM.render(obj, container, callback) 渲染这个虚拟dom 创建obj中的type -&gt; dom 元素 document.createElement() 根据属性，给dom标签上加属性，并且只循环自身属性（hasOwnProperty） 特殊属性要注意，比如className, style, 挂载dom节点到Container上， container.appendChild(dom) React申明组件的方式-基于函数 所有的组件都是以函数的方式声明出去 export default function Component (props) { ... } 要在该页面中引入 React才可以正常的使用，因为要使用React.createElement 来创建出元素 经过babel处理后，所有的属性都会以props对象的形式存在起来，所以函数的形参位置就是接受的函数 React申明组件的方式-基于组件Component 基于JSX来craeate-element来转换为对象 继承React.component并且在构造器中要调用 super 组件中关于props的使用12345678910111213141516171819202122// 1.super中传入props，因为是实例到对象上了，所以可以使用this.来进行访问constructor (props) &#123; super(props) this.props // 这里可以正常的访问到元素&#125;render ()&#123; this.props // 这里可以正常的访问到元素&#125;// 2.不传入，在constructor中是无法使用的，其他地方react做了默认关联constructor () &#123; super() this.props // 不可以访问到元素&#125;render ()&#123; this.props // 这里可以正常的访问到元素&#125; React申明组件 函数式 和 组件式异同相同点 都是通过JSX转换执行 不同点 函数式（静态组件） -&gt; 普通函数执行 其中 this为undefined 操作较简单 适合简单调取的方式 组件式 （动态组件）-&gt; 调用new来创建， 其中this为创建的虚拟元素 较为复杂 能够使用生命周期函数 能够使用一些状态来动态更新内容 组件中的状态只有基于类的组件，有状态，可以使用生命周期函数 属性只读（别人给的） 状态读写（自己设定） 模拟双向数据绑定可以在input的onchange事件中绑定setState()12345678let &#123;text&#125; = this.state&lt;input type="text" onchange=&#123;ev =&gt; &#123; this.setState(&#123; text: ev.target.value &#125;)&#125;&#125; value=&#123;text&#125; /&gt;&lt;div&gt;&#123;text&#125;&lt;/div&gt; 组件生命周期组件第一次创建的生命周期 static defaultProps{} (默认参数，非正式的第一步，需安装组件 prop-types 才可配置) 123456static defaultProps = &#123; speed: 300&#125;static propTypes = &#123; speed: PropTypes.number&#125; constructor()组件的构造函数 componentWillMount()组件挂载之间 render()渲染中 componentDidMount()组件渲染完成后，一般将请求数据放到此处 改变状态的生命周期 shouldComponentUpdate(nextProps, nextState)钩子函数，必需返回true,才能够出发更新，一般做性能优化使用 componentWillUpdate(nextProps, nextState)更新之前，此时的props, state还是之前的数据，可以理解为栈，此时还没有压栈 render渲染中 componentDidUpdate()更新完成后 传入的属性发生变化 componentWillReceiveProps(nextProps, nextState)传入的属性发生了变化，接下来执行改变状态生命周期的一系列 卸载 componentWillUnmount()该组件被卸载之前，并不是销毁，组件还在 setState() 注意改变状态的这个方法是一个异步执行的方法，一定要慎用 n: this.state.n++ 这类操作,最好使用n: this.state.n+1123456789101112131415161718this.state = &#123; n: 0&#125;console.log(this.state.n)this.setState(&#123; n: this.state.n++&#125;)console.log(this.state.n)// ======= 运行情况 (注意++ 是先赋值，后自增1)// 主线程 等待队列 1. log(0) 2. set this.state.n = 0 (此时还没到++) 3. this.state.n = 1 (此时已经给他++了) 4. log(1)执行情况 1 -&gt; 3 -&gt; 4 -&gt; 2 最终结束后 this.state.n = 0所以执行到下一个生命周期的时候，把n=0带了过去 组件之间通信属性传递 (只读)通过props进行传递，父亲给儿子， 儿子设置给孙子12345678// index&lt;Parent n=&#123;1&#125;&gt;&lt;/Parent&gt;// Parent&lt;Son n=&#123;this.props.n&#125;&gt;&lt;/Son&gt;// Son&lt;div&gt;&#123;this.props.n&#125;&lt;/div&gt; 上下文传递 (可二次修改，不影响其他组件)父组件先把需要给后代元素（包括孙子），全都设置好，后代组件需要信息，直接去调取即可（不需要儿子转递了）12345678910111213141516171819202122// ==父组件==// 设置上下文类型static childContextTypes = &#123; n: PropTypes.number, m: PropTypes.number&#125;// 向上下文传递数据getChildContext () &#123; let &#123;n, m&#125; // 得到需要放置的值 return &#123; // 传递下去 n, m &#125;&#125;// ==子组件==// 子组件需要主动接受的信息static contextTypes = &#123; n: PropTypes.number&#125;console.log(this.context.n)]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式总结]]></title>
    <url>%2F2019%2F06%2F25%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[单例设计模式js中由于没有类的概念，所以单例不需要特别设计，只要保证一个引用即可，但是保存到全局对象又容易造成污染，所以要结合闭包。注意：对象创建与单例的管理要分开。 策略模式将算法的使用 与 算法的设计 分离开， 可以看成可变的函数调用主要是解决if else分支过多的问题 代理模式客户不方便直接访问某个对象的时候，提供一个对象来控制对这个对象的访问， 客户 -&gt; 代理 -&gt; 本体虚拟代理 代理对象和实体之间应该是一致的，方便调用或者替换缓存代理 访问某个对象之前，通过闭包看一下之前有没有缓存过，没有则执行并放入缓存 return cache[args] = fn() 迭代器模式将迭代的过程抽离开，只关心最后的结果，并不关心迭代的过程内部迭代器 调用方便，更适合看结果，js已经实现了内部迭代器forEach外部迭代器 需要手动控制迭代过程，可自定义化比较高 （数据库resultMap类似，.next() 下一位） 发布-订阅（观察者） 模式将 多个订阅者 放到 一个发布者存储起来（尤其是对多个事件的异步执行），当这个发布者发布对象的时候，会调用其所有订阅者的方法执行，订阅者只需要按照规定订阅其发布者规定的方法即可，主要是事件的解耦，类似dom中的事件绑定 命令模式这里主要是针对绑定事件的解耦性， 将 onclick = function () { xxx } 分离开，变成约定好的固定模式,用了一个第三者 （命令者）连接了起来， 做到了解耦性onclick = commandObj.execute() + commandObj.execute = function () { xxx } 注意：命令模式中的：”聪明模式”由于没有receiver，从代码结构上与 策略模式 接近，但是从用途上区分他们命令模式，范围广，对什么执行什么命令策略模式，指定范围，采用什么样的方法解决 “傻瓜模式”： 由receiver做execute,所以命令其实啥都不知道，就是得到命令，调execute“聪明模式”： 直接在command中执行功能，不做转接，中间层直接执行代码 组合模式树形结构，只需要对树根发出指令，便会依此遍历所有的叶子方法的execute,是在命令模式的宏命令中延申而来类似一个深度遍历， 如果是组合节点-&gt; 遍历执行所有的叶节点的 execute, 如果是叶子节点，直接执行其代码即可 模板方法模式算法的框架由模板定义好，子类只需要按照一定的规则去实现一些细节的实现即可，有点类似于与java中的抽象类，接口类他是一种原型继承的方式 享元模式区分外部状态与内部状态其实就是找出变化的和不变化的，精髓是创建一个对象，依次改变其内部的属性，是一种典型的 以时间换空间的例子， 对象池也类似享元模式虽然没有体现状态分离，但是有共享的体现 职责链模式用来简化if else的相关操作，每个方法只需要处理自己的那一片，处理不了就往后抛，直到有相应的职责者可以处理即可。一般用字符串&#39;nextSuccessor&#39;表示传递给下一个职责对象，或者手动调用下去一般最后一个链都要放一个接锅侠，要不就被放走了 中介者模式对象之间的引用过于复杂的时候，通常可以引入中介者，将每个人的关系都扯到中介者身上，这样会减少对象之间关系维护的困扰，但是所有的关系都是由中介者来维护的，中介者一般会较大，处理逻辑较为复杂，但是其他类都是类似透明的，所有关系都有中介者来维护，类之间是不知道自己是否与别人有关联(导致本身的关联不被关注)，折中使用只需要维护中介者 就完成了类之间的关系维护 装饰者模式主要是为了在不改动原函数的情况下，进行拓展，最主要的运用是在函数之前.before，函数之后.after使用了AOP编程的思想，让功能之间的耦合度下降，并且装配性变强，可以根据不同的需求去装配不同的功能 注意：（两者代码结构相似，但是要从目的来进行区分）装饰者模式： 通常会添加一连串的装饰者，给他拓展之外的一些功能。代理模式： 通常只有一个代理对象，而他的目的是增强原有的功能 状态模式根据不同的场景来解决不同的问题，主要是在不同状态下表现出的方法不一样，将各个事件绑定到状态中定义且切换状态的方式，省去了大部分if else 的逻辑结构,其实就是鸭子类型，进行替换调这个替换对象中的方法 适配器模式主要是在不改动原有代码的情况下 进行修改，在代码的编写阶段是不会有的，肯定是在对接老项目的时候，修改了某些接口，从而进行变通的一种方式，或是为了兼容其他的API,或者是做方法之间的转换的 总结JavaScript中的设计模式，很多都是采用了高阶函数的一种变形， 其中大量充斥着闭包的概念很多设计模式看似相同，结构也是大部分一样的，但是主要是思想上的不同，他们所针对，所解决的问题不一致而不能单单从形式结构上区分它们，以及JavaScript是没有类的概念的，所以需要灵活的使用鸭子模式来达到不同的设计]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14适配器模式]]></title>
    <url>%2F2019%2F06%2F25%2F14%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* 适配器模式 主要是为了适配之前的功能， 或者是为了在不修改代码的情况下 进行不同接口之间的通信 */// 第三方接口不同var googleMap = &#123; show: function () &#123; console.log('开始渲染谷歌地图') &#125;&#125;var baiduMap = &#123; show: function () &#123; console.log('开始渲染百度地图') &#125;&#125;var renderMap = function (map) &#123; if (map.show instanceof Function) &#123; map.show() &#125;&#125;renderMap(googleMap)renderMap(baiduMap)var tencentMap = &#123; display: function () &#123; console.log('开始渲染腾讯地图') &#125;&#125;// 此时需要一个tencent地图的适配器var tencentMapAdapter = &#123; show: function () &#123; return tencentMap.display() &#125;&#125;renderMap(tencentMap)renderMap(tencentMapAdapter)// 需要的类型不一样var getCity = function () &#123; var city = [ &#123;name: 'Lanzhou',id: '11'&#125;, &#123;name: 'Hangzhou',id: '12'&#125; ] return city&#125;console.log(getCity())/*0: Object &#123; name: "Lanzhou", id: "11" &#125;1: Object &#123; name: "Hangzhou", id: "12" &#125;*/// 现在需求需要这样的格式 &#123;11: 'Lanzhou', 12: 'Hangzhou'&#125;// 再不改动原有代码的情况下 只能使用适配器var cityAddressAdapter = function (oldAddressfn) &#123; var address = &#123;&#125;, oldAddress = oldAddressfn() for(var i = 0, c; c = oldAddress[i++]; ) &#123; address[c.id] = c.name &#125; return function () &#123; return address &#125;&#125;getCity = cityAddressAdapter(getCity)console.log( getCity() )]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13状态模式]]></title>
    <url>%2F2019%2F06%2F25%2F13%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/* 状态模式， 在不同的状态下面 动态的为不同的事件绑定不同的方法， 这里模拟 电灯开关的例子， 关灯状态 按钮作用 - 开灯 开灯状态 按钮作用 - 关灯 */// 不适用状态模式 耦合性比较高，各种状态耦合在一起var Light = function () &#123; this.state = 'off' this.button = null&#125;Light.prototype.init = function () &#123; var button = document.createElement('button'), self = this button.innerHTML = '开关' this.button = document.body.appendChild( button ) this.button.onclick = function () &#123; self.buttonWasPressed() &#125;&#125;Light.prototype.buttonWasPressed = function () &#123; if (this.state === 'on') &#123; console.log('关灯') this.state = 'off' &#125; else if (this.state === 'off') &#123; console.log('开灯') this.state = 'on' &#125;&#125;var light = new Light()light.init()// 传统模拟类的一种写法 状态模式 对象方法语言中的实现// offLightStatevar OffLightState = function (light) &#123; this.light = light&#125;OffLightState.prototype.buttonWasPressed = function () &#123; console.log('弱光') // offLightState对应行为 this.light.setState(this.light.weakLightState)&#125;// WeakLightStatevar WeakLightState = function (light) &#123; this.light = light&#125;WeakLightState.prototype.buttonWasPressed = function () &#123; console.log('强光') // WeakLightState对应行为 this.light.setState(this.light.strongLightState)&#125;// StrongLightStatevar StrongLightState = function (light) &#123; this.light = light&#125;StrongLightState.prototype.buttonWasPressed = function () &#123; console.log('关灯') // StrongLightState对应行为 this.light.setState(this.light.offLightState)&#125;var Light = function () &#123; this.offLightState = new OffLightState(this) this.weakLightState = new WeakLightState(this) this.strongLightState = new StrongLightState(this) this.button = null&#125;Light.prototype.init = function () &#123; var button = document.createElement('button'), self = this this.button = document.body.appendChild(button) this.button.innerHTML = '开关类的状态机' this.currentState = this.offLightState // 设置初始化关灯的状态 this.button.onclick = function () &#123; self.currentState.buttonWasPressed() &#125;&#125;Light.prototype.setState = function ( newState ) &#123; this.currentState = newState&#125;var light = new Light()light.init()// javascript 版本的状态机 FSM Finite State Machine 有限状态机var Light = function () &#123; this.currentState = FSM.off this.button = null&#125;Light.prototype.init = function () &#123; var button = document.createElement('button'), self = this button.innerHTML = '开关灯FSM实现模式' this.button = document.body.appendChild(button) this.button.onclick = function () &#123; self.currentState.buttonWasPressed.call(self) &#125;&#125;var FSM = &#123; off: &#123; buttonWasPressed: function () &#123; console.log('开灯') this.button.innerHTML = '下一次关灯' this.currentState = FSM.on &#125; &#125;, on: &#123; buttonWasPressed: function () &#123; console.log('关灯') this.button.innerHTML = '下一次开灯' this.currentState = FSM.off &#125; &#125;&#125;var light = new Light()light.init()// 如果有修改 只需呀在状态机中修改即可,不用改动原始的代码]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12装饰者模式]]></title>
    <url>%2F2019%2F06%2F25%2F12%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183/* 装饰者模式，通常使用一连串的对象来为其增强功能， 其优点 就是 在不改动源码的情况下进行增加 导弹发射的例子 */var plane = &#123; fire: function () &#123; console.log('发射子弹 biu~') &#125;&#125;plane.fire()var missileDecorator = function () &#123; console.log('发射导弹')&#125;var fire1 = plane.fireplane.fire = function () &#123; fire1() missileDecorator()&#125;plane.fire()var atomDecorator = function () &#123; console.log('发射原子弹')&#125;var fire2 = plane.fireplane.fire = function () &#123; fire2() atomDecorator()&#125;plane.fire()/* 装饰函数 在不改变原有函数的前提下，进行对函数功能的扩充，注意原this指向的问题，所以要使用apply的方式 */// 普通模式 不考虑this的问题var a = function () &#123; console.log('1')&#125;var _a = aa = function () &#123; _a() console.log('2')&#125;a()// 考虑this指向的 如 document.getElementById// 使用AOP进行装饰Function.prototype.before = function (beforefn) &#123; var __self = this return function () &#123; beforefn.apply(this, arguments) return __self.apply(this, arguments) &#125;&#125;Function.prototype.after = function (afterfn) &#123; var __self = this return function () &#123; var ret = __self.apply(this, arguments) afterfn.apply(this, arguments) return ret &#125;&#125;console.log('===========================')window.onload = (window.onload || function () &#123; &#125;).after(function () &#123; console.log('2')&#125;).after(function () &#123; console.log('3')&#125;).after(function () &#123; console.log('4')&#125;)window.onload = (window.onload || function () &#123; &#125;).before(function () &#123; console.log('1')&#125;)// 还可以使用此特性改变参数var func = function (param) &#123; console.log(param) // &#123; a: "a", b: "b" &#125;&#125;func = func.before(function (param) &#123; param.b = 'b'&#125;)func(&#123; a: 'a' &#125;)/* 结合AOP做请求加token */var ajax = function (type, url, param) &#123; console.log(param) // todo.....省略这里&#125;ajax('GET', 'api.com/userinfo', &#123; name: 'zhn' &#125;)// 配置一个获取token的方法 用来校验apivar getToken = function () &#123; return 'Token'&#125;// 最基本的思想就是 硬编码到内部， 不利于拓展， 不利于后续的维护var ajax = function (type, url, param) &#123; param = param || &#123;&#125; param.token = getToken() console.log(param) // todo.....省略这里&#125;ajax('GET', 'api.com/userinfo', &#123; name: 'zhn' &#125;)// 这里使用AOP的思想 加入装饰模式 Function.prototype.befor = function (beforefn) &#123; var __self = this return function () &#123; beforefn.apply(this, arguments) return __self.apply(this, arguments) &#125;&#125;ajax = ajax.before(function (type, url, param) &#123; param.token = getToken()&#125;)ajax('GET', 'api.com/userinfo', &#123; name: 'zhn' &#125;)/* 表单验证方式 基于AOP思想,及时迁移了项目，或是改变环境，可以随时取消验证，取消before(validate) 即可，重新绑定一个空函数 通常表单提交会将 校验方法 和 提交ajax方法配到一起，但是这样会显得很臃肿，表单提交只应该包含一个提交 对于表单的校验功能，应该作为一个装饰者，来切入到提交之前 */// 之前的模式/* validata = function () &#123; // xxxxxx 一大堆验证逻辑 &#125; ajax('GET', 'api.com/userinfo', &#123; name: 'zhn' &#125;)*/// 使用AOP进行优化 如果验证的方式 为 false 则阻止提交Function.prototype.before = function (beforefn) &#123; var __self = this return function () &#123; if (beforefn.apply(this, arguments) === false) &#123; // 先前约定的逻辑 返回false直接阻止提交，不执行后面的函数 return &#125; return __self.apply(this, arguments) &#125;&#125;var username = document.getElementById('username')var password = document.getElementById('password')var validata = function () &#123; if (username.value === '') &#123; console.log('用户名不能为空') return false &#125; if (password.value === '') &#123; console.log('密码不能为空') return false &#125; &#125;var submit = function () &#123; var param = &#123; username: username.value, password: password.value &#125; ajax('GET', 'api.com/userinfo', &#123; name: 'zhn' &#125;)&#125;submit = submit.before(validata) // 提前把检验函数 以AOP的形式放进去// submit()]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11中介者模式]]></title>
    <url>%2F2019%2F06%2F25%2F11%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/* 中介者模式， 所有类之间的关系都有 一个中介者统一维护， 减少了类与类之间的关联， 这种关系要折中的考虑，如果类之间的关系都取消，等到类多了基本的关联可能都会丢失，中介者会越来越复杂 例子，统一一处的修改，改变所有的位置 并且要 选择颜色， 选择数量， 在最后的按钮上做提示信息 */var colortSelect = document.getElementById('colorSelect')var numberInput = document.getElementById('numberInput')var colorInfo = document.getElementById('colorInfo')var numberInfo = document.getElementById('numberInfo')var nextBtn = document.getElementById('nextBtn')// 传统方式 要对colorSelect numberInput 依次绑定事件,其核心业务代码可能是相同的var goods = &#123; "red": 3, "blue": 6&#125;/* 颜色框的逻辑 *//*colortSelect.onchange = function () &#123; var color = this.value, number = numberInput.value, stock = goods[color] colorInfo.innerHTML = color if (!color) &#123; nextBtn.disabled = true nextBtn.innerHTML = "请选择手机颜色" return &#125; if (!/^[1-9]\d*$/.test(number)) &#123; // 判断非正整数 nextBtn.disabled = true nextBtn.innerHTML = "请输入正确的购买数量" return &#125; if (number &gt; stock) &#123; nextBtn.disabled = true nextBtn.innerHTML = "库存不足" return &#125; nextBtn.disabled = false nextBtn.innerHTML = "加入购物车"&#125;*//* 输入框的逻辑 *//*numberInput.oninput = function () &#123; var number = this.value, color = colortSelect.value, stock = goods[color] colorInfo.innerHTML = color numberInfo.innerHTML = number if (!color) &#123; nextBtn.disabled = true nextBtn.innerHTML = "请选择手机颜色" return &#125; if (!/^[1-9]\d*$/.test(number)) &#123; // 判断非正整数 nextBtn.disabled = true nextBtn.innerHTML = "请输入正确的购买数量" return &#125; if (number &gt; stock) &#123; nextBtn.disabled = true nextBtn.innerHTML = "库存不足" return &#125; nextBtn.disabled = false nextBtn.innerHTML = "加入购物车"&#125;*//* 虽然可以把相同的代码抽离出来，可是如果要拓展，或者是加入其它的私有逻辑 要求修改代码，不符合开闭原则， 所以使用一个中介者管理他们 *//* 中介者 */var mediator = (function () &#123; var colortSelect = document.getElementById('colorSelect'), numberInput = document.getElementById('numberInput'), colorInfo = document.getElementById('colorInfo'), numberInfo = document.getElementById('numberInfo'), nextBtn = document.getElementById('nextBtn') return &#123; changed: function (obj) &#123; // obj是哪一个对象改变了 var color = colortSelect.value, number = numberInput.value, stock = goods[color] if (obj === colortSelect) &#123; // colorSelect 发生改变 colorInfo.innerHTML = color &#125; else if (obj === numberInput) &#123; numberInfo.innerHTML = number &#125; if (!color) &#123; nextBtn.disabled = true nextBtn.innerHTML = "请选择手机颜色" return &#125; if (!/^[1-9]\d*$/.test(number)) &#123; // 判断非正整数 nextBtn.disabled = true nextBtn.innerHTML = "请输入正确的购买数量" return &#125; if (number &gt; stock) &#123; nextBtn.disabled = true nextBtn.innerHTML = "库存不足" return &#125; nextBtn.disabled = false nextBtn.innerHTML = '放入购物车' &#125; &#125;&#125;)()// 事件函数colortSelect.onchange = function () &#123; mediator.changed(this)&#125;numberInput.oninput = function () &#123; mediator.changed(this)&#125;/* 颜色框和输入框 完全不知道对方的存在， 由于逻辑都是放在中介者当中的， 所以去掉其他类对整体没什么影响 虽然功能之间的耦合减少了， 但由于把逻辑内聚到中介者，业务上没有体现出来 颜色 和 数量 之间的关系 拓展性， 只需要在中介者增加拓展的代码， 即可 *//*var mediator = (function ()&#123; var memorySelect = document.getElementById('memorySelect') return &#123; changed: function (obj) &#123; var memory = memorySelect.value // .... 相关逻辑 if (obj === memorySelect) &#123; memoryInfo.innerHTML = memory &#125; &#125; &#125;&#125;)()*/]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10职责链模式]]></title>
    <url>%2F2019%2F06%2F25%2F10%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191/* 职责链模式，用于传递对象，依次拆分，是自己解决的类型就解决，否则就传递下去，交给别人解决 主要是避免了繁琐的 if else 结构， 整个代码看起来结构比较清晰，组织比较明确。 例子，使用优惠券 交了500定金， 100 优惠券 交了200定金 50 优惠券 没交定金/定金没有付款 没有优惠券 */// 之前使用if elsevar order = function ( orderType, pay, stock ) &#123; if (orderType === 1) &#123; // 100优惠券 if ( pay === true) &#123; // 付定金 console.log('得到100优惠券') &#125;else&#123; if (stock &gt; 0) &#123; console.log('普通购买') &#125; else &#123; console.log('手机没有库存') &#125; &#125; &#125; else if (orderType === 2) &#123; // 50优惠券 if ( pay === true) &#123; // 付定金 console.log('得到50优惠券') &#125;else&#123; if (stock &gt; 0) &#123; console.log('普通购买') &#125; else &#123; console.log('手机没有库存') &#125; &#125; &#125; else &#123; // 没有优惠券 if (stock &gt; 0) &#123; console.log('普通购买') &#125; else &#123; console.log('手机没有库存') &#125; &#125;&#125;order(1, true, 10)order(1, false, 10)// 职责链过渡代码var order500 = function ( orderType, pay, stock ) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500元定金预购，得到100优惠券') &#125; else &#123; // 处理不了全丢给下一个 order200( orderType, pay, stock ) &#125;&#125;var order200 = function ( orderType, pay, stock ) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200元定金预购，得到50优惠券') &#125; else &#123; // 处理不了全丢给下一个 orderNormal( orderType, pay, stock ) &#125;&#125;var orderNormal = function ( orderType, pay, stock ) &#123; if (stock &gt; 0) &#123; console.log('正常购买') &#125; else &#123; // 处理不了全丢给下一个 console.log('库存不足') &#125;&#125;order500(1, true, 10)order500(1, false, 10)// 以上代码存在耦合性比较大, 解耦var Chain = function ( fn ) &#123; this.fn = fn this.successor = null&#125;Chain.prototype.setNextSuccessor = function (successor) &#123; return this.successor = successor&#125;Chain.prototype.passRequest = function () &#123; var ret = this.fn.apply(this, arguments) if (ret === 'nextSuccessor') &#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments) &#125; return ret&#125;var order500 = function ( orderType, pay, stock ) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500元定金预购，得到100优惠券') &#125; else &#123; // 处理不了全丢给下一个 return 'nextSuccessor' &#125;&#125;var order200 = function ( orderType, pay, stock ) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200元定金预购，得到50优惠券') &#125; else &#123; // 处理不了全丢给下一个 return 'nextSuccessor' &#125;&#125;var orderNormal = function ( orderType, pay, stock ) &#123; if (stock &gt; 0) &#123; console.log('正常购买') &#125; else &#123; // 处理不了全丢给下一个 console.log('库存不足') &#125;&#125;var chainOrder500 = new Chain(order500)var chainOrder200 = new Chain(order200)var chainOrderNormal = new Chain(orderNormal)chainOrder500.setNextSuccessor(chainOrder200)chainOrder200.setNextSuccessor(chainOrderNormal)chainOrder500.passRequest(1, true, 10)chainOrder500.passRequest(1, false, 10)// js AOP的思想写法 类似永远先执行他自己，如果返回是retSuccessor就再调用他后面的函数Function.prototype.after = function (fn) &#123; var self = this return function () &#123; var ret = self.apply(this, arguments) if (ret === 'nextSuccessor') &#123; return fn.apply(this, arguments) &#125; &#125;&#125;var order500 = function ( orderType, pay, stock ) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500元定金预购，得到100优惠券') &#125; else &#123; // 处理不了全丢给下一个 return 'nextSuccessor' &#125;&#125;var order200 = function ( orderType, pay, stock ) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200元定金预购，得到50优惠券') &#125; else &#123; // 处理不了全丢给下一个 return 'nextSuccessor' &#125;&#125;var orderNormal = function ( orderType, pay, stock ) &#123; if (stock &gt; 0) &#123; console.log('正常购买') &#125; else &#123; // 处理不了全丢给下一个 console.log('库存不足') &#125;&#125;var order = order500.after(order200).after(orderNormal)order(1, true, 10)order(1, false, 10)/* 文件上传案例 重构之前迭代器模式，这里使用职责链模式更好一些 一般职责链最后要有一个接锅侠 */var getActiveObj = function () &#123; try&#123; return new ActiveXObject('TXFTNActiveX.FTNUpload') &#125;catch(e)&#123; return 'nextSuccessor' &#125;&#125;var getFlashUplaodObj = function () &#123;// if ( supportFlash() ) &#123; // 模拟支持插件// var str = '&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;'// return $(str).appendTo( $('body') )// &#125; return 'nextSuccessor'&#125;var getFormUploadObj = function () &#123; return str = '&lt;input name="File" type="File"&gt;&lt;/input&gt;'&#125;Function.prototype.after = function (fn) &#123; // 与之前一样 var self = this return function () &#123; var ret = self.apply(this, arguments) if (ret === 'nextSuccessor') &#123; return fn.apply(this, arguments) &#125; &#125;&#125;var getUploadObj = getActiveObj.after(getFlashUplaodObj).after(getFormUploadObj)console.log(getUploadObj())]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09享元模式]]></title>
    <url>%2F2019%2F06%2F25%2F09%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196/* 享元模式 flyweight,将相似的部分抽取出来复用，但是会牺牲时间为代价（替换属性所花费的一些时间） 移动端浏览器 通常分配的内存不够多，如果创建了大量的对象，很有可能会崩溃 最主要的就是 找到内部状态 和 外部状态 内部状态： 每一个元的本质区别 外部状态： 可以将不同的属性给这个元，派生出多个对象， 一张卷子，其题目就是内部状态，每个人的考生信息与答案就像外部状态，用这个外部状态可以生成全班所有人的考卷 ，而卷子始终都是一张（这里假设卷子是班级共用一张，大家写在各自答题卡上（外部状态上）） 模特拍照的例子 现在有50件男装，50件女装 依次模特展示拍照 */// 不使用享元模式， 对象爆炸, 这里50个男模特，50个女模特是一种浪费var Model = function (sex, underwear) &#123; this.sex = sex this.underwear = underwear&#125;Model.prototype.takePhoto = function () &#123; console.log('sex: ' + this.sex + ' underwear: ' + this.underwear)&#125;// 男模特拍照for (var i = 0; i &lt; 50; i++) &#123; var maleModel = new Model('male', 'underwear' + i) maleModel.takePhoto()&#125;// 女模特拍照for (var i = 0; i &lt; 50; i++) &#123; var femaleModel = new Model('female', 'underwear' + i) femaleModel.takePhoto()&#125;// 使用享元模式，不停修改模特的属性即可,只需要根据性别 创建两个模特即可var Model = function (sex) &#123; this.sex = sex&#125;Model.prototype.takePhoto = function () &#123; console.log('sex: ' + this.sex + ' underwear: ' + this.underwear)&#125;var maleModel = new Model('male'), femaleModel = new Model('female') // 男模特拍照for (var i = 0; i &lt; 50; i++) &#123; maleModel.underwear = 'underwear' + i maleModel.takePhoto()&#125;// 女模特拍照for (var i = 0; i &lt; 50; i++) &#123; femaleModel.underwear = 'underwear' + i femaleModel.takePhoto()&#125;/* 文件上传的例子， 根据上传控件的不同，使用不同的创建方式 */// 工厂对象实例化,创建 元 的地方, 很像单例模式var Upload = function (uploadType) &#123; this.uploadType = uploadType&#125;var UploadFactory = (function ()&#123; var createdFlyWeightObjs = &#123;&#125; return &#123; create: function (uploadType) &#123; // 内部状态是控件类型 （html5上传，还是falsh上传） if (createdFlyWeightObjs[uploadType]) &#123; return createdFlyWeightObjs[uploadType] &#125; return createdFlyWeightObjs[uploadType] = new Upload(uploadType) &#125; &#125;&#125;)()// 外部状态管理器,保存所有的外部状态var uploadManager = (function () &#123; var uploadDatabase = &#123;&#125; return &#123; add: function (id, uploadType, fileName, fileSize) &#123; // 增加一个外部状态 var flyweightObj = UploadFactory.create(uploadType) // ... 相关操作 uploadDatabase[id] = &#123; fileName, fileSize &#125; return flyweightObj &#125;, setExternalState: function (id, flyweightObj) &#123; // 设置当前的元的外部状态 var uploadData = uploadDatabase[id] for (var key in uploadData) &#123; flyweightObj[key] = uploadData[key] &#125; &#125; &#125;&#125;)()var startUpload = function (uploadType, files) &#123; for (var i = 0, file; file = files[i++]; ) &#123; var uploadObj = uploadManager.add(file.id, uploadType, file.fileName, file.fileSize) &#125; // 让uploadDatabase中批量上传 marcoUpload&#125;// 上传文件startUpload('plugin', [ &#123; id: 1, fileName: '1.txt', fileSize: 1000 &#125;, &#123; id: 2, fileName: '2.txt', fileSize: 2000 &#125;])startUpload('flash', [ &#123; id: 4, fileName: '4.txt', fileSize: 4000 &#125;, &#123; id: 5, fileName: '5.txt', fileSize: 5000 &#125;])// 当然如果要修改状态，比如添加每个文件后还要进行一些其他操作var add = function (id, uploadType, fileName, fileSize) &#123; // 增加一个外部状态 var flyweightObj = UploadFactory.create(uploadType) // ... 相关操作 uploadDatabase[id] = &#123; fileName, fileSize &#125; // 获取这个文件的完全对象 var dom = &#123;&#125; dom.onclick = function () &#123; flyweightObj.todo(id) // todo这个方法是定义到Upload 即原来的 元 对象上, 这里的方法应该是个事件 &#125; return flyweightObj&#125;Upload.prototype.todo = function (id) &#123; uploadManager.setExternalState(id, this) // 此时的this就是占用元对象的所有属性， 是一个完整的上传对象 // this.xxxxxx&#125;/* 享元模式对象池的应用 获取 和 归还都是去对象池中 */var objectPoolFactory = function (createObjFn) &#123; var objectPool = [] return &#123; create: function () &#123; // 取出一个 // 如果对象池中有 就拿出去一个， 否则就创建一个 var obj = objectPool.length === 0 ? createObjFn.apply(this, arguments) : objectPool.shift() return obj &#125;, recover: function (obj) &#123; // 归还一个 objectPool.push(obj) &#125; &#125;&#125;// 现在创建一个ifram的对象池var iframeFactory = objectPoolFactory(function () &#123; var iframe = document.createElement('iframe') document.body.appendChild(iframe) iframe.onload = function () &#123; iframe.onload = null // 防止iframe重复加载 iframeFactory.recover(iframe) &#125; return iframe&#125;)var iframe1 = iframeFactory.create()iframe1.src = 'https://www.baidu.com'var iframe2 = iframeFactory.create()iframe2.src = 'https://www.aliyun.com'var timer = setTimeout(function ()&#123; var iframe3 = iframeFactory.create() iframe3.src = 'https://im.qq.com'&#125;, 10000)// 如果10s后之前的网站有加载完毕的，就改变原有的，否则就创建一个iframe]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08模板方法模式]]></title>
    <url>%2F2019%2F06%2F25%2F08%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* 模板方法设计模式 将算法的框架与顺序以及一些不变的过程摆放在一起，其子类只需要实现其细节即可 Coffee or Tea 例子 冲咖啡： 把水煮沸 用沸水冲泡咖啡 把咖啡倒进屋子 加糖和牛奶 泡茶： 把水煮沸 用沸水浸泡茶叶 把茶水倒进杯子 加柠檬 */// 抽象出一个饮料的概念var Beverage = function () &#123;&#125;Beverage.prototype.boilWate = function () &#123; console.log('把水煮沸')&#125;Beverage.prototype.brew = function () &#123;&#125;Beverage.prototype.pourInCup = function () &#123;&#125;Beverage.prototype.addCondiments = function () &#123;&#125;Beverage.prototype.init = function () &#123; this.boilWate() this.brew() this.pourInCup() this.addCondiments()&#125;// 咖啡var Coffee = function () &#123;&#125;Coffee.prototype = new Beverage()Coffee.prototype.brew = function () &#123; console.log('沸水冲泡咖啡')&#125;Coffee.prototype.pourInCup = function () &#123; console.log('把咖啡倒进杯子')&#125;Coffee.prototype.addCondiments = function () &#123; console.log('加糖和牛奶')&#125;var coffee = new Coffee()coffee.init()/* 也可以使用传递对象的方式 然而这种方式是使用闭包的方式，创建后无法修改，因为找不到相应的方法，都是封装在函数里 */var Beverage = function (param) &#123; var boilWate = function () &#123; console.log('把水煮沸') &#125; var brew = param.brew || function () &#123; throw new Error('必须传递 brew 方法') &#125; var pourInCup = param.pourInCup || function () &#123; throw new Error('必须传递 pourInCup 方法') &#125; var addCondiments = param.addCondiments || function () &#123; throw new Error('必须传递 addCondiments 方法') &#125; var F = function () &#123;&#125; F.prototype.init = function () &#123; boilWate() brew() pourInCup() addCondiments() &#125; return F&#125;var Coffee = Beverage(&#123; brew: function () &#123; console.log('用水冲泡咖啡') &#125;, pourInCup: function () &#123; console.log('把咖啡倒进杯子') &#125;, addCondiments: function () &#123; console.log('加糖和牛奶') &#125;&#125;)var coffee = new Coffee()coffee.init()/* 拓展 这种回调的方式，称为 好莱坞方式，你只需要把函数给我， 什么时候执行我说了算，啥时候调也是我说了算 可以添加一些钩子函数，用来控制模板中的方法是否需要执行 */Coffee.prototype.pourInCup = function () &#123; if (this.customerWantsCondiments()) &#123; this.addCondiments() &#125;&#125;Coffee.prototype.customerWantsCondiments = function () &#123; return window.confirm('是否需要添加调料')&#125;]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07组合模式]]></title>
    <url>%2F2019%2F06%2F25%2F07%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/* 组合模式 更加强大的 宏命令,其优点是可以一次性的执行方法不需要if else 判断哪些要执行，哪些要遍历 打开空调 打开电视机和音响 关门，开电脑，登录QQ */var MacroCommand = function () &#123; // 宏命令 也即组合模式的根节点 return &#123; commandList: [], add: function (command) &#123; this.commandList.push(command) &#125;, execute: function () &#123; for (var i = 0, command; command = this.commandList[i++]; ) &#123; command.execute() &#125; &#125; &#125;&#125;/* 打开空调指令 */var openAcCommand = &#123; execute: function () &#123; console.log('打开空调') &#125;&#125;/* 打开电视机和音响指令 */var openTVCommand = &#123; execute: function () &#123; console.log('打开电视机') &#125;&#125;var openSoundCommand = &#123; execute: function () &#123; console.log('打开音响') &#125;&#125;// 组合命令var macroCommand1 = MacroCommand()macroCommand1.add(openTVCommand)macroCommand1.add(openSoundCommand)/* 关门，开电脑，登录QQ指令 */var closeDoorCommand = &#123; execute: function () &#123; console.log('关门') &#125;&#125;var openPCCommand = &#123; execute: function () &#123; console.log('打开电脑') &#125;&#125;var openQQCommand = &#123; execute: function () &#123; console.log('打开QQ') &#125;&#125;// 组合命令var macroCommand2 = MacroCommand()macroCommand2.add(closeDoorCommand)macroCommand2.add(openPCCommand)macroCommand2.add(openQQCommand)/* 组合三个事件 */var macroCommand = MacroCommand()macroCommand.add(openAcCommand)macroCommand.add(macroCommand1)macroCommand.add(macroCommand2)// 执行命令macroCommand.execute()/* 由于其执行的透明性的原因 很有可能会误对叶子节点 调用add,此时可以抛出相应的异常来解决 */var openAcCommand = &#123; execute: function () &#123; console.log('打开空调') &#125;, add: function () &#123; throw new Error('叶子对象不能再添加子节点') &#125;&#125;/* 使用命令模式模拟一个 扫描文件夹的实例 */var Folder = function (name) &#123; this.name = name this.files = []&#125;Folder.prototype.add = function (file) &#123; this.files.push(file) &#125;Folder.prototype.scan = function () &#123; console.log('开始扫描文件夹: ' + this.name) for (var i = 0, file; file = this.files[i++]; ) &#123; file.scan() &#125;&#125;var File = function (name) &#123; this.name = name&#125;File.prototype.add = function () &#123; throw new Error('文件下面不能再添加文件')&#125;File.prototype.scan = function () &#123; console.log('开始扫描文件: ' + this.name)&#125;var folder = new Folder('学习资料')var folder1 = new Folder('JavaScript')var folder2 = new Folder('jQuery')var file1 = new File('JavaSccript设计模式')var file2 = new File('精通jQuery')var file3 = new File('重构与模式')folder1.add(file1)folder2.add(file2)folder.add(folder1)folder.add(folder2)folder.add(file3)folder.scan()/* 增加父节点，就可以做到组合模式的删除 */var Folder = function (name) &#123; this.name = name this.parent = null this.files = []&#125;Folder.prototype.add = function (file) &#123; file.parent = this this.files.push(file)&#125;var File = function (name) &#123; this.name = name this.parent = null&#125;// 当做删除的时候File.prototype.remove = Folder.prototype.remove = function () &#123; if (!this.parent) &#123; return &#125; for (var files = this.parent.files, l = files.length; l &gt;= 0; l--) &#123; var file = files[i] if (file = this) &#123; files.splice(l, 1) &#125; &#125;&#125;]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06命令模式]]></title>
    <url>%2F2019%2F06%2F25%2F06%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* 命令模式 模拟给按钮绑定一个刷新事件 */// 真实刷新逻辑 var MenuBar = &#123; refresh: function () &#123; console.log('刷新了页面') &#125;&#125;// 刷新命令 (中间商命令者)var RefreshMenuBarCommand = function ( recevier ) &#123; return &#123; execute: function () &#123; recevier.refresh() &#125; &#125;&#125;// 设置命令var setCommand = function ( button, command) &#123; button.onclick = function () &#123; command.execute() &#125;&#125;var button1 = &#123;&#125; // 这里模拟button1按钮var refreshMenuBarCommand = RefreshMenuBarCommand ( MenuBar ) // 获取命令setCommand( button1, refreshMenuBarCommand)/* 宏命令，可以执行一批命令，就是把命令放入数组中，一批执行 关门 -&gt; 打开电脑 -&gt; 登录QQ */var closeDoorCommand = &#123; execute: function () &#123; console.log('关门') &#125;&#125;var openPCCommand = &#123; execute: function () &#123; console.log('打开电脑') &#125;&#125;var openQQCommand = &#123; execute: function () &#123; console.log('打开QQ') &#125;&#125;var MacroCommand = function () &#123; return &#123; commandList: [], add: function ( command ) &#123; this.commandList.push(command) &#125;, execute: function () &#123; for (var i = 0, command; command = this.commandList[i++]; ) &#123; command.execute() &#125; &#125; &#125;&#125;var marcroCommand = MacroCommand()marcroCommand.add (closeDoorCommand )marcroCommand.add (openPCCommand )marcroCommand.add (openQQCommand )marcroCommand.execute()/* 基于命令模式的撤销/重做（可重做的命令） 把历史命令全部保存起来，之后全部命令重做，直到所需要的前一步 */var commandStack = [] // 历史命令队列command() // 执行命令commandStack.push(command) // 放入历史命令// 重做任务 replay 把任务队列中的任务重新做一遍var replay = function () &#123; var command while (command = commandStack.shift()) &#123; command() &#125;&#125;// 撤销命令一般为 undovar undo = function () &#123; // commandStack.pop() // 之后根据逻辑进行操作 // 或者重做到上一步 commandStack.pop() // 弹出上一步 replay() // 重做所有&#125;]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05订阅者模式]]></title>
    <url>%2F2019%2F06%2F25%2F05%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/* 订阅，发布者 模拟售楼部的情况 */var salesOffices = &#123; // 售楼部 clientList: &#123;&#125;, // 订阅的列表 listen: function ( key, fn ) &#123; // 订阅者：订阅事件 if ( !this.clientList[ key ] ) &#123; // 如果还没有订阅过，先初始化一下 this.clientList[ key ] = [] &#125; this.clientList[ key ].push( fn ) // 订阅消息添加进缓存列表 &#125;, trigger: function () &#123; // 发布者: 发布消息 var key = Array.prototype.shift.call( arguments ), // 消息类型 fns = this.clientList[ key ] // 订阅该消息的所有方法 if ( !fns || fns.length === 0) &#123; // 没有人订阅 return false &#125; for ( var i = 0, fn; fn = fns[ i++ ]; ) &#123; // 执行订阅 fn.apply(this, arguments) &#125; &#125; &#125; salesOffices.listen( 'squareMeter88', function ( price ) &#123; // 订阅squareMeter88事件 console.log( 'squareMeter88 -&gt; 价格为' + price )&#125;)salesOffices.listen( 'squareMeter100', function ( price ) &#123; // 订阅squareMeter100事件 console.log( 'squareMeter100 -&gt; 价格为' + price )&#125;)salesOffices.trigger( 'squareMeter88', 2000000) // 发布squareMeter88事件salesOffices.trigger( 'squareMeter100', 3000000) // 发布squareMeter100事件/* 通用的订阅者事件（增加remove） */var event = &#123; clientList: &#123;&#125;, listen: function ( key, fn ) &#123; // 订阅功能 if ( !this.clientList[ key ]) &#123; this.clientList[ key ] = [] &#125; this.clientList[ key ].push( fn ) &#125;, remove: function( key, fn ) &#123; // 取消事件的订阅 var fns = this.clientList[ key ] if ( !fns ) &#123; return false &#125; if ( !fn ) &#123; // 没有指定 默认去除所有 fns &amp;&amp; ( fns.length = 0 ) &#125; else &#123; for ( var l = fns.length - 1; l &gt;= 0; l--) &#123; var _fn = fns[ l ] if ( _fn === fn ) &#123; fns.splice( l, 1) &#125; &#125; &#125; &#125;, trigger: function () &#123; // 发布功能 var key = Array.prototype.shift.call( arguments ), fns = this.clientList[ key ] if ( !fns || fns.length === 0 ) &#123; return false &#125; for ( var i = 0, fn; fn = fns[ i++ ]; ) &#123; fn.apply( this, arguments ) &#125; &#125;&#125;var installEvent = function ( obj ) &#123; // 安装事件 for ( var key in event) &#123; obj[ key ] = event[ key ] &#125;&#125;var salesOffices = &#123;&#125;installEvent(salesOffices) // 安装发布者模块var handleSquareMeter88Fn1 = function ( price ) &#123; console.log( 'fn1得知 squareMeter88 -&gt; 价格为' + price )&#125;var handleSquareMeter88Fn2 = function ( price ) &#123; console.log( 'fn2得知 squareMeter88 -&gt; 价格为' + price )&#125;salesOffices.listen( 'squareMeter88', handleSquareMeter88Fn1 ) // fn1订阅squareMeter88事件salesOffices.listen( 'squareMeter88', handleSquareMeter88Fn2 ) // fn2订阅squareMeter88事件salesOffices.trigger( 'squareMeter88', 2000000 )console.log('===========================')salesOffices.remove( 'squareMeter88', handleSquareMeter88Fn1 ) // 取消fn1对squareMeter88事件的订阅salesOffices.trigger( 'squareMeter88', 2000000 )/* 然而现实中不需要为特定的对象专门注册这一个发布订阅， 共用一个即可 */var Event = (function () &#123; var clientList = &#123;&#125;, listen, trigger, remove listen = function ( key, fn ) &#123; if ( !clientList[ key ]) &#123; clientList[ key ] = [] &#125; clientList[ key ].push( fn ) &#125; remove = function ( key, fn ) &#123; var fns = clientList[ key ] if ( !fns ) &#123; return false &#125; if ( !fn ) &#123; fns &amp;&amp; (fns.length = 0) &#125; else &#123; for ( var l = fns.length - 1; l &gt;= 0; l--) &#123; var _fn = fns[ l ] if ( _fn === fn ) &#123; fns.splice( l, 1 ) &#125; &#125; &#125; &#125; trigger = function () &#123; var key = Array.prototype.shift.call( arguments ), fns = clientList[ key ] if ( !fns || fns.length === 0 ) &#123; return false &#125; for ( var i = 0, fn; fn = fns[ i++ ]; ) &#123; fn.apply( this, arguments ) &#125; &#125; &#125;)()// 简单实现到这里， 完整的发布者 订阅者模式还需要提供如下两个方面的能力/* 1.全局事件命名冲突 比如都发布了一个 squareMeter88 无法确定具体是那一个 事件发布出来的，可能事件重名，不便于管理 这里可以引入 namespace 在每一个命名空间内进行事件的订阅 可以显示创建命名空间后在内部调用 默认情况下不申明，就在自己申明的'_default'环境中 2.离线时间的发布 有的事件发布出来，可能订阅者还没来得及订阅，这里可以使用一个离线的cache,等待何时的时机发布出去 离线事件只能发布一次，不能重复发布，不然就没有了发布的意义（它只是当时没发布，等到事宜的时机再将事件发布出去） 在触发的时候，判定有离线事件队列，就先别真触发，先放入离线事件队列中 当触发监听listen时 如果有离线事件队列，就把离线事件队列调出来运行一次 */]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04迭代器模式]]></title>
    <url>%2F2019%2F06%2F25%2F04%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/* 迭代器模式 将迭代的过程抽离开，根据业务的需求定制 是关心结果，还是关心迭代的过程 */// 模拟forEach内部迭代器var each = function ( ary, callback ) &#123; for (var i = 0, l = ary.length; i &lt; l; i++) &#123; callback.call( ary[i], ary[i], i) &#125;&#125;each( [1, 2, 3], function (item, index) &#123; console.log(`arr[$&#123;index&#125;] -&gt; $&#123;item&#125;`)&#125;)/* 通过编写一个比较函数， 分别使用内部迭代器，和外部迭代器 */// 内部迭代器 结合之前编写的 eachvar compare = function ( arr1, arr2 ) &#123; if (arr1.length !== arr2.length) &#123; throw new Error( 'arr1 与 arr2 不相等' ) &#125; each( arr1, function (item, index) &#123; if (item !== arr2[ index ]) &#123; throw new Error( 'arr1 与 arr2 不相等' ) &#125; &#125;) console.log( 'arr1 与 arr2 相等' )&#125;// compare( [1,2,3], [1,2,4]) // Error: arr1 与 arr2 不相等// 外部迭代器 只要保证对象有length 并且其key是数字 &#123;"0": '0index', '1': '1index'&#125;var Iterator = function ( obj ) &#123; var current = 0 var next = function () &#123; current += 1 &#125; var isDone = function () &#123; return current &gt;= obj.length &#125; var getCurrItem = function () &#123; return obj[ current ] &#125; return &#123; next, isDone, getCurrItem &#125;&#125;var compare = function ( iterator1, iterator2 ) &#123; // 如果长度不相同 是个bug while ( !iterator1.isDone() &amp;&amp; !iterator2.isDone()) &#123; if ( iterator1.getCurrItem() !== iterator2.getCurrItem() ) &#123; throw new Error( 'iterator1 和 iterator 不相等' ) &#125; iterator1.next() iterator2.next() &#125; console.log( 'iterator1 和 iterator 相等' )&#125;var iterator1 = Iterator([1,2,3])var iterator2 = Iterator([1,2,3])// compare(iterator1, iterator2) // iterator1 和 iterator 相等/* 应用内部迭代器 来根据支持的类型 插入不同的上传控件 */// 不符合开闭原则的写法var getUploadObj = function () &#123; try&#123; return new ActiveXObject("TXFTNActiveX.FTNUpload") // IE 上传控件 &#125;catch(e)&#123; if ( suportFlash() ) &#123; // 支持falsh 控件 模拟 var str = '&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;' return $(str).appendTo( $('body') ) &#125; else &#123; var str = '&lt;input name="File" type="File"&gt;&lt;/input&gt;' return $(str).appendTo( $('body') ) &#125; &#125;&#125; // 如果有另一种上传方式就需要 修改代码 不符合开闭原则 // 符合开闭原则的写法 + 内部迭代器var getActiveUploadObj = function () &#123; // IE 上传控件 try&#123; return new ActiveXObject("TXFTNActiveX.FTNUpload") &#125;catch(e)&#123; return false &#125;&#125;var getFlashUploadObj = function () &#123; if ( suportFlash() ) &#123; // 支持falsh 控件 模拟 var str = '&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;' return $(str).appendTo( $('body') ) &#125; return false&#125;var getFormUploadObj = function () &#123; var str = '&lt;input name="File" type="File"&gt;&lt;/input&gt;' return $(str).appendTo( $('body') )&#125;var iteratorUploadObj = function () &#123; // 如果返回是不是false 则返回该对象 循环结束 for (var i =0, fn; fn = arguments[ i++]; )&#123; var uploadObj = fn() if (uploadObj !== false) &#123; return uploadObj &#125; &#125;&#125;var uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getFormUploadObj )// 如果需求配置新的上传对象 只需要再添加新的方法即可var getHtml5UplaodObj = function () &#123; // ........ 具体代码略 如果不成功可以返回false&#125;var getWebkitUploadObj = function () &#123; // ........ 具体代码略 如果不成功可以返回false&#125;// 此时满足了开闭原则var uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getHtml5UplaodObj, getWebkitUploadObj, getFormUploadObj )]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03代理模式]]></title>
    <url>%2F2019%2F06%2F25%2F03%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/* 代理模式，通过一个代理对象访问本体 模拟小明将花送给A 可以通过B转送给A */var Flower = function () &#123;&#125;/* 默认 */var xiaoming = &#123; sendFlower: function ( target ) &#123; var flower = new Flower() target.receiveFlower( flower ) &#125; &#125;var A = &#123; receiveFlower: function ( flower ) &#123; console.log( '收到了花' + flower) &#125;, listenGoodMood: function (fn) &#123; setTimeout(function () &#123; console.log('心情不错，我答应啦') fn() &#125;, 5000) // 假设A 5s后心情变好 &#125;&#125;// xiaoming.sendFlower( A ) 这里A只有在心情好的时候 才收花,所以这里不行, 需要一个代理Bvar B = &#123; receiveFlower: function ( flower ) &#123; A.listenGoodMood(function () &#123; A.receiveFlower( flower ) &#125;) &#125;&#125;// xiaoming.sendFlower( B ) //通过一个代理B 完成了任务/* 虚拟代理发送整合http请求发送 对于实时性不太高的系统可以采用，减少频繁的http次数保证高效 */var synchronousFile = function ( id ) &#123; console.log( '开始同步文件， HTTP....' + id )&#125;var checkbox = document.getElementsByTagName('input')for (var i = 0, c; c = checkbox[i++]; ) &#123; c.onclick = function () &#123; if ( this.checked === true ) &#123; synchronousFile ( this.id ) &#125; &#125;&#125;/* 频繁的发送浪费网络请求， 可以整合成一批 进行发送 其原理类似公交车发车， 只要有一个请求过来就放一个公交车， 等待2s后，一起发车，后续的请求直接上车即可*/var proxySynchronousFile = (function () &#123; var cache = [], // 保存发送队列 timer // 定时器 return function ( id ) &#123; // 代理对象要与本体设计一致 方便调换和更改 cache.push(id) // 放入发送队列 if ( timer ) &#123; // 当前已经有一批准备好，发送中 return &#125; timer = setTimeout(function () &#123; synchronousFile ( cache.join( ',' ) ) clearTimeout( timer ) timer = null cache.length = 0 // 清空集合 &#125;, 2000) &#125;&#125;)()var checkbox = document.getElementsByTagName( 'input' )for (var i = 0, c; c = checkbox[i++]; ) &#123; c.onclick = function () &#123; if (this.checked === true) &#123; proxySynchronousFile( this.id ) &#125; &#125;&#125;/* 缓存代理，就是将一些结果提前缓存起来，然后后续便于直接查找 如 这里做一些大计算（认为此处为复杂计算） */var mult = function () &#123; var a = 1 for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i] &#125; return a&#125;var add = function () &#123; var a = 0 for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a + arguments[i] &#125; return a&#125;// 创建缓存代理的工厂var createProxyFactory = function ( fn ) &#123; var cache = &#123;&#125; return function () &#123; var args = Array.prototype.join.call( arguments, ',' ) if (args in cache) &#123; return cache[ args ] &#125; return cache[ args ] = fn.apply( this, arguments) &#125;&#125;var proxyMult = createProxyFactory( mult )var proxyAdd = createProxyFactory( add )proxyMult(1, 2, 3) // 进行计算，并且把结果放入缓存中proxyMult(1, 2, 3) // 从缓存中直接读取]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02策略模式]]></title>
    <url>%2F2019%2F06%2F25%2F02%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133// 定义策略var strategies = &#123; "S": function (salary) &#123; return salary * 4 &#125;, "A": function (salary) &#123; return salary * 3 &#125;, "B": function (salary) &#123; return salary * 2 &#125;&#125;// 使用策略var calculateBonus = function ( level, salary) &#123; return strategies[ level ]( salary )&#125;// 调用console.log( calculateBonus( 'S', 10000) )console.log( calculateBonus( 'B', 10000) )/* 使用案例，做一个表单验配置 validator *//* 策略对象 */var strategies = &#123; isNonEmpty: function ( value, errorMsg ) &#123; if (value === '') &#123; return errorMsg &#125; &#125;, minLength: function (value, length, errorMsg) &#123; if (value.length &lt; length) &#123; return errorMsg &#125; &#125;, maxLength: function (value, length, errorMsg) &#123; if (value.length &gt; length) &#123; return errorMsg &#125; &#125;, isMobile: function (value, errorMsg) &#123; if (!/^1[3|5|8][0-9]&#123;9&#125;$/.test( value )) &#123; return errorMsg &#125; &#125;&#125;/* 验证器 validator */class Validator &#123; constructor() &#123; this.cache = [] &#125; add (dom, rules) &#123; // 添加一个策略 for (var i = 0, rule; rule = rules[ i++ ]; ) &#123; var that = this ;(function (rule) &#123; // 异步调用， 这里要注意闭包，否则一直检验此项最后一个策略 var strategyAry = rule.strategy.split( ':' ) var errorMsg = rule.errorMsg that.cache.push(function () &#123; // cache放入配置好的待执行方法 var strategy = strategyAry.shift() // ['minLength', 6] strategyAry.unshift( dom.value ) // 把待测值放入第一个参数 ['value', 6] strategyAry.push(errorMsg) // 把错误提示 放入最后一个 （第二位或第三位） ['value', 6， '不能少于6位'] return strategies[ strategy ].apply(dom, strategyAry) &#125;) &#125;)(rule) &#125; &#125; validate () &#123; // 验证策略 for (var i = 0, validatorFunc; validatorFunc = this.cache [ i++ ]; ) &#123; var errorMsg = validatorFunc() if ( errorMsg ) &#123; return errorMsg &#125; &#125; &#125;&#125;/* ================= 客户端调用 ================= */var registerForm = document.getElementById('registerForm') // 获取元素var validataFunc = function () &#123; // 验证逻辑 var validator = new Validator() validator.add(registerForm.username, [&#123; strategy: 'isNonEmpty', errorMsg: '用户名不能为空' &#125;, &#123; strategy: 'minLength:6', errorMsg: '用户名不能少于6位' &#125;]) validator.add(registerForm.password, [&#123; strategy: 'minLength:6', errorMsg: '密码不能少于6位' &#125;]) validator.add(registerForm.phonenumber, [&#123; strategy: 'isMobile', errorMsg: '手机号不正确' &#125;]) // 调用校验 var errorMsg = validator.validate() return errorMsg&#125;registerForm.onsubmit = function () &#123; // 绑定验证逻辑 var errorMsg = validataFunc() if ( errorMsg ) &#123; // 有错误， 阻止提交 alert( errorMsg ) return false &#125;&#125;class Person&#123; constructor (name) &#123; this.name = name &#125; sayHi () &#123; console.log(this.name) console.log('hi') &#125;&#125;var p = new Person('zhn')// console.log(p)p.sayHi()]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01单例模式]]></title>
    <url>%2F2019%2F06%2F25%2F01%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 注意：单例管理 和 对象创建要分开 *//*// 返回创建单例的方法var getSingle = function ( fn ) &#123; var result return function () &#123; return result || (result = fn.apply(this, arguments)) &#125;&#125;// 创建对象的方法var createSigleIframe = getSingle(function () &#123; var iframe = document.createElement('iframe') document.body.appendChild(iframe) return iframe&#125;)// 使用document.getElementById( 'loginBtn' ).onclick = function () &#123; var loginLayer = createSigleIframe() loginLayer.src = 'http://www.baidu.com'&#125;document.getElementById( 'loginBtn' ).onclick = function () &#123; // 多次调用不会创建多个iframe var loginLayer = createSigleIframe() loginLayer.src = 'http://www.google.com'&#125;*//* 模拟小程序中云开发获取db的例子，使用单例 */var getSingle = function (fn) &#123; var result return function () &#123; return result || (result = fn.apply(this, arguments)) &#125;&#125;var getDB = getSingle(function (wx) &#123; return wx.cloud.database()&#125;) // 这里保证始终取出了一个db// var wx = &#123;name: 'wx'&#125;var db = getDB(wx)// ......var db = getDB()// ......var db = getDB()// ......]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的相关高阶函数]]></title>
    <url>%2F2019%2F06%2F25%2Fjs%E7%9A%84%E7%9B%B8%E5%85%B3%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[柯里化 currying就是把一些方法 在内部做了，或者可以连续调用 减少普遍性， 增加适用性，提前做12345678910111213141516171819202122232425262728293031// 做一个能够累加的方法var currying = function ( fn ) &#123; var args = [] return function () &#123; if (arguments.length === 0) &#123; return fn.apply( this, args) &#125;else&#123; [].push.apply( args, arguments ) return arguments.callee // 返回调用函数 可以fn()()() &#125; &#125;&#125;var cost = (function () &#123; var money = 0 return function () &#123; for (var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; money += arguments[i] &#125; return money &#125;&#125;)()// var result = cost(1, 2, 3) // 立即计算6// var cost = currying (cost) // 柯里化// cost(1)// cost(2)// cost(3)(4)// var result = cost() // 这里在计算10 非柯里化 uncurrying就是把原本内部的一些方法 抽离出来，可以单独使用， 借用方法，只要是this指向的问题 document.createElement() -&gt; 此时的createElement的调用者是document createFn = document.createElement-&gt; createFn() -&gt; 此时的createElement的调用者是window.所以会出现异常 主要的解决方案 是把this固定下来 1234567891011121314Function.prototype.uncurrying = function () &#123; var self = this // 这里是方法体 return function () &#123; var obj = Array.prototype.shift.call( arguments ) return self.apply( obj, arguments) &#125;&#125;var push = Array.prototype.push.uncurrying()var obj = &#123; "0": 0, "length": 1&#125;push(obj, 1) // Object [ 0, 1 ] 函数节流频繁触发的事件造成的不必要的事件的浪费,返回那些频繁的函数 12345678910111213141516171819202122232425262728293031var throttle = function (fn, interval) &#123; var _self = fn, // 原始函数的引用 timer, // 计时器 firstTime = true // 第一次 return function () &#123; var args = arguments _me = this if (firstTime) &#123; // 第一次进入 _self.apply(_me, args) return firstTime = false &#125; if (timer) &#123; // 当前正在准备运行中 return false &#125; timer = setTimeout(function () &#123; clearTimeout(timer) timer = null _self.apply(_me, args) &#125;, interval || 500) &#125;&#125;window.onresize = throttle(function () &#123; console.log('1')&#125;, 500) // 保证事件触发500ms/次 分时函数浏览器执行速度很快，有可能使其吃不消，假死，崩溃，可以降低速度，分批执行类似与坐大巴车， 一批一批的拉客 123456789101112131415161718192021222324252627282930313233var timeChunk = function (ary, fn, count) &#123; var obj, t var len = ary.length var start = function () &#123; for (var i = 0; i &lt; Math.min(count || 1, ary.length); i++) &#123; // 这里保证一次运行最小次数 var obj = ary.shift() fn(obj) &#125; &#125; return function () &#123; t = setInterval(function () &#123; if (ary.length === 0) &#123; return clearInterval(t) &#125; start() &#125;, 200) &#125;&#125;var ary = []for (var i = 0; i &lt; 1000; i++) &#123; ary.push(i)&#125;var render = timeChunk(ary, function (n)&#123; // TODO...... 一次执行8个任务 一批一批执行 // console.log(n)&#125;, 8)render() 惰性加载判断浏览器类型，这种需要干一次存储起来即可 1234567891011121314151617181920212223242526272829var addEvent = (function () &#123; // 提前缓存起来了， 但是可能一次没执行，会浪费 if (window.addEventListener) &#123; return function (ele, type, handler) &#123; ele.addEventListener(typem, handler, false) &#125; &#125; if (window.attachEvent) &#123; return function (ele, type, handler) &#123; ele.attachEvent('on' + typem, handler) &#125; &#125;&#125;)()// addEvent(dom, 'click', () =&gt; &#123; console.log(1) &#125;)var addEvent = function (ele, type, handler) &#123; // 当第一次用完之后改变指向 if (window.addEventListener) &#123; addEvent = function (ele, type, handler) &#123; ele.addEventListener(typem, handler, false) &#125; &#125; if (window.attachEvent) &#123; addEvent = function (ele, type, handler) &#123; ele.attachEvent('on' + typem, handler) &#125; &#125;&#125;// addEvent(dom, 'click', () =&gt; &#123; console.log(1) &#125;)]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中正则相关的方面]]></title>
    <url>%2F2019%2F06%2F12%2Fjs%E4%B8%AD%E6%AD%A3%E5%88%99%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[比较基础的用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 正则后match的结果是一个字符串 g是全局替换 否则他匹配到第一个就停下来了var str = 'abc666'var result = str.match(/^a.*6$/g) // ^表示严格开头 $表示严格结尾 [ "abc666" ]var str = '6^1a'var result = str.match(/\^1a/g) // [ "^1a" ] 对关键词进行转义 var str = ' hello world 'var result = str.match(/(^\s+)|(\s+$)/) // 匹配前后的空格 [ " ", " "]var str = 'php'var result = str.match(/p.p/) // .表示任意字符 一个点表示一个字符 [ "php" ]var str = 'phahsp'var result = str.match(/p.*p/) // .*表示任意的字符串 [ "phahsp" ]var str = 'pha_hsp'var result = str.match(/p\w*p/g) // \w表示 字母 数字 下划线 [ "pha_hsp" ]var str = 'p*@ #*-+p'var result = str.match(/p\W*p/g) // \W表示 非字母 非数字 非下划线 [ "p*@ #*-+p" ]var str = 'hello123456666aas5474xc'var result = str.match(/\d/g) // \d 表示也给数字 [ "1", "2", "3", "4", "5", "6", "6", "6", "6", "5", … ]var result = str.match(/\d+/g) // 贪婪模式，会一直匹配下去 [ "123456666", "5474" ]var result = str.match(/\D+/g) // \D 表示非数字 [ "hello", "aas", "xc" ]var str = 'abcd nihao 666 zhn'var result = str.match(/\bn.*/g) // \b 表示匹配边界 以开头 使用空格做依据 [ "nihao 666 zhn" ]var result = str.match(/\bn.*o/g) // [ "nihao" ]// 剩下查阅配置手册即可/* 分组的使用 */var str = '1111, 1212, 1331 1344'var result = str.match(/\d\d\d\d/g) // 查找四个数字 [ "1111", "1212", "1331" ]var result = str.match(/(\d)(\d)\1\2/g) // 匹配使用 \1 [ "1111", "1212" ]var result = str.match(/(\d)(?:\d)(\d)\2/g) // 匹配使用 禁止使用此分组 ?: [ "1111", "1344" ]/* 断言/环视 */var str = 'java11 and es6'var result = str.match(/[A-z]+(?=\d)/g) // 后限制,但是自己不会被输出 [ "java", "es" ] var str = '12sda4716'var result = str.match(/(?!^\d+\$)^[0-9a-zA-Z]+$/g) // 前表范围 不能只是数字的情况下 满足[0-9a-zA-Z]+即， [ "12sda4716" ]console.log(result) 函数方法相关123456789101112131415161718192021222324252627282930313233343536373839404142/*RegExp test 正则表达式的方法 */var res = /abc/g.test('abc') // true/*RegExp exec 正则表达式的方法 */var str = '1111 1122 3434 5678 8989'var r = /(\d)\d\1\d/g// 会有连续性var i = r.lastIndex // 前一次匹配的位置 0var res = r.exec(str) // [ "1111", "1" ] '1111'是匹配的结果 '1'是分组的信息console.log(i, res) // 0 [ "1111", "1" ]var i = r.lastIndex // 上一次匹配的结束位置 4var res = r.exec(str) // [ "3434", "3" ]console.log(i, res) // 4 [ "3434", "3" ] /*String replace的方法 */var str = 'helli world' var result = str.replace('l', 'L') // heLli world 只替换一处var result = str.replace(/l/, 'L') // heLli worldvar result = str.replace(/l/g, 'L') // heLLi worLd 全局替换/g// 借助子表达式 12345 - 12[12-3-45]45var str = '12345'var result = str.replace(/(3)/g, "[$`-$1-$']") // $` 匹配左侧的部分 $' 匹配右侧的部分var str = '1234567'var result = str.replace(/(2).(4).(6)/g, "[$`-$2-$']") // 1[1-4-7]7 整个分组左右// 去除汉字相同的部分var str = "这这这这丸丸丸子多多多多多多少钱一一一一斤"var result = str.replace(/([\u4e00-\u9fa5])\1*/g, '$1') //性能略差，所有都要匹配 子，少，钱也替换了（子 -&gt; 子） 这丸子多少钱一斤var result = str.replace(/([\u4e00-\u9fa5])\1+/g, '$1') //性能略好，子，少，钱根本就没匹配到（不满足\1+） 这丸子多少钱一斤// 借助替换函数 首字母大写var str = 'aaa bbb ccc' // Aaa Bbb Cccvar result = str.replace(/[a-z]+/g, function (x) &#123; // x为匹配到的的组 return x.substr(0, 1).toUpperCase() + x.substr(1) // 最后要将 x 返回出去&#125;) console.log(result)]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中正则相关的方面]]></title>
    <url>%2F2019%2F06%2F12%2F%E6%AD%A3%E5%88%99%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[比较基础的用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 正则后match的结果是一个字符串 g是全局替换 否则他匹配到第一个就停下来了var str = 'abc666'var result = str.match(/^a.*6$/g) // ^表示严格开头 $表示严格结尾 [ "abc666" ]var str = '6^1a'var result = str.match(/\^1a/g) // [ "^1a" ] 对关键词进行转义 var str = ' hello world 'var result = str.match(/(^\s+)|(\s+$)/) // 匹配前后的空格 [ " ", " "]var str = 'php'var result = str.match(/p.p/) // .表示任意字符 一个点表示一个字符 [ "php" ]var str = 'phahsp'var result = str.match(/p.*p/) // .*表示任意的字符串 [ "phahsp" ]var str = 'pha_hsp'var result = str.match(/p\w*p/g) // \w表示 字母 数字 下划线 [ "pha_hsp" ]var str = 'p*@ #*-+p'var result = str.match(/p\W*p/g) // \W表示 非字母 非数字 非下划线 [ "p*@ #*-+p" ]var str = 'hello123456666aas5474xc'var result = str.match(/\d/g) // \d 表示也给数字 [ "1", "2", "3", "4", "5", "6", "6", "6", "6", "5", … ]var result = str.match(/\d+/g) // 贪婪模式，会一直匹配下去 [ "123456666", "5474" ]var result = str.match(/\D+/g) // \D 表示非数字 [ "hello", "aas", "xc" ]var str = 'abcd nihao 666 zhn'var result = str.match(/\bn.*/g) // \b 表示匹配边界 以开头 使用空格做依据 [ "nihao 666 zhn" ]var result = str.match(/\bn.*o/g) // [ "nihao" ]// 剩下查阅配置手册即可/* 分组的使用 */var str = '1111, 1212, 1331 1344'var result = str.match(/\d\d\d\d/g) // 查找四个数字 [ "1111", "1212", "1331" ]var result = str.match(/(\d)(\d)\1\2/g) // 匹配使用 \1 [ "1111", "1212" ]var result = str.match(/(\d)(?:\d)(\d)\2/g) // 匹配使用 禁止使用此分组 ?: [ "1111", "1344" ]/* 断言/环视 */var str = 'java11 and es6'var result = str.match(/[A-z]+(?=\d)/g) // 后限制,但是自己不会被输出 [ "java", "es" ] var str = '12sda4716'var result = str.match(/(?!^\d+\$)^[0-9a-zA-Z]+$/g) // 前表范围 不能只是数字的情况下 满足[0-9a-zA-Z]+即， [ "12sda4716" ]console.log(result) 函数方法相关123456789101112131415161718192021222324252627282930313233343536373839404142/*RegExp test 正则表达式的方法 */var res = /abc/g.test('abc') // true/*RegExp exec 正则表达式的方法 */var str = '1111 1122 3434 5678 8989'var r = /(\d)\d\1\d/g// 会有连续性var i = r.lastIndex // 前一次匹配的位置 0var res = r.exec(str) // [ "1111", "1" ] '1111'是匹配的结果 '1'是分组的信息console.log(i, res) // 0 [ "1111", "1" ]var i = r.lastIndex // 上一次匹配的结束位置 4var res = r.exec(str) // [ "3434", "3" ]console.log(i, res) // 4 [ "3434", "3" ] /*String replace的方法 */var str = 'helli world' var result = str.replace('l', 'L') // heLli world 只替换一处var result = str.replace(/l/, 'L') // heLli worldvar result = str.replace(/l/g, 'L') // heLLi worLd 全局替换/g// 借助子表达式 12345 - 12[12-3-45]45var str = '12345'var result = str.replace(/(3)/g, "[$`-$1-$']") // $` 匹配左侧的部分 $' 匹配右侧的部分var str = '1234567'var result = str.replace(/(2).(4).(6)/g, "[$`-$2-$']") // 1[1-4-7]7 整个分组左右// 去除汉字相同的部分var str = "这这这这丸丸丸子多多多多多多少钱一一一一斤"var result = str.replace(/([\u4e00-\u9fa5])\1*/g, '$1') //性能略差，所有都要匹配 子，少，钱也替换了（子 -&gt; 子） 这丸子多少钱一斤var result = str.replace(/([\u4e00-\u9fa5])\1+/g, '$1') //性能略好，子，少，钱根本就没匹配到（不满足\1+） 这丸子多少钱一斤// 借助替换函数 首字母大写var str = 'aaa bbb ccc' // Aaa Bbb Cccvar result = str.replace(/[a-z]+/g, function (x) &#123; // x为匹配到的的组 return x.substr(0, 1).toUpperCase() + x.substr(1) // 最后要将 x 返回出去&#125;) console.log(result)]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[穿越时空的信]]></title>
    <url>%2F2019%2F06%2F12%2F%E7%A9%BF%E8%B6%8A%E6%97%B6%E7%A9%BA%E7%9A%84%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[如果把来找我咨询的人比喻成迷途的羔羊，通常他们的手上都有地图，却没有看，或是不知道路在哪里。 东野圭吾老先生著的《解忧杂货店》，故事看似独立，却又穿插其中，最后一幕真的是震惊到了我，穿越时空的连接，却近在眼前，每个人或许都有一个小牛奶箱，我想这零星的温暖，对我们来说，就已经足够了。 之前以为自己或许不爱看书，一直引以为傲，或许是该静下心来，去从别人的生活中照亮到自己的影子。 可是换个角度来看，正因为是一张白纸，才可以随心所欲的描绘地图，一切尽在你自己，对你来说，一切都是自由，在你面前是无限的可能，这可是很棒的事啊，我衷心的祈祷你可以相信自己，无悔的燃烧自己的人生。 或许这就是浪矢杂货店的魅力所在，或许这正也是阅读的魅力吧。]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise中链式调用then的问题]]></title>
    <url>%2F2019%2F06%2F11%2Fpromise%E4%B8%AD%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8then%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[promise是一个很好的解决异步调用的方法，其链式调用也是一个很好的方式，这里探究一下其调用过程 主要问题123456789101112Promise.resolve().then(res =&gt; &#123; return new Promise() &#125;)Promise.resolve().then(res =&gt; &#123; new Promise() &#125;)// 上下两种Promise的方式中， 是否会进行下去，//以及新产生的promise是否会被传递下去,或者说有什么不同 测试代码每一句打印后面都输出了时间戳，是为了更好描述运行顺序测试代码直接贴在下方，可以拿到浏览器中进行测试查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333;(function () &#123; // fn1() // fn1_1() // fn2() // fn3() // fn4() // fn5() // fn6() // fn7() // fn8() // fn9()&#125;)()function fn1 () &#123; console.log('start', new Date().getTime()) new Promise(resolve =&gt; &#123; console.log('11111', new Date().getTime()) &#125;).then(res =&gt; &#123; console.log('22222', new Date().getTime()) &#125;).then(res =&gt; &#123; console.log('33333', new Date().getTime()) &#125;) console.log('end', new Date().getTime()) /* start 1560165694777 11111 1560165694787 end 1560165694790 */&#125;function fn1_1 () &#123; console.log('start', new Date().getTime()) new Promise(resolve =&gt; &#123; console.log('11111', new Date().getTime()) resolve() console.log('11111-1111', new Date().getTime()) &#125;).then(res =&gt; &#123; console.log('22222', new Date().getTime()) &#125;).then(res =&gt; &#123; console.log('33333', new Date().getTime()) &#125;) console.log('end', new Date().getTime()) /* start 1560166834093 11111 1560166834106 11111-1111 1560166834108 end 1560166834110 22222 1560166834115 33333 1560166834119 */&#125;/*通过前 fn1, fn1_1 两个小例子可知，最开始的new Promise可能对我们进行干扰，出现这种状况的原因是，申明 new Promise的时候此时异步还未开始，所以我们直接按照接下来的方式进行测试*/function fn2 () &#123; console.log('start', new Date().getTime()) Promise.resolve() .then(res =&gt; &#123; console.log('11111', new Date().getTime()) &#125;) .then(res =&gt; &#123; console.log('22222', new Date().getTime()) &#125;).then(res =&gt; &#123; console.log('33333', new Date().getTime()) &#125;) console.log('end', new Date().getTime()) /* start 1560166657107 end 1560166657117 11111 1560166657120 22222 1560166657122 33333 1560166657130 */&#125;function fn3 () &#123; console.log('start', new Date().getTime()) Promise.resolve() .then(res =&gt; &#123; console.log('11111', new Date().getTime()) &#125;).then(res =&gt; &#123; console.log('22222', new Date().getTime()) return Promise.reject('2222error') &#125;).then(res =&gt; &#123; console.log('33333', new Date().getTime()) &#125;).catch(err =&gt; &#123; console.log(err, new Date().getTime()) &#125;) console.log('end', new Date().getTime()) /* start 1560166779524 end 1560166779533 11111 1560166779537 22222 1560166779539 2222error 1560166779543 */&#125;/*通过 fn3 这个例子知道了，只要在调用过程中，返回了一个Promise的reject状态就会结束下去*/function fn4 () &#123; console.log('start', new Date().getTime()) Promise.resolve() .then(res =&gt; &#123; console.log('11111', new Date().getTime()) return new Promise((resolve, reject) =&gt; &#123; console.log('inner Promise', new Date().getTime())&#125;) &#125;) .then(res =&gt; &#123; console.log('22222', new Date().getTime()) &#125;).then(res =&gt; &#123; console.log('33333', new Date().getTime()) &#125;).catch(err =&gt; &#123; console.log(err, new Date().getTime()) &#125;) console.log('end', new Date().getTime()) /* start 1560167538395 end 1560167538407 11111 1560167538409 inner Promise 1560167538414 */&#125;/*通过 fn4 这个例子，如果调用链中返回一个pending，他也会等待（Promise创建出来就是pending状态）,他既没有reject,也没有resovle。到目前，一共有两种方式会阻止链式， ① 返回了一个reject的Promise ② 返回pendding状态的Promsie其余的情况都会畅通无阻的运行下去(前提直接就在调用链中了)*/function fn5 () &#123; console.log('start', new Date().getTime()) Promise.resolve() .then(res =&gt; &#123; console.log('11111', new Date().getTime()) &#125;).then(res =&gt; &#123; console.log('22222', new Date().getTime()) Promise.reject('2222error') &#125;).then(res =&gt; &#123; console.log('33333', new Date().getTime()) &#125;).catch(err =&gt; &#123; console.log(err, new Date().getTime()) &#125;) console.log('end', new Date().getTime()) /* start 1560166933856 end 1560166933865 11111 1560166933869 22222 1560166933873 33333 1560166933874 (node:8196) UnhandledPromiseRejectionWarning: 2222error */&#125;/*通过 fn5 这个例子，其实那个新创建的Promise,并不属于这个调用链，我们接着向下验证*/function fn6 () &#123; console.log('start', new Date().getTime()) Promise.resolve() .then(res =&gt; &#123; console.log('11111', new Date().getTime()) &#125;).then(res =&gt; &#123; console.log('22222', new Date().getTime()) Promise.reject('2222error').then().catch(err =&gt; console.log('inner' + err, new Date().getTime())) &#125;).then(res =&gt; &#123; console.log('33333', new Date().getTime()) &#125;).catch(err =&gt; &#123; console.log(err, new Date().getTime()) &#125;) console.log('end', new Date().getTime()) /* start 1560167831274 end 1560167831292 11111 1560167831296 22222 1560167831301 33333 1560167831307 inner2222error 1560167831316 */&#125;/*通过 fn6 我们已经知道了在调用链中，如果return 出一个Promise，那么它将属于此调用链，否则就会有他自己的一个调用链*/function timeout(ms) &#123; // 这里模拟一个异步操作 return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;function fn7 () &#123; console.log('start', new Date().getTime()) Promise.resolve() .then(res =&gt; &#123; console.log('11111', new Date().getTime()) return timeout(500) &#125;).then(res =&gt; &#123; console.log('22222', new Date().getTime()) return timeout(500) &#125;).then(res =&gt; &#123; console.log('33333', new Date().getTime()) return timeout(500) &#125;).catch(err =&gt; &#123; console.log(err, new Date().getTime()) return timeout(500) &#125;) console.log('end', new Date().getTime()) /* start 1560167223744 end 1560167223759 11111 1560167223764 22222 1560167224274 33333 1560167224779 */&#125;function fn8 () &#123; console.log('start', new Date().getTime()) Promise.resolve() .then(res =&gt; &#123; console.log('11111', new Date().getTime()) timeout(500) &#125;).then(res =&gt; &#123; console.log('22222', new Date().getTime()) timeout(500) &#125;).then(res =&gt; &#123; console.log('33333', new Date().getTime()) timeout(500) &#125;).catch(err =&gt; &#123; console.log(err, new Date().getTime()) timeout(500) &#125;) console.log('end', new Date().getTime()) /* start 1560168006937 end 1560168006951 11111 1560168006954 22222 1560168006961 33333 1560168006966 */&#125;function fn9 () &#123; console.log('start', new Date().getTime()) Promise.resolve() .then(res =&gt; &#123; console.log('11111', new Date().getTime()) timeout(500).then(res =&gt; &#123; console.log('inner11111', new Date().getTime()) &#125;) &#125;).then(res =&gt; &#123; console.log('22222', new Date().getTime()) timeout(500).then(res =&gt; &#123; console.log('inner22222', new Date().getTime()) &#125;) &#125;).then(res =&gt; &#123; console.log('33333', new Date().getTime()) timeout(500).then(res =&gt; &#123; console.log('inner33333', new Date().getTime()) &#125;) &#125;).catch(err =&gt; &#123; console.log(err, new Date().getTime()) timeout(500).then(res =&gt; &#123; console.log('inner44444', new Date().getTime()) &#125;) &#125;) console.log('end', new Date().getTime()) /* start 1560168109766 end 1560168109775 11111 1560168109778 22222 1560168109781 33333 1560168109785 inner11111 1560168110281 inner22222 1560168110288 inner33333 1560168110291 */&#125;/*最后通过 fn7, fn8, fn9 这三个例子中，以及传入的时间，确实印证了之前所说的，这里用一副图进行代替。所以最为关键的就是，在Promise的调用链中，关键要明白你新产生的这个 Promsie是否添加到了这个调用链中*/ 总结图示]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云函数中生成excel并且上传到云存储中]]></title>
    <url>%2F2019%2F06%2F05%2F%E4%BA%91%E5%87%BD%E6%95%B0%E4%B8%AD%E7%94%9F%E6%88%90excel%E5%B9%B6%E4%B8%94%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%BA%91%E5%AD%98%E5%82%A8%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[云环境1.0.51 小程序的云开发功能为我们带来了很大的方便，于是就打算研究一下如何在云函数中拉取数据，之后生成excel到云存储中，过程中踩了些坑，这里分享给大家，希望能有所帮助。 首先了解一个node生成excel的库excel-export虽然已经许久未更新了，但是目前还没有什么太大的问题，所以在他的基础上进行开发,并且上手也比较容易 主要用法 引入 1let nodeExcel = require('excel-export'); 创建配置对象 12345let conf = &#123; stylesXmlFile, // 约束文件（不然生成的excel打开会报一些问题） cols, // 可理解为表头 [&#123; caption: 'columnName', type: 'string' &#125;], 这里出于方便,type为string,具体可移步其文档查看 rows, // 可以理解为填充的数据 ['wechat', 'mp']&#125; 创建流对象 123let result = nodeExcel.execute(conf)// 普通node后端可以直接使用 res.end(result, &apos;binary&apos;); 进行下载，要记得添加相应的头，其文档里也有说明// 最终可以使用 Buffer.from(result.toString(), &apos;binary&apos;) 转换为一个Buffer对象 嵌入云开发大致的思路就是 [拉取数据] -&gt; [生成excel流对象] -&gt; [上传到云存储中] -&gt; [返回该fileID] 几个踩坑点 读入文件要使用 path.resolve(__dirname, &#39;xxx&#39;) 得到excel流对象 使用 Buffer.from(result.toString(), &#39;binary&#39;) 再配合cloud.uploadFile 生成时conf要配置stylesXmlFile,不然打开文件总有个提示，很不爽!,styles.xml这个文件可以在node_modules/excel-export/example/styles.xml找到。 数据和表头最好是对应的，数据也可以存在空值 云函数目录结构123456- testDownload- |- index.js- |- styles.xml- |- package.json- |- package-lock.json- |- node_modules (在开发工具中应该是不显示的) package.json中的依赖1234"dependencies": &#123; "excel-export": "^0.5.1", "wx-server-sdk": "latest"&#125; index.js文件代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 云函数入口文件const cloud = require('wx-server-sdk')const nodeExcel = require('excel-export')const fs = require('fs')const path = require('path')cloud.init(&#123; env: "xxxx" // 你的环境&#125;)const db = cloud.database()// 生成分数项并且下载对应的excelexports.main = async (event, context) =&gt; &#123; let collectionId = '123666' // 模拟的集合名 let openId = 'sda6248daa888764' // 模拟openid let confParams = ['姓名', '学号', '签到时间'] // 模拟表头 let jsonData = [] // 获取数据 await db.collection(collectionId).get().then(res =&gt; &#123; jsonData = res.data &#125;) // 转换成excel流数据 let conf = &#123; stylesXmlFile: path.resolve(__dirname, 'styles.xml'), name: 'sheet', cols: confParams.map(param =&gt; &#123; return &#123; caption: param, type: 'string' &#125; &#125;), rows: jsonToArray(jsonData) &#125; let result = nodeExcel.execute(conf) // result为excel二进制数据流 // 上传到云存储 return await cloud.uploadFile(&#123; cloudPath: `download/sheet$&#123;openId&#125;.xlsx`, // excel文件名称及路径，即云存储中的路径 fileContent: Buffer.from(result.toString(), 'binary'), &#125;) // json对象转换成数组填充 function jsonToArray (arrData) &#123; let arr = new Array() arrData.forEach(item =&gt; &#123; let itemArray = new Array() for (let key in item) &#123; if (key === '_id' || key === '_openid') &#123; continue &#125; itemArray.push(item[key]) &#125; arr.push(itemArray) &#125;) return arr &#125; &#125; 触发云函数，可以看到云存储中有了刚刚生成的文件数据库中的数据,由于表头都是一样的，所以这边的key可以适当的简化，但是要注意数据库中拉取数据顺序的问题 最终生成的excel]]></content>
      <tags>
        <tag>wxmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.jQuery中选择元素的相关]]></title>
    <url>%2F2019%2F06%2F01%2FjQuery%E4%B8%AD%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[jQuery中最后都是输出一个伪数组，也即本质是一个对象，{0:xx, 1:xx, length:2}为其准备了length，也即可以使用循环，但是不能使用数组的内置方法1234for(let i = 0; i &lt; this.lenth; i++)&#123; let temp = this[i] // 其实是通过一个字面量的方式取到了对象内部的数据。&#125;this.slice() // x 报错，其不是一个数组 一般情况下，会出现 123456$('&lt;div&gt;&lt;/div&gt;') // 创建元素$('#dv1') // 选择id$('.div a.active') // 复杂的选择器$(document) // 传入的对象$(function () &#123; &#125;) // 页面加载函数$('[]') $('&#123;&#125;') // 一些其他的 首先他都是通过一些正则的判断，用来匹配，用if else来分治不同的情况。 $(&#39;&lt;div&gt;&lt;/div&gt;&#39;) $(&#39;&lt;div title=&#39;div&#39; html=&quot;div&quot;&gt;&lt;/div&gt;&#39;)html标签的形式主要使用jQuery.parseHTML解析成html字符串的形式，并最后jQuery.merge来混合成位数组，如果里面有属性，则遍历这个属性,如果是jQuery定义的方法，如css(),html(),就采用 this[ key ] (this[key]) 否则进行属性添加，this.attr(key, this[key]) $(&#39;#dv1&#39;)id的形式主要通过提取其id并且通过js原生方法getElementById用来获取dom,之后挂载到this后输出即可 $(&#39;.div a.active&#39;)复杂的选择器主要通过使用jQuery的内置方法find来进行寻找，其find内部使用了sizzle引擎进行查找 $(function () { })function 页面加载函数直接将其挂载到rootjQuery.ready() 上面，页面加载函数 $(&#39;[]&#39;) $(&#39;{}&#39;)其他一些形式通过jQuery.makeArray，传入两个参数，变成一个伪数组后输出即可 注意jQuery中的伪数组里面都是dom对象，这也就解释了为什么可以通过$(&#39;&#39;)[0] $(&#39;&#39;).get(0) 来转换成dom对象，（get方法内部就是this[num]，如果是负数 -&gt; 从后往前取，那么就是this[this.length+num]） dom对象转换成jQuery对象只需要 $(dom),如果是对象的话this[0] = dom 直接挂载上去即可]]></content>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.对创建jQuery的理解]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%AF%B9%E5%88%9B%E5%BB%BAjQuery%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[关于jQuery中创建对象的相关，jQuery.fn.init.prototype = jQuery.fn; 本文以jQuery2.0.3分析为例 关于构造函数的两个点 在JS中创建对象必须要使用new，否则就如同构建了一个普通对象，this表示未来创建的实例， 并返回this 123456function Student (school) &#123; this.school = school&#125;new Student('hdu') // 创建了对象 &#123;school: 'hdu'&#125;Student('hdu') // 仅仅是执行了一个函数 并无其他作用 如果构造函数中有返回值return xxx 如果xxx是个复杂类型（对象,数组…）时，最终返回这个复杂类型（对象,数组…） 1234567891011function Student (school) &#123; this.school = school return 666&#125;new Student('hdu') // &#123;school: 'hdu'&#125;function Student (school) &#123; this.school = school return &#123;name: 'LiHua'&#125;&#125;new Student('hdu') // &#123;name: 'LiHua'&#125; jQuery.fn.init.prototype = jQuery.fn的作用 首先在jQuery中定义了 jQuery.fn = jQuery.prototype ，其应该是方便后续的调用，fn就是prototype 我们在调用jQuery的时候，是采用$(&#39;&#39;)($ = jQuery) 我们都知道jQuery是面向对象的思想，其$(&#39;&#39;).css(),那么我们就能推测出来，$(&#39;&#39;)返回值是一个对象，但是之前我们看到构造函数必须要使用new这个关键字才行,也就是new $(&#39;&#39;)，然而jQuery目的就是让我们write less,所以我们自然就推测出来，$(&#39;&#39;)他的返回值是一个对象123jQuery = function( selector, context ) &#123; return new jQuery.fn.init( selector, context, rootjQuery ); &#125; 这也就证明了我们的推测, 调用$(&#39;&#39;)其返回值是jQuery.fn.init的一个实例 那么问题又来了，我们在使用的时候，好多方法都是挂载到$原型上面的，那么既然创建出的是jQuery.fn.init的一个实例，调用$(&#39;&#39;).css() 那么这个css()应该在jQuery.fn.init的原型上才对，但是纵观源码，都是对jQuery的原型操作的，我们自己定义拓展方法也是 $.fn.myFunction,这都说明了我们确实是挂载到 $的原型上的，所以我们不妨大胆假设一下，jQuery.fn.init的原型就是jQuery的原型，这样才能很好的解释我们的推测，也就说明了我们虽然创建出的是jQuery.fn.init的一个实例，由于其原型也是jQuery的原型，所以我们给jQuery添加的拓展方法，自然就关联到jQuery.fn.init上了 带着问题向下翻，果不其然!12// Give the init function the jQuery prototype for later instantiationjQuery.fn.init.prototype = jQuery.fn; 总结jQuery为了我们书写方便，避免了new $(&#39; &#39;), 但是他的源码中帮我们new了一个对象出来，为了关联，就只能把jQuery的原型和底层帮我们new出来的这个的原型绑定在一起， 这就有一个假象： $(&#39;&#39;)，给我们 new 了一个jQuery出来。 其实我们用的是jQuery.fn.init的实例 jQuery也只是一个方法名]]></content>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解读webpack,简单实现mypack]]></title>
    <url>%2F2019%2F05%2F26%2F%E8%A7%A3%E8%AF%BBwebpack-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0mypack%2F</url>
    <content type="text"><![CDATA[虽然使用webpack有一阵日子了，但是对其内部的相关打包过程，还不是很了解，今天翻阅了相关资料后，借鉴写了一个webpack简化版本，仅是其核心的部分，mypack 了解一下requireJS的大致运行过程 这里需要node环境（用到了文件读写相关，webpack也是在node上运行的） 12345678910111213141516171819202122// a.jslet fs = require('fs')function myRequire (moduleName) &#123; // content指示文件的内容 let content = fs.readFileSync(moduleName, 'UTF8') let fn = new Function('exports', 'module', 'require', '__dirname', '__filename', content + '\n return module.exports') let module = &#123; exports: &#123;&#125; &#125; return fn(module.exports, module, myRequire, __dirname, __filename)&#125;let str = myRequire('./b.js')console.log(str)// b.jsmodule.exports = "Hello RequireJS!" 模拟一下AMD的打包方式，虽然不常用，但是对理解起来是有帮助的 可以直接在浏览器中运行12345678910111213141516171819202122232425262728293031323334353637// myAMD.jslet factories = &#123;&#125;function myDefine (moduleName, dependencies, factory) &#123; factory.dependencies = dependencies // 挂在该方法上的依赖关系 factories[moduleName] = factory // 创建对应关系&#125;function myRequire (mods, callback)&#123; let result = mods.map(mod =&gt; &#123; let factory = factories[mod] // 获取该方法 let dependencies = factory.dependencies // 获取该依赖 let exports myRequire(dependencies, function ()&#123; exports = factory.apply(null, arguments) &#125;) return exports &#125;) return callback.apply(null, result)&#125;// 申明依赖myDefine('name', [], function () &#123; return 'AMD'&#125;)myDefine('age', [], function () &#123; return 666&#125;)myDefine('person', ['name', 'age'], function (name, age)&#123; let person = 'person ' + name + ' is ' + age return person&#125;)// 引入依赖 第一种方式myRequire(['name', 'age'], function (name, age)&#123; console.log(name, age)&#125;)myRequire(['person'], function (person)&#123; console.log(person)&#125;) 其中的核心思想就是 申明了一个全局的factories，并且通过其moduleName作为key,其factory（也就是callback）作为value,在申明的过程中就已经关联到了全局的factories,后续直接从中取出即可。 在挂载其依赖的时候，require内部分别将其依赖转换为依赖的结果（map方法），这里如果再有依赖可以利用递归的方式解决。 mypack的实现 配置mypack的环境 首先在建立mypack，（并进入mypack文件夹中）并且将在bin中创建出mypack.js,并且初始化npm环境npm init -y 1234567|-mypack| |-bin| |-mypack.js| |-package.json|// 注意修改package.json中的路径问题 bin: bin/mypack.js 然后在mypack.js中文件头部#! /usr/bin/env node 不然会报没有适当的js解析器 之后我们进行链接 npm link 这样我们就全局安装，退回其他位置都可以执行命令 &gt;mypack 首先确定入口文件，出口文件的位置，也即有执行的开始位置，将解析入口文件中的内容，递归的读入，把require替换成本规则可识别的函数名（本例myRequire），并且以key(文件路径)，value(内容)的形式放到总的modules中。也即所有用到的依赖已经到内存中。 立即执行函数，并且第一个require的就是入口文件，依次执行，也就是碰见myRequire(已经在第二步全部正则替换)时，解析出内容返回。 递归的进行myRequire的解析，其参数就为之前的modules的key,通过映射关系取出内容执行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// mypack.js mypack代码#! /usr/bin/env nodelet entry = './src/index.js' // 入口文件let output = './dist/index.js' // 出口文件const fs = require('fs')const path = require('path')let modules = []let script = fs.readFileSync(entry, 'UTF8')// 匹配对应关系let replaceReg = (script) =&gt; &#123; return script.replace(/require\(['"](.+?)["']\)/g, function () &#123; let name = path.join('./src', arguments[1]) let content = fs.readFileSync(name, 'UTF8') // 对于每拿到的content都进行一次替换 content = replaceReg(content) modules.push(&#123;name, content&#125;) return `mypack_require('$&#123;name&#125;')` &#125;)&#125;script = replaceReg(script)const ejs = require('ejs')let template = `(function(modules) &#123; // 引入 function mypack_require(moduleId) &#123; var module = &#123; exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, mypack_require); return module.exports; &#125; return mypack_require("&lt;%-entry%&gt;"); &#125;) (&#123; "&lt;%-entry%&gt;": (function(module, exports, mypack_require) &#123; eval(\`&lt;%-script%&gt;\`); &#125;) // index.js的文件&lt;%for(let i = 0; i &lt; modules.length; i++)&#123;let module = modules[i]%&gt; , "&lt;%-module.name%&gt;": (function(module, exports, mypack_require) &#123; eval(\`&lt;%-module.content%&gt;\`); &#125;)&lt;%&#125;%&gt; &#125;);`// 最终result为打包后的结果let result = ejs.render(template, &#123; entry, script, modules&#125;)fs.writeFileSync(output, result)console.log('mypack success') 12345// 目录结构|-src| |a.js| |c.js| |index.js 123456789101112// index.js打包前的内容require('./a.js')console.log('hello mypack')// a.jsrequire('./c.js')console.log('hello mypack666')// c.jsconsole.log('=====c.js======') 123456789101112131415161718192021222324252627// index.js 打包后的内容(function(modules) &#123; // 引入 function mypack_require(moduleId) &#123; var module = &#123; exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, mypack_require); return module.exports; &#125; return mypack_require("./src/index.js"); &#125;) (&#123; "./src/index.js": (function(module, exports, mypack_require) &#123; eval(`mypack_require('src\a.js')console.log('hello mypack')`); &#125;) // index.js的文件 , "src\a.js": (function(module, exports, mypack_require) &#123; eval(`console.log('hello mypack666')`); &#125;) &#125;); 添加一个styleLoader,这里以函数的形式进行放入，也可以单独写一个模块引入 loader 其实就是在解析所有的代码时（递归读入代码，即replaceReg之中，对模块内容在进行一些处理） loader 解析不同的文件是根据正则表达式的后缀进行区分的。 这里针对于styleLoader中的css代码，第一是进行了压缩成一行，并且替换掉了/r/n解析时的标志，因为innerText接收的是字符串，然而字符串是无法换行的，所以只能压缩成一行，在将原来空行形成的/r/n替换掉。（文末提出一种不压缩的方案） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// mypack.js mypack代码加入了styleLoader #! /usr/bin/env nodelet entry = './src/index.js' // 入口文件let output = './dist/index.js' // 出口文件const fs = require('fs')const path = require('path')let modules = []let script = fs.readFileSync(entry, 'UTF8')//======================styleLoader申明===================let styleLoader = function (source) &#123; //模拟styleLoader return ` let style = document.createElement('style') style.innerText = $&#123;JSON.stringify(source).replace(/\\r\\n/g, '')&#125; document.head.appendChild(style) `&#125;//=====================styleLoader申明结束===================// 匹配对应关系let replaceReg = (script) =&gt; &#123; return script.replace(/require\(['"](.+?)["']\)/g, function () &#123; let name = path.join('./src', arguments[1]) let content = fs.readFileSync(name, 'UTF8') // 对于每拿到的content都进行一次替换 content = replaceReg(content)//======================应用规则===================== if(/\.css$/.test(name))&#123; content = styleLoader(content) // 处理styleLoader &#125;//=====================应用规则结束=================== modules.push(&#123;name, content&#125;) return `mypack_require('$&#123;name&#125;')` &#125;)&#125;script = replaceReg(script)const ejs = require('ejs')let template = `(function(modules) &#123; // 引入 function mypack_require(moduleId) &#123; var module = &#123; exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, mypack_require); return module.exports; &#125; return mypack_require("&lt;%-entry%&gt;"); &#125;) (&#123; "&lt;%-entry%&gt;": (function(module, exports, mypack_require) &#123; eval(\`&lt;%-script%&gt;\`); &#125;) // index.js的文件&lt;%for(let i = 0; i &lt; modules.length; i++)&#123;let module = modules[i]%&gt; , "&lt;%-module.name%&gt;": (function(module, exports, mypack_require) &#123; eval(\`&lt;%-module.content%&gt;\`); &#125;)&lt;%&#125;%&gt; &#125;);`// 最终result为打包后的结果let result = ejs.render(template, &#123; entry, script, modules&#125;)fs.writeFileSync(output, result)console.log('mypack success') 123456// 目录结构|-src| |a.js| |c.js| |b.css| |index.js 123456789101112131415161718// index.js打包前的内容require('./a.js')require('./b.css')console.log('hello mypack')// a.jsrequire('./c.js')console.log('hello mypack666')// c.jsconsole.log('=====c.js======')//b.cssbody&#123; background: hotpink;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243// index.js 打包后的内容(function(modules) &#123; // 引入 function mypack_require(moduleId) &#123; var module = &#123; exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, mypack_require); return module.exports; &#125; return mypack_require("./src/index.js"); &#125;) (&#123; "./src/index.js": (function(module, exports, mypack_require) &#123; eval(`mypack_require('src\a.js')mypack_require('src\b.css')console.log('hello mypack')`); &#125;) // index.js的文件 , "src\c.js": (function(module, exports, mypack_require) &#123; eval(`console.log('=====c.js======')`); &#125;) , "src\a.js": (function(module, exports, mypack_require) &#123; eval(`mypack_require('src\c.js')console.log('hello mypack666')`); &#125;) , "src\b.css": (function(module, exports, mypack_require) &#123; eval(` let style = document.createElement('style') style.innerText = "body&#123; background: hotpink;&#125;" document.head.appendChild(style) `); &#125;) &#125;); 不压缩css的一种写法 123456789style.innerText = \\\` $&#123;source&#125; \\\`// 代码在构建的时候 输出到index.js变成了 evel(` ...\` backgrounde... \` ... `)// 代码再被执行的时候，执行evel的时候，就以模板字符串` background ...` 呈现出来// index.js 打包后变为style.innerText = \` body&#123; background: hotpink;&#125; \`]]></content>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[种好每一颗土豆]]></title>
    <url>%2F2019%2F05%2F24%2F%E7%A7%8D%E5%A5%BD%E6%AF%8F%E4%B8%80%E9%A2%97%E5%9C%9F%E8%B1%86%2F</url>
    <content type="text"><![CDATA[感谢75岁的任老先生 “风口浪尖”的华为 这几天由于美国相关政策，华为的芯片西方供应链似乎全部断裂，加上之前孟女士被加拿大政府软禁，就在这样一个紧急关头，大家都在担心华为今后发展之时，任老先生的采访似乎形成了巨大反差，就连我们的央视记者都感到诧异，而在他的回答中，无不显示一个掌舵人的沉稳。 种好每一颗土豆 任老先生的回答中，关于基础教育谈到了很多，也提到公司内部的数学家，物理学家，以及工程师，全球人才的引进,生于忧患死于安乐。这都是值得我们思考的问题。或许不能带上过于偏激的想法，真正的发展，才是最重要的，就如任老先生所说，在攀登珠峰的道路上，我们暂时滑了下去，但是有朝一日，我们会在峰顶携手共进。 在这样的环境下，似乎都有了去搞芯片的想法，但给我影响最大的，就是那句“种好每一个土豆”，我们怎样爱国，并不是买他的手机，也不是一窝蜂去干什么，各行各业都对祖国有贡献，或许我们种好每一颗土豆，就是对祖国最大的支持。 加油！“愿有朝一日，我们在珠峰携手共进。”]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache2的安装与配置]]></title>
    <url>%2F2019%2F05%2F23%2FApache2%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[当前环境Centos7 安装Apache yum install httpd httpd 启动 service httpd start httpd 状态查看 service httpd status httpd 停止 service httpd stop 安装目录介绍 Apache默认将网站的根目录指向/var/www/html 默认的主配置文件/etc/httpd/conf/httpd.conf 配置存储在的/etc/httpd/conf.d/目录 如果出现外部设备无法访问的情况，应该调试相关的防火墙配置]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[45天的诞生]]></title>
    <url>%2F2019%2F05%2F20%2F45%E5%A4%A9%E7%9A%84%E8%AF%9E%E7%94%9F%2F</url>
    <content type="text"><![CDATA[记第一个微信小程序的上线 从0405号创建项目开始，到慢慢探索，中间确实收获了不少的知识，最开始是为了’微信小程序比赛’,但是在不断的打磨当中，才慢慢发现做一个应用也并非写一个程序，需要不断地打磨，或许有写好的功能，又要被砍去，或许几天后发现之前的做法简直蠢极了，更多的感悟，都融进了这个应用里，感谢它带给我的成长，继续加油吧！]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一百万种可能]]></title>
    <url>%2F2019%2F05%2F05%2F%E4%B8%80%E7%99%BE%E4%B8%87%E7%A7%8D%E5%8F%AF%E8%83%BD%2F</url>
    <content type="text"><![CDATA[2018/11/16-2019/05/05 一共170天 不知不觉，这样过去了快半年，明天5.6号就结束了，一瞬间有一百万种可能，感谢成长，这一阵子失去了很多，也获得了很多，很多的意想不到，很多的突然闯入，感谢这一阵子让我成长的人和事，明天开始就要努力学习了，或许自己还没有很多能力去干很多事情，或许还有好多，回想起之前的种种不舍，但是，还是要继续向前，加油吧，浩南，路还很长，一定不要放弃，给自己加油，你是最棒的！]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vm连接虚拟机]]></title>
    <url>%2F2019%2F05%2F04%2F%E4%BD%BF%E7%94%A8vm%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[基于Centos7 参考:https://blog.csdn.net/n950814abc/article/details/79512834#commentBox 设置虚拟机网络设置使用vmnet8 即（NAT模式）记住子网IP与子网掩码 比如 子网IP：192.168.204.0 子网掩码：255.255.255.0 网络配置，电脑中网络适配器VMare8 Network Adapter注意ip地址，是电脑最为一台机器的ip如 192.168.204.6 子网掩码，默认网关填写之前即可 DNS服务器可以使用8.8.8.8 / 114.114.114.114 配置linux中的网络配置vim /etc/sysconfig/network-scripts/ifcfg-ens33 （这里为ifcfg-ens33根据实际情况来） 修改配置：BOOTPROTO=static // 静态ip 新增地址：如 123IPADDR=192.168.204.134 // 分配的ipNERMASK=255.255.255.0 // 子网掩码GATEWAY=192.168.204.1 // 默认网关 重启linux的网络配置service network restart 查看ip地址ifconfig 查看ens33那个 理解 之前一直在纠结linux是否要联网才能用，因为是我自己配置的？为什么要联网？ 这里其实是连接本地服务的那个网，所以才要在那里配置开机自启动。 外部电脑地址到底是x.x.x.1还是要另外设置? 主机也相当于一台电脑，和虚拟机中平起平坐，只不过是它连接的正好是他自己的服务，但是也要给他一个内网ip,所以之前设置了电脑上为192.168.204.6，在windows中查看也可以看到。而192.168.204.1是默认网关只要和默认网关不同就可以。]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nginx部署前端项目]]></title>
    <url>%2F2019%2F04%2F26%2F%E4%BD%BF%E7%94%A8nginx%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[当前环境 centos7 安装相关依赖 gcc 安装 安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装： yum install gcc-c++ PCRE pcre-devel 安装 PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令： yum install -y pcre pcre-devel zlib 安装 zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。 yum install -y zlib zlib-devel OpenSSL 安装 OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。 yum install -y openssl openssl-devel 下载nginx1234wget -c https://nginx.org/download/nginx-1.10.1.tar.gz# 搜狐镜像wget -c http://mirrors.sohu.com/nginx/nginx-0.1.8.tar.gz 解压nginxtar -xzvf nginx-1.10.1.tar.gz 安装（进入解压目录） ./configure make make install 查看nginx的安装目录whereis nginx 测试nginx ./nginx 开区服务 ./nginx -s quit 关闭服务 部署项目 切换到安装目录中的conf文件夹 编辑vim nginx.config1234location / &#123; root &lt;项目的路径&gt;; index index.html index.htm;&#125; 启动nginx查看运行情况 ps -ef | grep nginx 查看nginx运行的情况以及pid ./nginx -s quit 注意 以上操作需在nginx安装目录中，（可参考linux环境变量相关知识）]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于云开发中云函数超时定义]]></title>
    <url>%2F2019%2F04%2F19%2F%E5%85%B3%E4%BA%8E%E4%BA%91%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BA%91%E5%87%BD%E6%95%B0%E8%B6%85%E6%97%B6%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[在云函数中的定义里，有一个关于超时的概念，这里并不是程序实际运行的时间，而是一个预期运行的时间 比如一个程序跑下来仅用了 8ms 但是他一直在等待内部的异步操作执行完才会关闭，这里就是异步操作超时，导致整个请求超时。（20s是截止目前云函数最长运行时间）12345678910111213141516171819202122232425262728293031323334353637console.log('======= start ===')console.log(new Date().getTime()) // 1555601179634db.collection("testCollection").get() .then(res =&gt;&#123; console.log('===第一次====') console.log(new Date().getTime()) // 1555601179843 return timeout(5000) &#125;) .then(res =&gt;&#123; console.log('===第二次====') console.log(new Date().getTime()) // 1555601184847 return timeout(5000) &#125;) .then(res =&gt;&#123; console.log('===第三次====') console.log(new Date().getTime()) // 1555601189853 return timeout(5000) &#125;) .then(res =&gt;&#123; console.log('===第四次====') console.log(new Date().getTime()) // 1555601194853 return timeout(5000) &#125;) .then(res =&gt;&#123; console.log('===第五次====') console.log(new Date().getTime()) // 这里已经是超时区了 return timeout(5000) &#125;)console.log('======= end ===')console.log(new Date().getTime()) // 1555601179642// 封装的Promise的等待函数function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;]]></content>
      <tags>
        <tag>wxmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02关于云函数中await与async的理解]]></title>
    <url>%2F2019%2F04%2F19%2F%E5%85%B3%E4%BA%8E%E4%BA%91%E5%87%BD%E6%95%B0%E4%B8%ADawait%E4%B8%8Easync%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在小程序云开发的服务端交互数据库的案例中，官方文档都用了async与await,其实是为了更好的表示出先后次序 核心语法123async function()&#123; await asyncFunction() // 等待异步函数的执行&#125; 其实他会阻塞函数，可以理解为把一个异步活生生变成同步了 示例123456789101112;(() =&gt; &#123; console.log(new Date().getTime()) // 1555597655277 timeout(5000) console.log(new Date().getTime()) // 1555597655279&#125;)();(async () =&gt; &#123; console.log(new Date().getTime()) // 1555597655277 await timeout(5000) console.log(new Date().getTime()) // 1555597655279&#125;)() 那么可以看出，这样做的目的，一方面是为了严控代码的执行顺序，另一方便也省去了很多考虑异步的麻烦。]]></content>
      <tags>
        <tag>wxmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue-fullpage]]></title>
    <url>%2F2019%2F04%2F05%2Fmpvue-fullpage%2F</url>
    <content type="text"><![CDATA[自定义的fullpage效果, 其核心是top属性的改变 起步 复制此模板去自己的项目中 每一个滚动屏div添加上class:section 在totalPageNum填入当前滚动屏的数量 使用了一些技巧 css高度属性 hv, wv, 高度，宽度的视口大小， 100hv = 1 viewport height 等等 为了双向数据绑定，将变化的css属性 以style属性的方式写在了标签内部。 预览效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212&lt;template&gt; &lt;div class=&quot;fullpage-container&quot;&gt; &lt;div class=&quot;fullpage-container-fill&quot;&gt; &lt;div class=&quot;scroll-fullpage&quot; :style=&quot;&#123; top: top &#125;&quot; ref=&quot;fullpage&quot;&gt; &lt;div id=&quot;hook1&quot; class=&quot;section section01&quot; :class=&quot;&#123; active: scrollindex === 0 &#125;&quot; @touchstart=&quot;scrollTouchStart&quot; @touchmove=&quot;scrollTouchMove&quot; @touchend=&quot;scrollTouchEnd&quot; &gt; &lt;div class=&quot;cont&quot;&gt; &lt;div class=&quot;cont-body&quot;&gt; &lt;h1&gt;排队挂号&lt;/h1&gt; &lt;h3&gt;腰腿痛---&gt;建议前往骨伤科就诊&lt;/h3&gt; &lt;p&gt;①&lt;/p&gt; &lt;h4&gt;↓↓↓↓↓&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;hook2&quot; class=&quot;section section02&quot; :class=&quot;&#123; active: scrollindex === 1 &#125;&quot; @touchstart=&quot;scrollTouchStart&quot; @touchmove=&quot;scrollTouchMove&quot; @touchend=&quot;scrollTouchEnd&quot; &gt; &lt;div class=&quot;cont&quot;&gt; &lt;div class=&quot;cont-body&quot;&gt; &lt;h1&gt;前往骨伤科&lt;/h1&gt; &lt;h3&gt;三楼，电梯口右侧&lt;/h3&gt; &lt;p&gt;②&lt;/p&gt; &lt;h4&gt;↓↓↓↓↓&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;hook3&quot; class=&quot;section section03&quot; :class=&quot;&#123; active: scrollindex === 2 &#125;&quot; @touchstart=&quot;scrollTouchStart&quot; @touchmove=&quot;scrollTouchMove&quot; @touchend=&quot;scrollTouchEnd&quot; &gt; &lt;div class=&quot;cont&quot;&gt; &lt;div class=&quot;cont-body&quot;&gt; &lt;h1&gt;预约医师&lt;/h1&gt; &lt;h3&gt;请将您的挂号单与前台处扫描&lt;/h3&gt; &lt;p&gt;③&lt;/p&gt; &lt;h4&gt;↓↓↓↓↓&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;hook4&quot; class=&quot;section section04&quot; :class=&quot;&#123; active: scrollindex === 3 &#125;&quot; @touchstart=&quot;scrollTouchStart&quot; @touchmove=&quot;scrollTouchMove&quot; @touchend=&quot;scrollTouchEnd&quot; &gt; &lt;div class=&quot;cont&quot;&gt; &lt;div class=&quot;cont-body&quot;&gt; &lt;h1&gt;收费处缴纳医药费&lt;/h1&gt; &lt;h3&gt;一楼，大厅，进大门右手处&lt;/h3&gt; &lt;p&gt;④&lt;/p&gt; &lt;h4&gt;↓↓↓↓↓&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; scrollindex: 0, // 当前页面的索引值 totalPageNum: 4, // 总共页面数 starty: 0, // 开始的位置x startTime: 0, // 开始的时间戳 endy: 0, // 结束的位置y endTime: 0, // 结束的时间戳 critical: 120, // 触发翻页的临界值 maxTimeCritical: 300, // 滑动的时间戳临界值上限 minTimeCritical: 100 // 滑动的时间戳临界值下限 &#125;; &#125;, computed: &#123; top() &#123; // 计算当前往上的距离 return this.scrollindex * -100 + &apos;vh&apos;; &#125; &#125;, methods: &#123; scrollTouchStart(e) &#123; e = e.mp; // 获取开始点击点 this.starty = e.touches[0].pageY; // 获取当前点击时间 this.startTime = e.timeStamp; &#125;, scrollTouchMove(e) &#123;&#125;, scrollTouchEnd(e) &#123; e = e.mp; // 获取结束位置 this.endy = e.changedTouches[0].pageY; // 间隔时间 this.endTime = e.timeStamp; let timeStampdiffer = this.endTime - this.startTime; if ( // 此时判断是滑动的时间差 timeStampdiffer &lt;= this.maxTimeCritical &amp;&amp; timeStampdiffer &gt; this.minTimeCritical &amp;&amp; // 此时判断已经改变了 初始位置 &gt; 当前位置 this.starty &gt; e.changedTouches[0].pageY ) &#123; // 手势上滑 移动 this.scrollindex = this.scrollindex &gt;= this.totalPageNum-1 ? this.scrollindex : this.scrollindex + 1; &#125; else if ( // 判断时间 timeStampdiffer &lt;= this.maxTimeCritical &amp;&amp; timeStampdiffer &gt; this.minTimeCritical &amp;&amp; // 初始位置 &lt; 当前位置 手势下滑 this.starty &lt; e.changedTouches[0].pageY ) &#123; // 手势下滑 移动 this.scrollindex = this.scrollindex &lt;= 0 ? 0 : this.scrollindex - 1 ; &#125; &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;wxss&quot;&gt;#hook1 &#123; background: #9999cc;&#125;#hook2 &#123; background: #cc66cc;&#125;#hook3 &#123; background: #cc99cc;&#125;#hook4 &#123; background: #cccccc;&#125;.cont&#123; position: relative;&#125;.cont-body h4&#123; position: absolute; bottom: 100rpx; font-size: 48rpx; left: 45%; color: #fff;&#125;.cont-body p&#123; text-align: center; font-size: 80rpx; color: #fff; margin-top: 300rpx;&#125;page &#123; height: 100%; background: #fff; color: #282828;&#125;.fullpage-container &#123; height: 100%; flex: 1; flex-direction: column; box-sizing: border-box; padding: 0; align-items: initial; justify-content: first baseline;&#125;.fullpage-container-fill &#123; height: 100%; overflow: hidden; position: relative;&#125;.scroll-fullpage &#123; box-sizing: border-box; position: absolute; /* 增加动画*/ transition: top .3s linear;&#125;.section &#123; width: 100vw; height: 100vh; position: relative;&#125;.cont &#123; width: 100%; height: 100%; margin: 0 auto;&#125;&lt;/style&gt;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[orcl创建数据库基于DBCA-11g（图）]]></title>
    <url>%2F2019%2F03%2F17%2Forcl%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E4%BA%8EDBCA-11g%2F</url>
    <content type="text"><![CDATA[第1步 第2步 第3步 第4步 第5步 第6步 第7步 第8步 第9步 第10步 第11步 确认安装 最后一路等待就可以]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm中关于依赖包冲突的问题]]></title>
    <url>%2F2019%2F03%2F06%2Fnpm%E4%B8%AD%E5%85%B3%E4%BA%8E%E4%BE%9D%E8%B5%96%E5%8C%85%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[测试环境 npm-v 6.8.0 要了解npm解决包冲突的问题，就要先了解一下他是如何找包的 node中require查找依赖的方式123│ app.js│└───node_modules 一般我们们的app.js中的requier查找依赖的时候，会去目录下的node_modules去寻找 但是，实际他会以一种依次向上的方式进行寻找，这里以common模块依赖jquery为例123// common.jslet $ = require('jquery') 向外层目录寻找(当前目录没找到指定的js) 123456789│ app.js│├───common│ │ common.js│ ││ └───node_modules│ └───bootstrap└───node_modules └───jquery 首先 common.js会在本级的node_modules中寻找是否存在jquery 之后，他会向上一层目录去寻找，是否有node_modules,并去寻找 向外层目录寻找(当前目录不存在node_modules) 1234567│ app.js│├───common│ common.js│└───node_modules └───jquery 首先，common.js的本级目录不存在node_modules，直接跳向上一级目录 在上级目录中，找到了指定的js 向多层目录下寻找（直到找到根目录为止） 12345678910111213│ app.js│├───mgr│ └───public│ ├───common│ │ │ common.js│ │ ││ │ └───node_modules│ │ └───bootstrap│ └───node_modules│ └───express└───node_modules └───jquery 首先，common.js在本级的node_modules中寻找，未找到，跳转到上一级目录 查找到了public目录， 查看此目录的node_modules中寻找，未找到，跳转上一级目录 来到了mgr目录， 未找到node_modules目录，继续向上寻找 来到了项目根目录下，在本级的node_modules中，寻找到了 可以看出，他在寻找的时候，会依次向上寻找，直到根目录下 node不会去兄弟目录中查找 123456789101112│ app.js│├───common│ │ common.js│ ││ └───node_modules│ └───bootstrap├───host│ └───node_modules│ └───jquery└───node_modules └───express common.js去本级node_modules目录下寻找，没有找到，返回上一级 来到了项目根目录，去本级目录下的node_modules目录下寻找,没有找到，寻找结束，未找到。 注意，他不会钻到他的兄弟目录host中去寻找，他只能向上寻找，不能向下。 npm解决包冲突的问题 有两个相同的项目依赖了同一个文件 1234├───a│ └───c_v1.0.0└───b └───c_v2.0.0 a 依赖了1.0.0的c文件 b 依赖了2.0.0的c文件 版本不同的时候，他会分别在各自的包下建立node_modules文件 123456789101112│ app.js│└───node_modules ├───a │ └───node_modules │ └───c(v1.0.0) ├───b │ └───node_modules │ └───c(v2.0.0) ├───bootstrap ├───c └───jquery a依赖了的c包（1.0.0） (实际上没有版本号，就叫c) b依赖了的c包2.0.0 (实际上没有版本号，就叫c) 由于他查找包的机制，就会找到适合自己版本的 仅仅单个版本不同 1234567891011│ app.js│└───node_modules ├───a │ └───node_modules │ └───c(v1.0.0) ├───b ├───d ├───bootstrap ├───c └───jquery a依赖了c包（1.0.0） b也依赖的c包 d也依赖的c包 由于包查找机制，先从内层查找，依次向外翻，a会使用它特定版本的c,其他使用外部的c就好]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node中文件操作路径问题]]></title>
    <url>%2F2019%2F03%2F06%2Fnode%E4%B8%AD%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[文件分隔符 / 左-&gt; 正斜杠，\ 右 -&gt; 反斜杠 在mac, linux, unix 使用 / 分隔符 在win 使用 \ 作为分隔符， 由于\存在转义的效果，一般会使用\\ win中也可以使用/ 介绍path相关 path.basename 获取一个路径的文件名（默认包含拓展名） path.basename(‘c:/a/b.js’) -&gt; b.js path.basename(‘c:/a/b.js’, ‘.js’) -&gt; b path.dirname 获取一个路径中的目录部分 path.parse 把一个路径转换为对象 root 根目录 dir 目录 base 包含后缀名的文件名 ext后缀名 name 不包含后缀名的文件名 path.join 需要进行路径拼接的时候推荐使用这个方法（极其智能） path.join(‘c:/a/b’, ‘c’) -&gt; c:/a/b/c path.join(‘c:/a/b’, ‘/c’) -&gt; c:/a/b/c path.join(‘c:/a/b’, ‘./c’) -&gt; c:/a/b/c path.join(‘c:/a/b’, ‘../c’) -&gt; c:/a/c path.isAbsolute 判断是否是一个绝对路径 path.isAbsolute(‘c://a’) -&gt; true path.isAbsolute(‘/a’) -&gt; true (/为根目录) __dirname 与 __filename 均是动态的获取, 他们是比较特殊的成员 __dirname 文件所属目录的绝对路径 c://a/b __filename 所属文件的绝对路径 c://a/b/c.js fs模块中的相对路径 fs.readFile(‘./a.txt’, fn) 其中的路径’./a.txt’ 并不是文件所在目录为寻找 是以终端，即node运行文件时目录 c://a/b&gt; node a.js c://a/&gt; b/node a.js 虽然他们 看似相同，由于node运行目录不相同，fs.readFile时寻找不一样 c://a/b/a.txt c://a/a.txt 这是专门的一种设计，并不是一种bug,所以建议修改目录为 fs.readFile(path.join(__dirname, &#39;./a.txt&#39;), fn) 这样每次都是动态获取的，所以不会造成目录问题 注意引入path模块，一般，fs,path都是成对引入 require中的相对路径 在require中，不存在上述问题，还是引入即可， require(‘./a’) 省略模块后缀.js]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node中连接数据库]]></title>
    <url>%2F2019%2F03%2F05%2Fnode%E4%B8%AD%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[mongodb数据库，基于第三方库 mongoose(高度封装了mongodb官方文件)引入mongoose12var mongoose = require('mongoose')var Schema = mongoose.Schema 连接数据库1mongoose.connect('mongodb://localhost/test') 设计文档结构（表结构）段名称就是表结构中的属性名称, 约束的目的是为了保证数据的完整性12345678910111213var userSchame = new Schame(&#123; username: &#123; type: String, required: true // 必须有 &#125;, password: &#123; type: String, required: true &#125;, email: &#123; type: String &#125;&#125;) 将文档发布为模型1var User = mongoose.model('User', userSchame) 使用文档模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// **********************// /新增数据// **********************var admin = new User(&#123; username: 'zs', password: '123456', email: 'admin@admin.com'&#125;)admin.save(function (err, ret) &#123; if (err) &#123; console.log('保存失败') &#125; else &#123; console.log('保存成功') console.log(ret) &#125;&#125;)// **********************// /新增数据// **********************// **********************// /查询数据// **********************User.find(function (err, ret) &#123; if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret) &#125;&#125;)User.find(&#123; username: 'zs'&#125;, function (err, ret) &#123; if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret) &#125;&#125;)User.findOne(&#123; username: 'zs'&#125;, function (err, ret) &#123; if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret) &#125;&#125;)// **********************// /查询数据// **********************// **********************// /删除数据// **********************User.remove(&#123; username: 'zs'&#125;, function (err, ret) &#123; if (err) &#123; console.log('删除失败') &#125; else &#123; console.log('删除成功') console.log(ret) &#125;&#125;)// **********************// /删除数据// **********************// **********************// /更新数据 // **********************// 注意，mongodb中的_id是一个较为特殊的值, 可以查询使用，避免对象中出现_id这种属性//User.findByIdAndUpdate('5a001b23d219eb00c8581184', &#123; password: '123'&#125;, function (err, ret) &#123; if (err) &#123; console.log('更新失败') &#125; else &#123; console.log('更新成功') &#125;&#125;)// // 更新密码123 -&gt; 456User.update(&#123; password: '123' &#125;, &#123; password: '456' &#125;, fn);// // 更新密码123 -&gt; 456 多个文件User.update(&#123; password: '123' &#125;, &#123; password: '456' &#125;, &#123; multi: true &#125;, fn);// **********************// /更新数据// ********************** mysql数据库，第三方库引入数据库1var mysql = require('mysql'); 配置连接对象123456var connection = mysql.createConnection(&#123; host : 'localhost', user : 'user', password : 'password', database : 'my_db'&#125;); 连接数据库1234567// 开启连接connection.connect()...// 断开连接connection.end() SQL语句 均使用connection.query 根据不同的需要传入不同的SQL语句就可以 回调函数中的参数 error 显示错误信息 results 查询的结果 fields 改变的行的数量 12345// connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; if (error) throw error; console.log('The solution is: ', results[0].solution);&#125;);]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于javascript中的分号的问题]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%85%B3%E4%BA%8Ejavascript%E4%B8%AD%E7%9A%84%E5%88%86%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在开发中，有的编码规范可以对分号没有要求，可以省去分号;1234let name = 'nn'function foo()&#123; return &#123;&#125;&#125; 但是在一下情况中，绝对不能省略 [,(,&#39;（此处代表反引号）因为可能导致，编译错误，所以这样加上一句冒号，就能避免这样的错误。12345;(function()&#123; let foo = 'bar' &#125;)();`hello`.toString()]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配方案总结]]></title>
    <url>%2F2019%2F02%2F20%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对于移动端设备，通常就是解决不同设备的显示问题，总结常见布局的优缺点 流式布局 响应式布局 rem适配 在移动端的设备，需要进行视口的设置(类似于 浏览器-包含一个视口-包含我们看到的页面dom)，要最先解读到css属性所以一般放在头部12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"&gt; &lt;/head&gt; ....&lt;/html&gt; 其中width,视口的宽度自动跟随设备调整， inital-scale是初始化缩放级别，用户看到的和在pc端的是1:1的关系，（不会因为整体缩小，而导致字体过小无法看到） user-scalable是用户是否可以自动缩放 1 yes 或者 0 no 流式布局 流式布局的原理就是利用width:100%已达到解决响应式的问题，在这种设计基础上，一定要注意 使用边框盒子（防止溢出）box-sizing: border-box 宽度尽量使用width: 100% 比较简单，使用浏览器自适应宽度，达到自适应的效果，要注意由于使用border-box所以在设置的时候，要尽量设置爱元素的padding,防止元素溢出 双飞翼布局 两栏布局 有一款插件，是为了解决局部元素的滑动，可以使用iscroll.js,当其元素有超出的长度的时候，可以在局部进行滑动，iscroll,局部刷新 响应式布局 响应式布局主要通过媒体查询来判断当前容器的宽度之类，在执行相应的css代码 css媒体查询 @media screen and (max-width: 768px) 最大宽度为768px时执行的代码 css代码1234567891011121314151617181920212223242526272829303132333435363738*&#123; margin: 0; padding: 0;&#125;.contain&#123; width: 1000px; height: 1000px; margin: 0 auto; background: pink;&#125;@media screen and (max-width: 768px) and (min-width: 320px)&#123; .contain&#123; width: 100%; background: blue; &#125;&#125;@media screen and (max-width: 992px) and (min-width: 768px)&#123; .contain&#123; width: 750px; background: green; &#125;&#125;@media screen and (max-width: 1200px) and (min-width: 992px)&#123; .contain&#123; width: 970px; background: red; &#125; &#125;@media screen and (min-width: 1200px)&#123; .contain&#123; width: 1200px; background: yellow; &#125; &#125; html代码12345678910111213141516&lt;body&gt; &lt;!-- 媒体查询 使用css关键字 @media screen and (&lt;这里接条件&gt;) 通过查询不同的屏幕尺寸 做不同的相应（css 优先级） 需求 超小屏幕 768px 宽度100% 背景色 蓝色 小屏设备768px-992px 宽度750px 背景色 绿色 中屏设备992px-1200px 宽度970px 背景色 红色 大屏设备 1200px 宽度1170px 背景色 黄色 宽度要小于最小界限 保证显示不出现滚动条 --&gt; &lt;div class="contain"&gt;&lt;/div&gt;&lt;/body&gt; 最终的效果为 大屏设备 1200px 宽度1170px 背景色 黄色 中屏设备992px-1200px 宽度970px 背景色 红色 小屏设备768px-992px 宽度750px 背景色 绿色 超小屏幕 768px 宽度100% 背景色 蓝色 其中著名的框架有bootstrap rem适配 rem适配主要通过:html中的style中font-size从而判断出整体的页面布局样式大小，从而达到自适应。也就是在html头部统一定义了基准大小，所有尺寸按照基准大小设置，如果更改了设备，只需要动态更改基准大小，从而就能达到整个页面的自适应效果 em是以父元素为基准，rem是以根元素root(也就是&lt;html&gt;&lt;/html&gt;), 这里有一个换算， 当前基准尺寸 = （当前设备宽度/设计稿设备宽度）* 设计稿基准尺寸 使用不同屏幕下的基准值 动态的去设置html中的font-size这个基准值 假设当前设计稿 width:750px font-size:100px1234567891011121314151617181920212223242526272829303132333435363738394041// 动态设配基准值的css@meadia (min-width: 750px)&#123; html&#123; font-size:100px; // (750/750)*100 &#125;&#125;@meadia (min-width: 640px)&#123; html&#123; font-size:85.33333px; // (640/750)*100 &#125;&#125;@meadia (min-width: 414px)&#123; html&#123; font-size:55.2px; // (414/750)*100 &#125;&#125;@meadia (min-width: 320px)&#123; html&#123; font-size:42.7px; // (320/750)*100 &#125;&#125;// 样式的css代码span&#123; font-size: 0.2rem; // 设计稿中是20px 基准值是100px 相对为 20/100 rem, &#125;div&#123; width: 100%; // 设计稿中是100%的宽度 height: 0.5rem; // 设计稿中是50px 基准值是100px 相对为 50/100 rem &#125;/** 如果是到了其他设备 比如414px的设备 则在原有代码的情况下* 之前的设计稿 0.2rem = 0.2 * 100 = 20px* 就会变为0.2rem = 0.2 * 55.2 = 11.4px* 也就达到了适配的目的,等比例缩放的效果。*/ 在这里使用less编写，可以达到自动计算所有的适配屏的css代码的编写 12345678910111213141516171819202122232425262728293031323334353637383940414243@charset "UTF-8";/*variable.less*/// 适配设备的集合@adapterDeviceList:750px,720px,640px,540px,480px,424px,414px,400px,384px,375px,360px,320px;// 设计稿尺寸@psdWidth:750px;// 预设基准值@baseFontSize:100px;// 主流设备的个数@len:length(@adapterDeviceList);/*adapter.less*/// 1.适配不同宽度的基准，利用递归函数实现循环 // 2.由于这里是min-width，考虑到css从上到下读取，应该使用min-width:320,414,640,750这种顺序.adapterMixin(@index) when(@index &gt; 0)&#123; @media (min-width: extract(@adapterDeviceList, @index))&#123; html&#123; font-size: extract(@adapterDeviceList, @index) / @psdWidth * @baseFontSize; &#125; &#125; .adapterMixin(@index - 1);&#125; // 函数的使用.adapterMixin(@len);/*样式的less代码，由于less有计算功能，就比较方便*///@baseFontSize; 为之前定义过的基准font-sizespan&#123; font-size: 20rem/@baseFontSize; //设计稿是20px 直接就是20 rem / 100 = 0.2rem&#125;div&#123; width: 100%; // 设计稿中是100%的宽度 height: 50rem/@baseFontSize; // 设计稿是50px 直接就是50 rem / 100 = 0.5rem&#125; 使用了less后，可以动态的生成适配代码，并且以后的维护也比较方便,也不用去计算那些适配值，只需要带入即可 总结 无论是流式布局，响应式布局，rem布局，其实之间都用到了很多相似的地方，很多地方，都有width:100%等。并且在rem布局中很多地方也用到了width:100%，所以并不只是单一的技术实现，是多种技术共同作用，达到移动端适配的目的。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS模块化（四）ES6的应用（目前使用较广，较火）]]></title>
    <url>%2F2019%2F02%2F05%2FJS%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89ES6%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E7%9B%AE%E5%89%8D%E4%BD%BF%E7%94%A8%E8%BE%83%E5%B9%BF%EF%BC%8C%E8%BE%83%E7%81%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ES6模块化需要编译打包处理，由于目前部分浏览器不支持es6，需要先转换es5 基本使用 暴露出去 export 应用进来 import 使用方式 先用babel转化es5 使用browserify编译转换 需要提前安装一些库npm install babel-cli browserify -gnpm install babel-preset-es2015 --save-dev 自定义依赖 文件结构 （列举了主要部分） 1234567891011│ .babelrc│ package-lock.json│ package.json│├─js│ ├─dist│ └─src│ main.js│ modules1.js│ modules2.js│ modules3.js .babelrc (babel run controller) 123&#123; "presets":["es2015"]&#125; 各个模块文件 1234567891011121314151617181920212223242526272829303132333435363738modules1.js// 暴露模块 分别暴漏export function foo()&#123; console.log("foo() module1");&#125;export function bar()&#123; console.log("bar() module1");&#125;export let arr = [1,2,3,4,5];modules2.js// 暴露模块 统一暴露function fun1 () &#123; console.log("fun1() module2");&#125;function fun2 () &#123; console.log("fun2() module2");&#125;export &#123;fun1, fun2&#125;modules3.js// 默认暴露 export default export default &#123; msg:"默认暴露", foo()&#123; console.log("foo() modules3",this.msg); &#125;&#125; 主文件 main.js 123456789101112131415161718// 引入其他模块// 语法 import xxx from '路径'// 统一暴露方式 统一暴露方式 是要什么取什么import &#123;foo, bar, arr&#125; from './modules1';import &#123;fun1, fun2&#125; from './modules1';// 默认暴露import modules3 from './modules3';foo(); // foo() module1bar(); // bar() module1console.log(arr); // [ 1, 2, 3, 4, 5 ]fun1(); // fun1() module2fun2(); // fun2() module2 modules3.foo(); // foo() modules3 默认暴露 编译打包 babel命令 es6-es5 babel js/src -d js/lib 使用browserift命令 browserify js/src/main.js -o js/dist/bundle.js 将最终的bundle放入index.html 1&lt;script type="text/javascript" src="04-ES6/js/dist/bundle.js" &gt;&lt;/script&gt; 这种方式需要首先使用babel将es6-es5,在使用browserify进行编译打包，每一次改变都需要这样，相对较为繁琐（所以就有了后面的自动打包工具） 使用第三方依赖 在npm安装依赖 （jquery为例 npm install jquery@1.12.4） 在主文件中引入即可 123import $ from "jquery";$("body").css("background","yellowgreen"); 使用babel与browserify分别进行编译 打包 最后html代码还是 放入browserify最终生成的代码 1&lt;script type="text/javascript" src="04-ES6/js/dist/bundle.js" &gt;&lt;/script&gt; 使用ES6的这种方式 相对来时 是比较简单的，而且命令也相对好记 export与import这种方式也是使用最为广泛，目前比较好的一种方式，唯一不好的就是需要每一次都编译打包，后来诞生出一些自动化工具。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS模块化（三）AMD(Asynchronous Module Definition)的应用]]></title>
    <url>%2F2019%2F02%2F05%2FJS%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89AMD(Asynchronous%20Module%20Definition)%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基本使用 暴露出去 123456789// 定义没有依赖的模块define(function()&#123; return 模块 &#125;)// 定义有依赖的模块define(['module1','module2'],function(m1,m2)&#123; return 模块&#125;) 应用进来 123requirejs(['module1','module2'],function(m1,m2)&#123; 使用m1,m2即可&#125;) 自定义依赖的引用 文件的结构 1234567891011└─js │ main.js │ ├─libs │ require.js │ └─modules alerter.js dataService.js││ index.html modules 的文件 123456789101112131415161718192021222324dataService.jsdefine(function () &#123; let name = "dataService.js"; function getName()&#123; return name; &#125; // 向外暴露模块 return &#123;getName&#125;;&#125;)alerter.jsdefine(['dataService'],function (dataService) &#123; let msg = "alerter.js"; function showMsg()&#123; console.log(msg, dataService.getName()); &#125; // 向外暴露模块 return &#123;showMsg&#125;;&#125;) 主文件main.js 12345678910111213141516(function() &#123; // 配置requirejs requirejs.config(&#123; baseUrl: "js/", paths: &#123; dataService: './modules/dataService', alerter: './modules/alerter' &#125; &#125;); // 引入依赖 requirejs(['alerter'], function(alerter) &#123; alerter.showMsg(); // alerter.js dataService.js &#125;);&#125;)() html文件 1&lt;script data-main="js/main.js" src="js/libs/require.js"&gt;&lt;/script&gt; 这种方式需要做requirejs的配置，之后再引入js文件的时候，注意src是requre.js 而data-main才是我们的main.js,这种方式是针对客户端较早出现的一种方式 引入第三方的依赖 （引入jQuery为例） 放入相关的js，文件结构 123456789101112│ index.html│└─js │ main.js │ ├─libs │ jquery-1.11.0.js │ require.js │ └─modules alerter.js dataService.js 其余和之前相同，就是引入第三方库即可，main.js 12345678910111213141516171819(function() &#123; // 配置requirejs requirejs.config(&#123; baseUrl: "js/", paths: &#123; dataService: './modules/dataService', alerter: './modules/alerter', jquery: './libs/jquery-1.11.0' // jQuery源码中 遵循了AMD规范 并且暴露模块为jquery &#125; &#125;); // 引入依赖 requirejs(['alerter',"jquery"], function(alerter,$) &#123; alerter.showMsg(); $("body").css("background","deeppink"); &#125;);&#125;)() html文件 1&lt;script data-main="js/main.js" src="js/libs/require.js"&gt;&lt;/script&gt; 都是在内部引入的，所以发请求只需要一个请求就可以搞定，只需要配置好模块路径即可]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS模块化（二）CommonJS的应用]]></title>
    <url>%2F2019%2F02%2F05%2FJS%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89CommonJS%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基本使用 暴露出去 module.exports = value或者是exports.xxx = value 引入进来 let xxx = require(&quot;./modules/xxx&quot;); 补充：因为exports是 module.exports的一个引用，也就相当于在代码中，还有 var exports = module.exports,所以他们俩是等价的，但是要注意一点， 12345678910// 可理解为 var exports = module.exports 系统自动做的// 导出的时候 是 return module.exportsexports.foo = bar // module.exports.foo = barexports = &#123;&#125; // 这里改变了exports的指向， // 指向了一个新的对象后，而不是module.exportexports.age = 16 // 所以在导出的时候，不会有这个age// 也就是相当于exports如果改变了指向，// 那么以后添加的方法则不会暴露出去，（改变指向后，无法修改到原对象了） CommonJS-node(服务端) 首先部署出文件的结构 12345678├─modules│ modules1.js│ modules2.js│ modules3.js││ app.js│ package-lock.json│ package.json modules的文件 1234567891011121314151617181920212223242526272829303132module1.js// 使用module.exports = valuemodule.exports = &#123; msg:"module1", foo()&#123; console.log("foo() " + this.msg); &#125;&#125;module2.js// 使用module.exports = valuemodule.exports = function () &#123; console.log("foo() module2");&#125;module3.js// 使用exports.xxx = valueexports.foo = function()&#123; console.log("foo() module3");&#125;exports.bar = function() &#123; console.log("bar() module3");&#125;// 暴露一个数组出去exports.arr = [1,2,3,4,5,2,3,1,2,4]; app.js主配置文件 使用node app.js运行 1234567891011121314151617181920app.js// 提前引入第三方库// 引入uniqlet uniq = require("uniq");// 将其他模块汇总到主模块let module1 = require("./modules/modules1");let module2 = require("./modules/modules2");let module3 = require("./modules/modules3");module1.foo(); // foo() module1module2(); // foo() module2module3.foo(); // foo() module3module3.bar(); // bar() module3console.log(module3.arr); // [ 1, 2, 3, 4, 5, 2, 3, 1, 2, 4 ]let result = uniq(module3.arr);console.log(module3.arr); // [ 1, 2, 3, 4, 5 ] 在服务端运行的时候 语法相对简单，要注意第三方库要放在最开始的地方，因入库写名字就可以 CommonJS-Browserify(客户端) 首先部署出文件的结构 12345678910├─js│ ├─dist│ └─src│ app.js│ modules1.js│ modules2.js│ modules3.js││ package-lock.json│ package.json modules的文件 1234567891011121314151617181920212223242526272829303132module1.js// 使用module.exports = valuemodule.exports = &#123; msg:"module1", foo()&#123; console.log("foo() " + this.msg); &#125;&#125;module2.js// 使用module.exports = valuemodule.exports = function () &#123; console.log("foo() module2");&#125;module3.js// 使用exports.xxx = valueexports.foo = function()&#123; console.log("foo() module3");&#125;exports.bar = function() &#123; console.log("bar() module3");&#125;// 暴露一个数组出去exports.arr = [1,2,3,4,5,2,3,1,2,4]; app.js文件 123456789101112131415161718// 提前引入第三方库// 引入uniqlet uniq = require("uniq");// 将其他模块汇总到主模块let module1 = require("./modules/modules1");let module2 = require("./modules/modules2");let module3 = require("./modules/modules3");module1.foo();module2();module3.foo();module3.bar();console.log(module3.arr);let result = uniq(module3.arr);console.log(module3.arr); 打包处理jsbrowserify js/src/app.js -o js/dist/bundle.js 在 页面引入 （运行结果与之前相同） 1&lt;script type="text/javascript" src="js/dist/bundle.js" &gt;&lt;/script&gt; 在客户端运行的时候，要放到dist生成环境的文件夹，要进行打包处理才能变成浏览器识别的文件]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS模块化（一）]]></title>
    <url>%2F2019%2F02%2F05%2FJS%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[js发展历史 全局function的方式12345678910module.jsfunction foo () &#123; console.log("foo() "); &#125;function bar()&#123; console.log("bar() ");&#125; 1&lt;script type="text/javascript" src="module.js" &gt;&lt;/script&gt; 这种方式虽然带来了简便方式，但是一定程度上造成了命名冲突的问题，并且在后期难以维护，是一个比较严重的问题，污染全局变量 采用namespace的方式12345678module.jslet obj = &#123; msg : "module", foo()&#123; console.log("foo()" + this.msg); &#125;&#125; 123456&lt;script type="text/javascript" src="module.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; obj.foo(); // foo()module obj.msg = "namespace"; obj.foo(); // foo()namespace&lt;/script&gt; 这种方式虽然解决了命名冲突的问题，但是不安全，由于使用对象进行封装，所以仍然可以修改对象中的内容 采用IIFE的方式1234567891011module.js// 采用闭包的方式 IIFE(function (window) &#123; let msg = "module"; function foo()&#123; console.log("foo() " + msg); &#125; // 暴露出去对象 window.obj = &#123;foo&#125;;&#125;)(window) 1234567&lt;script type="text/javascript" src="module.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; msg = "IIFE"; // 此时为隐式全局变量 obj.foo(); // foo() module obj.msg = "IIFE"; // 由于存在了闭包，修改的并不是那一个数据 obj.foo(); // foo() module&lt;/script&gt; 这种方式通过全局变量传递出去模块名称，而且采用了立即执行函数相对数据较安全，也是比较好的一种模块定义方式 采用IIFE-引入依赖的方式 这种方式是IIFE的增强模式，由IIFE发展而来，也是今后的js模块化的一种标准1234567891011module.js(function (window,$) &#123; let msg = "module"; function foo () &#123; console.log("foo() " + msg); &#125; window.obj = &#123;foo&#125;; // 此时引入第三方库的方法 $("body").css("background","deeppink");&#125;)(window,jQuery) 12345&lt;script type="text/javascript" src="jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;script type="text/javascript" src="module.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; obj.foo(); // foo() module&lt;/script&gt; 这是在IIFE上发展而来的一种方式，引入了第三方的依赖，但是由于有依赖关系，一定要注意引入的顺序，由于module.js引入了jquery,所以jquery要先被解析 传统的相互依赖演示 文件的结构 123456└─js alerter.js dataService.js││ app.js│ index.html module的文件 1234567891011121314151617181920212223dataService.js// 定义一个没有依赖的模块(function (window) &#123; let name = "dataService.js"; function getName()&#123; return name; &#125; // 暴露出去 window.dataService = &#123;getName&#125;;&#125;)(window)alerter.js// 定义一个有依赖的模块(function (window,dataService) &#123; let msg = "alerter.js"; function showMsg()&#123; console.log(msg, dataService.getName()); &#125; // 暴露出去 window.alerter = &#123;showMsg&#125;;&#125;)(window,dataService) app.js的主文件 123456app.js// 直接调用alerter.js(function (alerter) &#123; alerter.showMsg(); // alerter.js dataService.js&#125;)(alerter) html文件 123&lt;script type="text/javascript" src="js/dataService.js" &gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/alerter.js" &gt;&lt;/script&gt;&lt;script type="text/javascript" src="app.js" &gt;&lt;/script&gt; 由于他们之间产生了依赖关系 所以一定要弄清楚之间的关系，引入顺序很重要 在这些传统的方式上产生了一些引入js的标准 CommonJS AMD CMD(目前使用不广泛) ES6接下来会分别介绍 CommonJS,AMD，ES6引入依赖的方式]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-祝自己]]></title>
    <url>%2F2019%2F02%2F05%2F2019-%E7%A5%9D%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[关于新年做自己守护者，愿自己，身体健康。(图源：包图网)]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5语义化标签及其兼容性解决]]></title>
    <url>%2F2019%2F01%2F26%2Fh5%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E5%8F%8A%E5%85%B6%E5%85%BC%E5%AE%B9%E6%80%A7%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[html5的语义化标签确实为我们带来了许多方便，但是如何解决他的兼容性代码也是需要我们去解决的，简单分析一下h5的相关使用 h5带来了哪些好处 比较利于开发人员使用,不需要去仔细阅读每一个类，就可以较为清楚地分析出网页的整体结构。 利于SEO-搜索引擎优化,搜索引擎也要分析我们的网页，当时用了h5的时候，他也可以很方便的寻找出网页的重点部分，排名靠前。 (左为h5 右为传统网页) h5带来的问题 最大就是兼容性，在IE8及其以前是不支持h5的，并且会将其解析为行间元素，涉及到h5标签(包括h5的相关api)，以及大部分的css3属性 IE9的显示效果 IE8的显示效果，（IE8是将其转换为行间元素进行解析） 如何解决兼容性问题 首先使用js创建元素，document.createElement(&#39;header&#39;) 设置其css的display：block 在这里可以使用html5shiv.js这个插件来帮我们完成,需要注意的一点，此处我们需在网页的最开始引入此js文件 如何判断我们是否需要去引入该插件 因为只有IE8及其以前的版本需要处理，那在其他的浏览器下就是不太需要的操作 （X）使用js的userAgent来进行判断,应为我们需要最开始来加载，所以不能使用js的方式来判断 （√）使用条件注释的方式来进行判断 123&lt;!--[if lt IE 9]&gt; &lt;h1&gt;您的浏览器版本过低，请及时更新您的浏览器&lt;/h1&gt;&lt;![endif]--&gt; (这里 lt&lt; lte&lt;= gt&gt; gte&gt;=) 处理兼容性的代码 123&lt;!--[if lt IE 9]&gt; &lt;script src="bower_components/html5shiv/dist/html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[loading过渡动画的使用]]></title>
    <url>%2F2019%2F01%2F18%2Floading%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用loading相关插件优化用户体验 在使用ajax刷新数据的时候，中间的间隔可以使用一些过渡动画增加用户体验 首先选用一些动画插件 比如此处的http://loading.awesomes.cn/找到要使用的样式 插入相关的代码，这里可以单独列出文件整合起来 html代码 123456&lt;!--loading动画--&gt;&lt;div class="ball-pulse-sync" style="display: none"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; css代码 123456789101112131415161718192021222324252627282930313233343536373839404142 /*loading动画的样式表*/.ball-pulse-sync &#123; transform: scale(1);&#125;.ball-pulse-sync &gt; div:nth-child(1) &#123; -webkit-animation: ball-pulse-sync 0.6s -0.14s infinite ease-in-out; animation: ball-pulse-sync 0.6s -0.14s infinite ease-in-out;&#125;.ball-pulse-sync &gt; div:nth-child(2) &#123; -webkit-animation: ball-pulse-sync 0.6s -0.07s infinite ease-in-out; animation: ball-pulse-sync 0.6s -0.07s infinite ease-in-out;&#125;.ball-pulse-sync &gt; div:nth-child(3) &#123; -webkit-animation: ball-pulse-sync 0.6s 0s infinite ease-in-out; animation: ball-pulse-sync 0.6s 0s infinite ease-in-out;&#125;.ball-pulse-sync &gt; div &#123; background-color: #fff; width: 15px; height: 15px; border-radius: 100%; margin: 2px; -webkit-animation-fill-mode: both; animation-fill-mode: both; display: inline-block;&#125;@keyframes ball-pulse-sync &#123; 33% &#123; -webkit-transform: translateY(10px); transform: translateY(10px); &#125; 66% &#123; -webkit-transform: translateY(-10px); transform: translateY(-10px); &#125; 100% &#123; -webkit-transform: translateY(0); transform: translateY(0); &#125;&#125; 设置其元素显示的时机，这里提供一种可以居中的方式 css代码 123456789101112.ball-pulse-sync&#123; display: flex; /*使用flex布局*/ align-items: center; /*居中*/ justify-content: center; /*居中*/ position: fixed; /*固定于浏览器*/ z-index: 1001; /*设定层级*/ background: rgba(0,0,0,.7); /*背景色*/ left: 0; right: 0; top: 0; bottom: 0; &#125; 可以使用jquery的 fadeIn() 与 fadeOut() 方法 在&lt;div style=&quot;display:none&quot;&gt;···&lt;/div&gt; 之所以设置display:none 是为了淡入淡出可以恢复 display:flew的特性（jQuery默认是display:block） 效果图 其实使用这种进度条，或是加载函数都是一种表面的东西，其内部是一些函数，会走的越来越慢，当加载完毕的时候一下子走通，造成了一种进度条的感觉，实际是ajax开始一个动作，结束一个动作// jQuery中的统一ajax $(document).ajaxStart(function(){ // ajax开始的代码 }).ajaxStop(function(){ // ajax结束的代码 });]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦·书·电影]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%A2%A6%C2%B7%E4%B9%A6%C2%B7%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[想要把自己活成一场梦，一本书,一步电影。 – 齐一 00：20平安夜，everyone,祝平安，快乐，每个人都会得到想要的！加油！]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可能否]]></title>
    <url>%2F2018%2F12%2F08%2F%E5%8F%AF%E8%83%BD%E5%90%A6%2F</url>
    <content type="text"><![CDATA[可能否春天的风 能否吹来夏天的雨 秋天的月 能否照亮冬天的雪 夜空的星 能否落向晨曦的海 山间的泉 能否遇上南飞的雁 能否早一点 看透命运的伏线 能否不轻易就深陷 能否慢一点 挥霍有限的时间 能否许我一个永远 可能我撞了南墙才会回头吧 可能我见了黄河才会死心吧 可能我偏要一条路走到黑吧 可能我还没遇见 那个她吧 断掉的弦 能否扯破自缚的茧 熄灭的火 能否烧光残留的念 梦中的云 能否化作熟悉的脸 前世的劫 能否换来今生的缘 能否早一点 相信年少的誓言 能否不轻易说再见 能否慢一点 感受岁月的缱绻 能否许我一次成全 可能我撞了南墙才会回头吧 可能我见了黄河才会死心吧 可能我偏要一条路走到黑吧 可能我还没遇见 那个她吧 可能我撞了南墙才会回头吧 可能我见了黄河才会死心吧 可能我偏要一条路走到黑吧 可能我还没遇见 那个她吧 可能我还没忘掉 哪个她吧 可能否 – 木小雅 2018-12-08 杭州 · 杭州电子科技大学 · 雪]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你所遭受的苦难，都将在未来的某个时刻派上用场]]></title>
    <url>%2F2018%2F11%2F26%2F%E4%BD%A0%E6%89%80%E9%81%AD%E5%8F%97%E7%9A%84%E8%8B%A6%E9%9A%BE%EF%BC%8C%E9%83%BD%E5%B0%86%E5%9C%A8%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%9F%90%E4%B8%AA%E6%97%B6%E5%88%BB%E6%B4%BE%E4%B8%8A%E7%94%A8%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[加油，一切都会过去！干！ 2018-11-26&#160; &#160; 23:26 杭州·杭州电子科技大学]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定制bootstrap的列相关]]></title>
    <url>%2F2018%2F11%2F08%2F%E5%AE%9A%E5%88%B6bootstrap%E7%9A%84%E5%88%97%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[如何定制bs的栅格 BS（bootstrap）默认是以12列，那么我们如果想布局5列的话，就比较困难了，(12/5不能整除的，所以我们布局五列的时候，使用原生的bs进行调整就很困难了)这里我们可以使用bs的定制功能，定制一个我们自己想要的列数等，这里我们使用15列为基础，则每一列占3列 col-sm-3 去bs官网进行定制并下载 官网 下载之后js,css,font 完成定制之后，我们的列就已经变成了15列，那么我们此时进行普通的操作即可。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的基本操作及Jdk,MySQL,Tomcat]]></title>
    <url>%2F2018%2F10%2F29%2FLinux%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%8F%8AJdk-MySQL-Tomcat%2F</url>
    <content type="text"><![CDATA[Linux 中的一些 常用操作 目录的操作 创建文件夹 mkdir &lt;name&gt; 查看隐藏文件 ls -a 查看文件的详细信息 ls -l或者是ll 修改目录名称 mv &lt;oldName&gt; &lt;newName&gt; 拷贝操作 cp -r &lt;src&gt; &lt;dest&gt; 删除操作 rm -rf &lt;fileName&gt;使用提示rm -r &lt;fileName&gt; 在输入y或者n选择是否确定删除 文件的操作 cat &lt;fileName&gt; 查看某个文件的最后一屏幕 more &lt;fileName&gt; 查看文件的所有，回车是一行 空格下一页 less &lt;fileName&gt; 查看文件页的形式，使用上下页查看，PageUp键向上 PageDown键向下 q结束查看 tail -&lt;n&gt; &lt;filename&gt; 查看文件的后n行 tail -f &lt;fileName&gt; 查看文件的日志 ll -h 查看文件的大小 文件的编辑 使用vi或者vim进入文本编辑器 i,o进行文本编辑 :wq保存并退出 writeQuit :q 不保存退出 quit 文件的压缩(tar只是打包命令 文件大小没有多少区别 .tar.gz是加入gzip指令，会压缩存放) -c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 一些可选指令更在后面即可 -z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出 -f: 使用档案名字，必须放在最后 操作 压缩 tar -cvf &lt;tarName&gt;.tar *.jpg 进所有jpg压缩进tarName.tar tar –czf &lt;tarName&gt;.tar.gz *.jpg 打成gz包 tar –cjf &lt;tarName&gt;.tar.bz2 *.jpg 打成bz2包（bz2压缩比高一些） tar –cZf jpg.tar.Z *.jpg 打成Z包 操作 解压 tar –xvf &lt;fileName&gt;.tar 解压tar包 tar -xzvf &lt;fileName&gt;.tar.gz 解压tar.gz tar -xjvf file.tar.bz2 解压 tar.bz2 tar –xZvf file.tar.Z解压tar.Z&lt;!–暂时有一些问题 文件权限的修改 r读权限 w写权限 x 操作权限 chmod u=--- g=--- o=--- &lt;fileName&gt;修改文件的权限，要分三组来看 –&gt; 系统管理命令 查看时间date 设置时间date -s &quot;yyyy-MM-dd HH:mm:ss&quot; 查看分区情况 df查看xxG或者xxM df -h 显示内存 free 查看xxG或者xxM free -h 清屏 clear 显示登录日志信息 who 显示主机名称 hostname 系统信息 uname 详细信息 uname -a 其他一些指令 pwd 查看当前文件目录 grep &lt;keyword&gt; &lt;fileName&gt; --color在fileName中查看keyword关键字并且高亮 ps -ef查看当前的进程 kill -9 &lt;pId&gt;干掉进程 netstat -an查看端口的使用情况 命令的逻辑 &amp;&amp;和编程中一样，逻辑与 &lt;command1&gt; &amp;&amp; &lt;command2&gt; 命令1执行成功 后执行 命令2 命令1执行失败 不执行 命令2 ||和编程中类似有短路效果&lt;command1&gt; || &lt;command2&gt; 命令1执行成功 不执行 命令2 命令1执行失败 后执行 命令2 创建一个公共的文件夹 供Vm共享的文件夹 打开Vm中的共享文件夹 根目录下mnt/hgfs/可看到我们刚刚设置的公共文件夹 服务 rpm -qa | grep &lt;keywords&gt; 查看服务 rpm -e --nodeps &lt;name&gt; 删除相关服务 安装JDK的操作 rpm -qa | grap java查询是否安装了jdk 解压jdk tar -zxvf &lt;jdkName.tar.gz&gt; 配置 /etc/profile中文件vi /etc/profile 添加如下的操作，注意此处的/usr/java/xxx/jdkxxx(下一层就有bin了，同时这个文件夹也是刚刚解压出来的) #java environment export JAVA_HOME=/usr/java/&lt;directoryName&gt; export CLASSPATH=.:${JAVA_HOME}/jre/lib/rt.jar:${JAVA_HOME}/lib/dt.jar:${JAVA_HOME}/lib/tools.jar` export PATH=$PATH:${JAVA_HOME}/bin 最后source /etc/profile 安装MySQL的操作(一定要注意路径的修改 software/文件,data/数据库) 创建文件夹(可根据需求定制) 新建文件夹 xxx/mysql/software/MySQL程序 新建文件夹 xxx/mysql/data/数据库文件 复制文件过去 cp 指令并解压tar指令 创建用户和组 groupadd mysql useradd -r -g mysql mysql 关联myql用户到mysql用户组中 #chown -R mysql:mysql /software/mysql/ #chown -R mysql:mysql /data/mysql/ #chown -R mysql /software/mysql/ #chown -R mysql /data/mysql 更改mysql安装文件夹mysql/的权限 chmod -R 755 /software/mysql/ 注意根据需要 安装libaioyum install libaio 进行数据库的初始化工作./mysqld --user=mysql --basedir=/software/mysql --datadir=/data/mysql --initialize 注意root@localhost: (oiwsWz7-dhc这里的初始密码！切记！切记！ 修改mysql配置文件vim /software/mysql/support-files/mysql.server保存退出后拷过去cp /software/mysql/support-files/mysql.server /etc/init.d/mysqld，并添加权限chmod 755 /etc/init.d/mysqld if test -z “$basedir”thenbindir=/software/mysql/binif test -z “$datadir”thendatadir=/data/mysqlfisbindir=/software/mysql/binlibexecdir=/software/mysql/binelsebindir=”$basedir/bin”if test -z “$datadir”thendatadir=”$basedir/data”fisbindir=”$basedir/sbin”libexecdir=”$basedir/libexec”fi 修改my.cnf文件vim /etc/my.cnf [client] no-beep socket =/software/mysql/mysql.sock # pipe # socket=0.0 port=3306 [mysql] default-character-set=utf8 [mysqld] basedir=/software/mysql datadir=/data/mysql port=3306 pid-file=/software/mysql/mysqld.pid #skip-grant-tables skip-name-resolve socket = /software/mysql/mysql.sock character-set-server=utf8 default-storage-engine=INNODB explicit_defaults_for_timestamp = true # Server Id. server-id=1 max_connections=2000 query_cache_size=0 table_open_cache=2000 tmp_table_size=246M thread_cache_size=300 #限定用于每个数据库线程的栈大小。默认设置足以满足大多数应用 thread_stack = 192k key_buffer_size=512M read_buffer_size=4M read_rnd_buffer_size=32M innodb_data_home_dir = /data/mysql innodb_flush_log_at_trx_commit=0 innodb_log_buffer_size=16M innodb_buffer_pool_size=256M innodb_log_file_size=128M innodb_thread_concurrency=128 innodb_autoextend_increment=1000 innodb_buffer_pool_instances=8 innodb_concurrency_tickets=5000 innodb_old_blocks_time=1000 innodb_open_files=300 innodb_stats_on_metadata=0 innodb_file_per_table=1 innodb_checksum_algorithm=0 back_log=80 flush_time=0 join_buffer_size=128M max_allowed_packet=1024M max_connect_errors=2000 open_files_limit=4161 query_cache_type=0 sort_buffer_size=32M table_definition_cache=1400 binlog_row_event_max_size=8K sync_master_info=10000 sync_relay_log=10000 sync_relay_log_info=10000 #批量插入数据缓存大小，可以有效提高插入效率，默认为8M bulk_insert_buffer_size = 64M interactive_timeout = 120 wait_timeout = 120 log-bin-trust-function-creators=1 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES&lt;br/ # # include all files from the config directory # !includedir /etc/my.cnf.d 启动/etc/init.d/mysqld start 登录mysql/software/mysql/bin/mysql -u root –p p 为上一步的临时密码 (oiwsWz7-dhc 最后进入mysql修改初始密码即可ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;新密码&#39;##Tomcat的安装## 解压tomcat并放到所需的文件夹下 打开防火墙的8080端口（也可打开80端口） firewall-cmd --zone=public --add-port=8080/tcp --permanent 8080port firewall-cmd --zone=public --add-port=80/tcp --permanent 80port firewall-cmd --reload重启防火墙 打开服务器即可 tomcat/bin目录下的 开启./startup.sh 关闭 ./shutdown.sh]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为你我受冷风吹]]></title>
    <url>%2F2018%2F10%2F20%2F%E4%B8%BA%E4%BD%A0%E6%88%91%E5%8F%97%E5%86%B7%E9%A3%8E%E5%90%B9%2F</url>
    <content type="text"><![CDATA[第一次用自己的力量做公益！ 浙江·杭州辰星儿童早期干预中心 记一次公益墙绘行！ 微信推文 &#160; &#160; &#160; &#160;经过了两周的准备，从开始联系记者，老师，到后来跟进项目计划，再到后来策划颜料，人员，发票，再到每个人中午的午饭问题，一切都是新的开始，让我一个非艺术生去带他们画画，还是有点意思的！但是，这次活动总体而来还是很不错的，学到了很多，也看到了他们的优秀，强就对了！ 话不多说，上图早上7:50出门，找到车站已经快8:30了，哈哈 先是铅笔构图打底子 到了午饭时间，是胃口大还是饭订少了！嘻嘻，真香！吃就对了 底子打起来 屋内的哆啦A梦主题，画起来还是很起劲的嘛！ 这两只鲸鱼还是很有爱的！一进门看到是不很舒爽，不接受反驳 最后的成果走一波 公交车我们包了！都累成了狗！哈哈，不过确实是充实的一天 最后愿大家：前程似锦，海阔任鱼跃，天高任鸟飞！这不是套话，是真心对你们的祝福！(ﾉ´▽｀)ﾉ♪]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git中分支相关的操作]]></title>
    <url>%2F2018%2F10%2F18%2FGit%E4%B8%AD%E5%88%86%E6%94%AF%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[为什么要存在分支 如果只有一个主分支master那么我们在提交或是 修改的时候很容易影响到其他的代码或是文件，所以这里就需要引入一些分支，在这个分支修改好之后，再推送到主分支上。 一般Master分支是最稳定的一个分支，用于发布版本使用 新建一个分支 $ git branch &lt;branchName&gt; 新建一个分支 切换一个分支 $ git checkout &lt;branchName&gt; 切换一个分支，这里可以使用一个比较快捷的操作，再新建完分支 直接切换过去$ git checkout -b &lt;branchName&gt; 直接新建并且切换到该分支 分支的删除 $ git branche -d &lt;branchName&gt; 可以删除这个分支 分支的合并$ git merge &lt;branchName&gt; 先切换到需要被 合并的分支 比如主Master分支 之后进行分支的合并$ git merge &lt;branchName&gt; 如果出现了冲突，那么我们就在本地解决 冲突，最后不要忘记本地的提交 add与commit]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git的与远程仓库搭配的使用]]></title>
    <url>%2F2018%2F10%2F18%2FGit%E7%9A%84%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%90%AD%E9%85%8D%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[了解向远程仓库通讯 &#160; &#160;&#160; &#160;在远端的Git仓库中 比如我们在github中的仓库，会涉及到对文件的上传与下载下载 文件push（推送）到远程仓库&#160;$ git push &#160; &#160;&#160; &#160;在向远程的仓库进行提交文件的时候，他会覆盖到原来的一个版本，所以在push之前我们要做好准备。 文件pull（拉取）到本地仓库&#160;$ git pull &#160; &#160;&#160; &#160;在向本地仓库拉取文件的时候，很可能会出现 与远程仓库不一致的情况，这个时候与本地合并分支比较类似，他会在本地有冲突的文件做一些提示，我们在本地修改好之后直接提交即可，注意这时一定不要忘了 提交$ git add .与$ git commit -m&#39;&#39;与本地保持一致，这个时候本地仓库就已经是与远程仓库相同的情况。 文件远程同步的步骤 一般情况下 先是从远程仓库 pull下来，此时有冲突 也比较好解决 再解决相应的冲突 即可将代码push推送的远程仓库]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git的基本本地操作]]></title>
    <url>%2F2018%2F10%2F18%2FGit%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AC%E5%9C%B0%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[首先需要了解的就是Git大致仓库的含义 &#160; &#160;&#160; &#160;Git中仓库（.git文件）其实他的含义并不是一个真正的仓库，只是一个存放文件状态的一个位置，真正的文件还是在我们的文件夹中。&#160; &#160;&#160; &#160;那么也就是说他的文件夹存放的时文件状态的一些文件，可以使用这些状态文件，恢复到任何一个版本的文件，也就是达到了所谓的仓库的概念。 为什么使用暂存盘与仓库 &#160; &#160;&#160; &#160;之后需要明确的一点就是 Git中的暂存盘 与 仓库的区别他是先将文件放到暂存盘中，之后一起拿去做提交更改，很类似公交车拉人的一种感觉，拉满了一车过去，就会提高一些效率。 文件提交的的流程 先将文件 $ git add a.txt 将a.txt这个文件放到暂存盘中 再将文件 $ git commit -m &#39;提交了文件a.txt&#39; 将这个a.txt做一次提交，也就是将此次状态保存到了git仓库里。 文件修改的的流程 首先已经提交过文件了确保这个文件在git的管理中 $ git add b.txt 将b.txt这个文件放到暂存盘中 对b.txt这个文件做一些操作，之后文件的状态发生改变,出现没有暂存的修改 我们需要将这个修改添加到暂存盘中 $ git add b.txt现在他已经在我们的暂存盘中了 最后一波提交即可$ git commit -m &#39;提交了文件b.txt&#39;现在b.txt文件的状态也已经存储到仓库中了 文件删除的的流程 首先已经提交过文件了确保这个文件在git的管理中 $ git add c.txt 将c.txt这个文件放到暂存盘中 c.txt这个文件删除rm c.txt此时该文件目前是被删除（文件夹中查看是不见的） 此时我们确定删除，$ git commit -m &#39;删除了c.txt&#39;现在c.txt文件被删除的状态也已经存储到仓库中了 一些撤销的操作 当我们修改/删除了文件 没有提交到暂存盘的时候我们可以使用 $ git checkout --file进行回退操作（这里不加–也是可以的$ git checkout file容易和分支搞混） 当我们修改/删除了文件 已经提交到暂存盘的时候我们可以使用 $ git reset file将文件从暂存区撤回（现在相当于修改了未提交），之后进行上面的操作即可 一些版本回退的操作 我们可以使用 $ git log 查看历史纪录 也可以使用 $ git reflog 查看历史纪录,此时查询出的历史记录是带一些版本号，便于我们恢复 git reset –hard HEAD~3`前3步 我们可以使用$ git reset --hard xxxxx回退到指定的步数 也就是我们在$ git reflog查询出的序列号]]></content>
  </entry>
  <entry>
    <title><![CDATA[hello Hexo(1)]]></title>
    <url>%2F2018%2F09%2F13%2Fhello-Hexo%2F</url>
    <content type="text"><![CDATA[Hello-markdownJAVA！ 2018-09-13 15:36杭州·杭州电子科技大学]]></content>
  </entry>
</search>
